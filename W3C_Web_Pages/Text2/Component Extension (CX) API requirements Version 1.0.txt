Component Extension (CX) API requirements Version 1.0 Component Extension (CX) API requirements Version 1.0 W3C Note 11 December 2001 This version: http://www.w3.org/TR/2001/NOTE-CX-20011211 Latest version: http://www.w3.org/TR/CX Editors: Angel Diaz, IBM Jon Ferraiolo, Adobe Stein Kulseth, Opera Philippe Le Hégaret, W3C Chris Lilley, W3C Charles McCathieNevile, W3C Tapas Roy, Openwave Ray Whitmer, Netscape/AOL Copyright©2001 W3C® (MIT, INRIA, Keio), All Rights Reserved. W3C liability,trademark,documentuse, and softwarelicensing rules apply. Abstract From the early days of the World Wide Web, Web Agents had been extended tosupport more types of contents. The recent developments of XML and thepossibility to mix mupltiple XML Namespaces in the document reiterated theneed to extend implementations and relaying on add-on softwares to accomplishtasks not supported by default in the implementation. In other words, we haveseveral XML languages to represent different parts of Web pages (XHTML, SVG,MathML, XForms, etc.), we now need a well defined mechanism that allowdifferent specialized tools to work together and handled these compounddocuments. This W3C Note contains a non-exhaustive list of requirements to work on aComponent Extension API. The goal of this API is to extend the ability of a Web application.Note that the Web application can be either on the server side or on a clientside, and does not automatically implies interaction with a user or having aWeb browser. Status of this Document This document is an early draft resulting from the HyperText CoordinationGroup face to face meeting to discuss standardization of Plug-in and ActiveComponent Architecture for the Web. It is anticipated that this will bepublished as a W3C note as soon as it has reached an appropriate state ofmaturity. This document is a Notemade available by the W3C for discussion only. Publication of this Note byW3C indicates no endorsement by W3C or the W3C Team, or any W3C Members.There is no commitment by W3C to invest additional resources in topicsaddressed by this Note. Comments on this document are invited and are to be sent to the publicmailing list www-component-extension@w3.org.An archive is available at http://lists.w3.org/Archives/Public/www-component-extension/. W3C Technical reports are publishedonline at http://www.w3.org/TR. Table of Contents 1 Requirements 1.1 Formatting 1.1.1 baseline and linehight 1.1.2 linebreak, size and rectangle negotiation, multiplerectangles 1.1.3 DOMViews and Formatting 1.2 Rendering 1.2.1 freeze/unfreeze 1.2.2 z-order/painting 1.2.2.1clipping 1.2.3 sharingcolormap 1.2.4 sharingfonts 1.2.5 colors(accessibility issues) 1.2.6 Devicedependent drawing 1.2.7 forcingredraws, invalidate rectangles, invalidate region 1.2.8 window-less plug-in 1.3 Style 1.3.1 DOMCSS 1.3.1.1specified values 1.3.1.2computed values 1.3.2 actual values 1.3.3 Generic Styler 1.3.4 Local Styler 1.3.5 Mobile profiles 1.4 Error handling 1.5 Events 1.6 DOM Core tree 1.7 Starting point 1.8 Connecting withoutside/scripting 1.9 Nesting/reetrance 1.10 Abstraction level 1.11 timeline 1.12 network/HTTP 1.13 Editing 1.13.1 Editing mode 1.14 associations/registrations/negociations 1.15 Accessibility 1.16 Versioning 1.17 storage/persistence 1.18 Memory management 1.19 Security Appendices A Glossary B References C Contributors 1 Requirements This document contains a description of the Component Extension requirements established during theHyperText CG meeting in August 2001. It classifies the Application Programming Interface (API) requirements in 3categories: [1] The requirement must be addressed by the Component Extension API. [2] The requirement may be addressed by the Component Extension API. [3] The requirement is declared out of the scope of the Component Extension API. It might become in its scope in future versions. The description of a Component Extension must be in terms of content thatis handled, not in terms of a specific piece of software. For example, it isappropriate to request a Component Extension that handles SVG [SVG 1.0], including some set of functionalities (forexample identified using the SMIL required functionalities mechanism for theswitch element, or the SVG equivalent). The list of requirements provided in this document is not exhaustive andonly reflects the requirements from the HyperText CG meeting. 1.1 Formatting [1] The Host implementation must provide amechanism for an embedded object to request a region or set of regions fordisplaying content. The formatting interface should be independent ofplatform specific constraints. 1.1.1 baseline andlinehight [1] The Host implementation and Component Extension need to coordinate thelinehight and the baseline. 1.1.2 linebreak,size and rectangle negotiation, multiple rectangles [1] The Host shall provide means to determine the maximum size of therectangle into which the embedded object may render. Conceptually, the sizeof this page may be unconstrained in both dimensions given scrolling. Inpractice, the Host must somehow constrain this in at least one dimension. For example, the Host may indicate that this rectangle is scrollable inthe line-stacking direction. It must fix the other dimension. Typically, itwould report the current width of its renderable area. The embedded object must be permitted to negotiate rectangles and breakinto smaller areas across lines if need be. 1.1.3 DOM Views andFormatting [2] The [DOM Level 3 Views and Formatting] should beconsidered by the Component Extension API. 1.2 Rendering [1] 1.2.1 freeze/unfreeze[1] A Component Extension may wish to suspendrendering momentarily while for example a succession of changes are made tothe structure, or the structure is made temporarily invalid, or for someother reason whereby the intermediate state of the document is no to bedisplayed. Examples of such methods: SVG DOM: SVGSVGelement   unsigned long suspendRedraw(in unsigned long max_wait_milliseconds);  void          unsuspendRedraw(in unsigned long suspend_handle_id)                  raises(DOMException);  void          unsuspendRedrawAll();  void          forceRedraw();  void          pauseAnimations();  void          unpauseAnimations();                See also section 5.11 in [SVG10]. Openwave plugin API PluginSuspend and PluginResume methods. 1.2.2 z-order/painting[1] It should be possible for content which is rendered by Component Extensions to take its correct place in the z-orderof the entire document - it can be above other content such as backgrounds,which show through transparent areas, and other content later in the documentor with higher z-order should be able to partially overlap content renderedby the Component Extension. 1.2.2.1 clipping [1] Clipping, which addresses removal of parts of display elements thatlie outside of a given boundary, must be addrssed by the ComponentExtension. 1.2.3 sharing colormap[2] Implementations which require a colormap will need to allow the Component Extension to request the allocation ofcolors in the colormap and to find out what colors are already in thecolormap, and to be notified if the color associated with a particular colorindex has changed. 1.2.4 sharing fonts[2] The Component Extension should have access tosystem fonts and their properties. The Host implementation provide means forquerying metrics of the current font. Metrics of interest could be a subsetof those provided by [OpenType]. The Hostimplementation should provide methods for determining glyph bounding boxes,baselines, and nominal font height. It should also provide an indicationwhether a given character maps to a glyph in that font. The Component Extension should be able to find out aboutdownloadable fonts that other content on the same page has made available,and itself to make available fonts that it has downloaded. The fontproperties in use on the parent of the element whose content is beingrendered by the Component Extension should be madeavailable by inheritance over the ComponentExtension interface so that the same fonts can be used by the Component Extension. Accessibility information about preferred font sizes should be passedacross the Component Extension interface. 1.2.5 colors(accessibility issues) [1] 1.2.6 Device dependentdrawing [1] Component Extension API should provide aplatform dependent (e.g. XWindow Graphic Context, Microsoft Device Context)method for gathering device dependent information for formatting and drawinginto each of the rectangles (e.g. for optimisation of drawing, such aswindow, device context, fonts). However this must not preclude the ability touse device independent methods, and the specification should recommend thatthese are available as a fallback. 1.2.7 forcing redraws,invalidate rectangles, invalidate region [1] In the Component Extension-does-compositing model with direct screendrawing, a Component Extension might damagecontent rendered by something else. This is like the situation in windowingsystems where a window is iconised and (portions of) other windows that arenow uncovered have to be told to redraw. The container-does-compositing model, with rendering being an offscreenRGBA pixmap, does not have this problem and need not tell its parents orother Component Extensions to redraw. Moving orupdate of a Component Extension merely requiresre-composition of the current stack of offscreens without the need for aforced redraw, though this can be limited to a particular invalidatedregion. Issue (rectangle-region-1): These descriptions narrowly miss actually listing a requirement. Make itsimpler. See also [Netscape Plug-ins]. 1.2.8 window-less plug-in[1] Component Extension which do not draw at allshould be addressed by the Component ExtensionAPI. See also [Netscape Plug-ins]. 1.3 Style [1] 1.3.1 DOM CSS [1] This section describes the relation between the Component Extension API and the Document Object Model (DOM)Level 2 CSS specification [DOM Level 2 Style Sheets andCSS]. 1.3.1.1 specified values[3] Unlike the DOM Level 2 CSS specification [DOM Level 2Style Sheets and CSS], this note does not require access to the specifiedCSS values in the style sheets. 1.3.1.2 computedvalues [1] If the Host implementation provides a DOMtree to the Component Extension and a CSS Style engine, the Component Extension API must have access to the computed CSSvalues of its nearest DOM Node ancestor (its parentNode) using the DOM Level2 CSS [DOM Level 2 Style Sheets and CSS] ViewCSSinterface. Depending on the CSS Style engine, the Host Implementation mayalso provide a fully decorated DOM tree for the content addressed by the Component Extension. 1.3.2 actualvalues [3] Actual CSS values, as defined in the CSS specification [CSS Level 2], will not be addressed by the Component Extension API. 1.3.3Generic Styler [1] The Host implementation should contain aStyle engine to handle general properties and to provide extension mechanismin order to support other properties. This Generic Styler engine has theresponsibility of decorating the DOM tree with the computed values (see also1.3.1.2 computed values). Languages, such as CSS, have mechanism to extend the set of styleproperties used in the application. As an example, SVG 1.0 [SVG 1.0] reused some of the properties listed in the CSS 2specification [CSS Level 2] and adds new ones. It isexpected that the Generic Styler of the Hostimplementation supports a specific set of properties and some generalstyle properties such as color, background or fonts are required to besupported. [Definition: A foreign style property is a styleproperty that is not recognized internally by the Generic Styler.] TheGeneric Styler does not know its default value, or if the value could beinherited or not. The Generic Styler is expected to support foreign styleproperties. The Component Extension should declareinformation on style properties it uses that may be foreign to the GenericStyler such as parse, default values, inheritance, ... The Styler isresponsible for maintaining the information and dealing with duplicatedeclarations between Component Extensions. A Component Extension remove styleproperties or values associated with the style properties. In other words,the set of style properties stored by the Generic Styler is the union of theset of style properties supported by the Hostimplementation and its Component Extensions.If a computed value is not recognized, the Generic Styler can: use a default value like for colors, always make the computed value have two parts a value in first set of values a possible extended value have extended value + callback Issue (generic-style-engine-1): What to do about style sheets when it is not known what ComponentExtension will be loaded? 1.3.4 LocalStyler [2] The Component Extension can also embedded itsown local Style engine. In this case, the Component Extension does not needto declare or get the computed values of the style properties in a DOM tree.This model has the advantage to not assume a DOM API between the Host implementation and the ComponentExtension, and only applies to the root node of Component Extension (svg:svg,math:math, ...). The local Style engine needs to provide: access to style sheets. access to containing DOM tree (optional). access to the [parent] information item in order to get the computed values of the style properties: propname -> value [1] access to style properties information: propname -> inherit/initial value. [1] 1.3.5 Mobile profiles [1] Mobile profiles are always required to be supported by the Hostimplementation and its Component Extensions. 1.4 Error handling[2] An error handling mechanism should be provided by the Host implementationto the Component Extension in a future revision ofthe Component Extension API. This mechanism may bebased on, or inspired from, the error handling mechanism provided by the DOMLevel 3 Core specification [DOM Level 3 Core]. 1.5 Events [1] There must be a way to pass events from the Hostimplementation to the Component Extension andfrom the Component Extension to the Hostimplementation. If the Host implementationprovides a DOM tree to the component extension and contains an eventmechanism, the Component Extension API must support the DOM Level 2 Eventsspecification. User Interface events, such as window events or system events(reload, URI notify events), may be addressed. Namespace-bound events are events whose propagation is limited to elementsnamespace boundaries, i.e. it propagates until it reaches an element who doesnot use its ancestor's namespace name. Namespace bound events are out ofscope. 1.6 DOM Core tree[1] The Component Extension API must provideprogrammatic read-only access to HTML and XML content by conforming to thefollowing modules of the W3C Document Object Model Level 2 Core Specification[DOM Level 2 Core] and exporting the interfaces theydefine: the Core module for HTML the Core and XML modules for XML. 1.7 Starting point[1] Features of the existing Netscape Plugin API [Netscape Plug-ins] should considered as a startingpoint with implementation experience for features of the Component Extension API, which may be modified, replaced, oreliminated as required to address problems and requirements. 1.8Connecting with outside/scripting [1] The Component Extension will call a Host implementation function to request a connection to oneof its features. This feature may be a generic functionality (eg. "copy/paste", whetherthis is selected by button, menu item, keyboard shortcut, drag-drop, or ...) or a specific Host implementation chrome (eg. toolbar, button, status bar ... ). The request can be to output data through the feature (eg. status bar,title bar, alert, ...), to subscribe to events generated from a browsercontrol, or to add a control to the chrome (eg. toolbar, menubar, menu...) The Host implementation should return a valueindicating whether it allows the connection or not. The Component Extension API should define howthe features are selected, and specify a minimal list of connections that thebrowser *should* allow if it does have the requested feature, so that the Component Extension can reasonably expect such aconnection request to be granted. Subscribed-to events can be passed to the ComponentExtension using the normal event-passing mechanism (see 1.5 Events). If the connection needs to pass largeamounts of data, the Component Extension's streamAPIs should be used. chrome [1] adding new items/removing new items "right-click drop down menu"/main menu bar status line copy/paste find drag/drop focus alert [1] query user agents capabilities? cross plug-in streams properties [2] properties dialog system properties: hostname, IP, ... 1.9Nesting/reetrance [1] It must be possible for a Component Extensionto discover, where available, and integrate the formatting and rendering ofexternally supported content types inserted into the Component Extension DOM Node's subhierarchy that are notinternally supported by the ComponentExtension. 1.10Abstraction level [1] Much like the W3C DOM IDL descriptions and language bindings, theComponent Extension API must be described independent of programminglanguage, operating system and platform. 1.11 timeline[2] SMIL 2.0 [SMIL 2.0] is a specification forsynchronized multimedia and SMIL Animation [SMILAnimation] is a specification for how the timing and animation aspects ofSMIL 2.0 can be integrated into other languages, such as SVG (see chapter 19in [SVG10]). If the Host implementation supportssynchronized playing of media such as audio, video or animations, then theHost implementation must support the ability for time-based Component Extensions to play media on a portion of a Hostcanvas, and the Host-played media and the Component Extension-played mediamust be synchronized. The API for achieving this synchronization must be richenough to permit accurate implementation of the 'syncBehavior' and'syncTolerance' attributes defined in the section 10.3.1 in [SMIL 2.0]. SMIL 2.0 and SMIL Animation allow content to be started and stopped viainteractivity, such as User Interface events (e.g., mouse and keyboard). Host-supplied event propagation APIs must be such that time-based Component Extensions can implement the interactivitycapabilities defined in the section 10.3.1, "Basic time support", in [SMIL 2.0]. If the Host implementation supports streamingmedia, then the Host implementation must supplyAPIs that allow Component Extensions to receivestreaming content. 1.12 network/HTTP[1] Networking Support will include an API to request the data from a URIreference. The Component Extension will call a Host implementation function and pass the URI reference, anyadditional headers (for example, in the case of HTTP, maybe an additionalaccept type), the method (in case of HTTP, GET, PUT, POST or HEAD) and apointer to a notify data. The Component Extensionmay tell the Host implementation to use thecache or to override it. When the request is complete, the Hostimplementation will call the ComponentExtension's notify function, and pass the data to the Component Extension using the ComponentExtension's stream APIs. Example:     kError HostURIRequest(kURIMethod method,                          const char *uri,                          const char *headers,                          const char *entity,                          unsigned long entitySize,                          void* notifyData,                          boolean useCache);    void   CXURINotify(const char *uri,                       kStatus status,                       void* notifyData);        Issue(networking-1): In the Netscape model [Netscape Plug-ins], thedata corresponding to a network request are sent to the Component Extension by the Hostimplementation by creating a stream: it is a callback mechanism. Should we reused this mechanism or do we want to tie all asynchronousrequests with one (probably DOM) event model ? 1.13 Editing [2] Many Component Extensions will involve editingfunctions, so the API must provide a method for access to editingfunctionalities - character input, drawing interfaces, etc. These must beavailable in a device independent manner. This requirement also means thatthe available rendering space may need to be dynamically re-sized (see also1.1.2 linebreak, size and rectangle negotiation,multiple rectangles). 1.13.1 Editing mode[1] The Component Extension API must provide an interface that allows thenotification of the toggle between "edit" and "view" modes. This API must bepresent on both the Host implementation and the Component Extension. 1.14associations/registrations/negociations [1] In order for the Component Extension to be ableto extend the Host DOM implementation, there must be a way for the Component Extension to register its own DOMimplementation in the Host DOM implementation. In that case, the DOMimplementation Node factories in Document must create DOM Nodes using theregistered Component Extensions Node for thecorresponding types. Only the construction of the DOM nodes is affected bythe registrations, not the building of the DOM tree. If the Component Extension does not provide a DOM implementation, theHost implementation must build the entire DOMtree itself, including for the content addressed by the Component Extension. If the Host implementation provides supportfor XML 1.0 [XML] documents, it must also implement thenamespaces support defined in the Namespaces recommendation [XML Namespaces]. Namespace conflicts resolutionbetween Component Extensions must be resolved bythe Host implementation. There must be a way forthe user to choose between Component Extensionimplementations in case of conflicts. The set of functionalities provided by the Hostimplementation must be accessible to the Component Extension. The sameapplies for the Component Extension: the Host implementation must have a way to query the set offunctionalities provided by the ComponentExtension. There are severals ways to extend the Host implementation. Technologiessuch as XBL or IE behaviors must be considered. The group might decide to come up with a modular architecture for an XMLparser that will permit some of the XML content to be handled by othercomponent. A general stream API should be addressed by the ComponentExtension to gain access to their data. 1.15Accessibility [2] The Component Extension API must provide foraccessibility requirements. Substantially, this reinforces the need forseveral of the requirements listed already, such as the ability to specify acontent-type rather than a plugin, the provision and use ofdevice-independent interaction interfaces. The User Agent Accessibility Guidelines [UUAG] requirethat access is provided for DOM interfaces, and "platform-specificinterfaces" (for example MSAA, the Java Accessibility API, etc) where theyexist. 1.16Versioning [1] The Component Extension API should have anidentifiable versioning mechanism. The version information must change eachtime the functionality is changed. I am not sure it is necessary to discuss techniques here, as is done inthe following paragraph. One technique for achieving this is to provide the naming forfunctionalities, and use a mechanism like CC/PP for identifying the availablefunctionalities. Although this seems a little heavy for this purpose, andseems to be better suited to using various unstandardized systems rather thanfor a standardized system. 1.17storage/persistence [2] The Host implementation will allow the Component Extension to save data in persistentstorage or a file system. This ability will be governed by the security modelassociated with the Component Extension. For example, a web page has the ability to store cookies in the filesystem of the host. But a sandbox model exists there. Furthermore, the usermay block web pages from setting cookies. The storage functionality can be divided into: Reading and Writing data specific to the Component Extension. ('Private' Storage) Example, saving high scores in a game. Storing cookies is an example in the context of a web page. Reading and Writing data from the global data. ('Public' Storage). Example, reading list of addresses (or a specific address) from an addressbook. [3] For the first item, the Host implementationmay provide the Component Extension APIs to getand set values. For example, to set: HostSetAttribute("newscore", itoa(newScore));        to read, length = HostGetDataSize ("highscores");if (length > 0){    scoreString = memAlloc (length);    HostGetAttribute ("highscores", scoreString);}        If the security settings of the ComponentExtension do not allow these operations, then these operations will fail.Or, the user maybe prompted for advice. See also [WAP Persistent Storage]. 1.18 Memory management[1] Memory management would include APIs for Allocating a block of memory Resizing the block of memory Releasing the block of memory and Flushing memory from the host's space. Issue(memory-1): how much memory should a plugin be allowed ? Probable answer: Systemdependent. If the allocation function fails, an exception will begenerated. Issue(memory-2): What about read/write? If the allocate APIs return a pointer, (as theNetscape APIs do), what will prevent a plugin to do something like           char* s = MemAlloc (100);          s[2000] = 'a';          On a system that doesn't have a memory management unit, this may freezethe system. 1.19 Security Security issues must be considered for each of the functionalities of theComponent Extension API. A Glossary Component Extension The term Component Extension (also well-known as plug-ins in Web browsers) refers to any software in charge of providing the client-side part of the Component Extension API. It is a program that runs as part of the Host implementation and that is not part of content. Host implementation The term Host implementation refers to any software in charge of providing the server-side part of the Component Extension API. Softwares may include Web browsers, media players, Component Extensions, and other programs (including assistive technologies) that help in retrieving and processing (this includes rendering) Web content. Application Programming Interface (API) An application programming interface (API) defines how communication may take place between applications. It is a set of functions or methods used to access some functionality. B References CSS Level 2 W3C (World Wide Web Consortium) Cascading Style Sheets, level 2 Specification, May 1998. Available at http://www.w3.org/TR/1998/REC-CSS2-19980512 DOM Level 2 Core W3C (World Wide Web Consortium) Document Object Model Level 2 Core Specification, November 2000. Available at http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113 DOM Level 3 Core W3C (World Wide Web Consortium) Document Object Model Level 3 Core Specification, September 2001. Available at http://www.w3.org/TR/DOM-Level-3-Core DOM Level 2 Style Sheets and CSS W3C (World Wide Web Consortium) Document Object Model Level 3 Views and Formatting Specification, November 2000. Available at http://www.w3.org/TR/2000/REC-DOM-Level-2-Style-20001113 DOM Level 3 Views and Formatting W3C (World Wide Web Consortium) Document Object Model Level 3 Views and Formatting, November 2000. Available at http://www.w3.org/TR/2000/WD-DOM-Level-3-Views-20001115 Netscape Plug-ins Netscape Plug-in Guide, 1998. Available at http://developer.netscape.com/docs/manuals/communicator/plugin/index.htm OpenType Microsoft OpenType Specification, April 2001. Available at http://www.microsoft.com/typography/otspec/default.htm RFC2396 IETF (Internet Engineering Task Force) RFC 2396: Uniform Resource Identifiers (URI): Generic Syntax, eds. T. Berners-Lee, R. Fielding, L. Masinter. August 1998. Available at http://www.ietf.org/rfc/rfc2396.txt SVG 1.0 W3C (World Wide Web Consortium) Scalable Vector Graphics (SVG) 1.0 Specification, September 2001. Available at http://www.w3.org/TR/SVG SMIL 2.0 W3C (World Wide Web Consortium) Synchronized Multimedia Integration Language (SMIL 2.0), August 2001. Available at http://www.w3.org/TR/smil20 SMIL Animation W3C (World Wide Web Consortium) SMIL Animation, September 2001. Available at http://www.w3.org/TR/smil-animation User Agent Accessibility Guidelines 1.0 W3C (World Wide Web Consortium) User Agent Accessibility Guidelines 1.0, September 2001. Available at http://www.w3.org/TR/UAAG10 WAP Persistent Storage WAP Forum (Wireless Application Forum) WAP Persistent Storage Interface , May 2001. Available at http://www1.wapforum.org/tech/documents/WAP-227-PSTOR-20010530-a.pdf XML W3C (World Wide Web Consortium) Extensible Markup Language (XML) 1.0, October 2000. Available at http://www.w3.org/TR/2000/REC-xml-20001006 XML Information set W3C (World Wide Web Consortium) XML Information Set, August 2001. Available at http://www.w3.org/TR/2001/PR-xml-infoset-20010810 XML Namespaces W3C (World Wide Web Consortium) Namespaces in XML, January 1999. Available at http://www.w3.org/TR/1999/REC-xml-names-19990114 C Contributors The people who contributed to this document are the members of theHyperText Coordination Group and the participants of the Oslo face-to-facemeeting: Jonny Axelsson (Opera), Bert Bos (W3C), Angel Diaz (IBM), Jon Ferraiolo(Adobe), Max Froumentin (W3C), Rick Graham (Bitflash), Stein Kulseth (Opera),Dean Jackson (W3C), Philippe Le Hégaret (W3C), Håkon Lie(Opera), Rune Lillesveen (Opera), Chris Lilley, (W3C), Charles McCathieNevile(W3C), Steven Pemberton (CWI/W3C), Vincent Quint (W3C, HyperText CG Chair),Tapas Roy (Openwave), Peter Stark (Ericksson), Ray Whitmer (Netscape/AOL),Steve Zilles (Adobe)