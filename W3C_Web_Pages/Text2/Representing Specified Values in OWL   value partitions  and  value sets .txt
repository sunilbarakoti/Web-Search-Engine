Representing Specified Values in OWL: "value partitions" and "valuesets" Representing Specified Values in OWL: "value partitions" and "valuesets" W3C Working Group Note 17 May 2005 This version: http://www.w3.org/TR/2005/NOTE-swbp-specified-values-20050517 Latest version: http://www.w3.org/TR/swbp-specified-values Previous version: http://www.w3.org/TR/2004/WD-swbp-specified-values-20040803 Editors: Alan Rector,University of Manchester Copyright© 2005 W3C® (MIT, ERCIM,Keio), All Rights Reserved. W3C liability,trademark,documentuse rules apply. Abstract Modelling various descriptive "features" (also known variously as"qualities", "attributes" or "modifiers") is a frequent requirementwhen creating ontologies. For example: "size" may describe persons orother physical objects and be constrained to take the values "small","medium" or "large"; rank may describe military officers and restrictedto a specific list of values depending on the militaryorganisation. In OWL such descriptive features are modelled asproperties whose range specifies the constraints on the values that theproperty can take on. This document describes two methods torepresent such features and their specified values: 1) as partitions ofclasses; and 2) as enumerations of individuals. It does notdiscuss the use of datatypes to represent lists of values. Status of this Document This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the W3C technical reports index at http://www.w3.org/TR/. This document is a Working Group Note, produced by the Ontology Engineering and Patterns Task Force in the Semantic Web Best Practices and Deployment Working Group, part of the W3C Semantic Web Activity. This document is one of a series of documents that is produced by the task force. Comments on this document may be sent to public-swbp-wg@w3.org, a mailing list with a public archive. Publication as a Working Group Note does not imply endorsement by the W3C Membership. This is a draft document and may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress. General issue It is a common requirement in developing ontologies to be able torepresent notions such as a "small man", a "high ranking officer" or a"health person." There are many such "features" (also known as"qualities", "attributes", or "modifiers") . In almost all suchcases it is necessary to specify the constraints on the values for the"feature" - e.g. that size may be "small", "medium" or "large" or thata person may be in "poor health", "medium health" or "goodhealth". In somecircumstanceswe may also want to represent modified values - e.g."very large", "moderately large", etc. or to otherwise furthersubdivide the original values. Inothercircumstances it is useful to be able to have two different collectionsofvalues covering the same feature, for example to have differentcollectionsof color values all partitioning the same "colour space" or to break up"health status" into four rather than three levels. There are at least three different ways to represent such specifiedcollections of values: As individuals whose enumeration makes up the parent classrepresenting the feature; (See pattern 1). As disjoint classes which exhaustively partition the parent classrepresenting the feature. (see pattern 2); As datatypes. Data types will more usually be used when there isa literal, numeric or derived data types rather than when there is anenumerated list of values. (Datatypes will not be considered further inthisnote because technical discussions are still continuing in other W3ccommittees. A supplement may be issued later when these issuesare resolved.) Use case examples We want to describe persons as having qualities such as having sizethat is small, medium or large, bodytypethat is slender, medium, or obese and as having health status that isgoodhealth, medium health, or poor health. It should not be possible tohave morethan one value for any of the qualities, e.g. it should beinconsistent (unsatisfiable) to be both slender and obese or in goodhealthand poor health. We will use the feature "Health" in the examples. Theothersfollow analogously. Conventions used in this note Diagramming The diagramming conventions used in this document are summarisedbelow. Examples are given in the appendix. Ellipses represent classes. Squares represent instances. Arrows: Closedundecorated arrows (pointing upwards if possible) represent rdfs:subclassOf; Open undecorated arrows indicate rdf:type; arrows decorated with a blob on the originindicaterestrictions if between classes or facts if between individuals. Dotted arrows indicate thatthe information represented is inferrable by a reasoner and not presentexplicitly in the code given. Upwardfacing square union symbols if spanning a set of rdfs:subclassOfarrowsor rdf:type arrowsindicate that the subclasses or individualsexhaust the class - i.e. that they cover all possibilities. Thisis expressed in OWL using owl:unionOf for classes or owl:oneOf for individuals Downwards facing bracesare used to indicate pairwise disjointness between subclasses or owl:allDifferent for individuals. (All siblingclasses are disjoint and all individuals of each type are different inthese examples.) Syntax for code In keeping with SWBP policy, the syntax within the body of note isN3. Details in alternative syntaxes are given by links. Vocabulary "Partition" - a classis partitioned by a group of subclasses if a) the subclasses aremutually exclusive, i.e. pairwise disjoint; and b) the subclassescompletely cover the parent class, i.e. that the union of thesubclasses is equal to the parent class. "Feature" - a characteristicof some entity. Other words for feature include "quality" [Weltyand Guarino], "attribute", "characteristic", and "modifier". Forpurposes of this note no distinction will be made between theseterms. For further information on representing more complex"qualities" see the note on N-ary Relations.) "Feature space" - the rangeof values that a feature can take on conceived of as a continuous rangeor 'space'. Also called quality space, see [Welty and Guarino]. Representation patterns Two patterns are introduced. The first is simple and intuitivebut has limitations. The second is more complex but is moreflexible. Some classifiers also work more reliably with Pattern 2than Pattern 1. Pattern 1: Values as sets of individuals In this approach, the class Health_Value is consideredas theenumeration of the individuals good_health,medium_health, and poor_health. Values aresets ofindividuals. To say that "John is is in good health", is to say that"Johnhas the value good_health for health_status"This assumes that a value is justaunique symbol, and a value set is just a a set of such symbols.Normally, thevalues will all need to be asserted to be different from each other. InOWL, any two individuals might represent the same thing unless there isanaxiom to say, explicitly, that they are different. In other words, OWLdoesnot make the "Unique Names Assumption". If we did not include thedifferentFrom axiom in the example, then it would bepossible that good_health and poor_health where the same thing, so that it would be possible tohave a person who was both in good health and poor healthsimultaneously. The approach is shown diagrammatically in Figure 1. Figure 1: A class-instance diagram of the use of enumeratedinstances to represent lists of values Representation for Pattern 1 {{The value set and make it equal tothe enumeration of the three individual values}} :Health_value       a       owl:Class ;       owl:equivalentClass               [ a       owl:Class ;                {{Define as one of three individuals}}                owl:oneOf (:medium_health :good_health :poor_health)                ] .:good_health      a       :Health_value ;      {{The next line make values different. Otherwise might be inferred the same}}      owl:differentFrom :poor_health , :medium_health .  {{Define each of the individual values as an individual of type Health_value}} :medium_health       a       :Health_value ;       owl:differentFrom :poor_health , :good_health  . :poor_health       a       :Health_value ;       owl:differentFrom :good_health , :medium_health . :has_health_status       a       owl:ObjectProperty , owl:FunctionalProperty ;       rdfs:range :Health_value . {{Define the individual John - and state that he has health_status good_health}}:John      a       :Person ;      :has_health_status :good_health .{{Define the class  Healthy_Person as the class of Person that has health_status good_health}} {{                                   	 i.e. an individual of type (Person AND has_health_status  value(good_health)):Healthy_person      a       owl:Class ;      owl:equivalentClass              [ a       owl:Class ;                owl:intersectionOf (:Person                                     [ a       owl:Restriction ;                                                  owl:hasValue :good_health ;                                                  owl:onProperty :has_health_status                                      ])               ] . Considerations using Pattern 1: There is a straight forward match to the usage in databases andmany frame systems without any assumptions or conventions aboutanonymous individuals. Many people find this the more intuitive approach. There is no possibility of further subpartitioning of values.This is because OWL supports only equality or difference betweenindividuals. It does not allow individuals to have partial overlaps. Itis not possible, as it is for classes, to say that one individual isequivalent to the the union (disjunction) of two other individuals. There is no way to represent alternative partitionings of thesame feature space. Because individuals cannot overlap, if Health_Valueis defined as equivalent to enumeration of one list of distinct values,it cannot also be equivalent to a different list of distinct values. Todo so would cause the reasoner to indicate a contradiction. (i.e that Health_Valuewas "unsatisfiable".) The representation is in OWL-DL, and DL reasoners shouldeventually be expected to make correct inferences with individuals usedin this way. However, neither FaCT nor Racer (the two most widespreadopen source reasoners in use today) perform all the expected inferencesreliably. OWL code for this example [N3] [RDF/XML abbrev] [Abstract syntax] Pattern 2: Values as subclasses partitioninga"feature" In this approach we consider the feature as a class representing acontinuous space that is partitioned by the values in the collection ofvalues. To say that "John is in good health" is to say that his healthisinside the Good_health_values partition of theHealth_value feature. Theoretically, there is anindividualhealth value, Johns_health, but all we know about it isthat itlies someplace in the Good_health_value partition. ThecassHealthy_Person is the class of all those persons who haveahealth in the Good_health_value partition. Figure 2: A class-instance diagram of the use ofpartitioningclasses for collections of values Some may find an alternative diagrammatic format adapted from Venndiagrams as shown in Figure 3 makes the intention clearer as it showsthepartioning more explicitly. Figure 3: An adapted Venn diagram showing the use ofpartitioningclasses to represent lists of values. Representation for two variants of Pattern 2 There are two variants presented: one in which the individual Johns_healthis explicitly represented, the other in which it is implied by anexistential restriction. Representation variant 1: Using a fact about the individual {{Define the parent Value class to bepartitioned}} :Health_Value       a       owl:Class ;       owl:equivalentClass               [ a       owl:Class ;               {{The next line makes the partition exhaustive}}                owl:unionOf (:Poor_health_value :Medium_health_value :Good_health_value                ] . {{Define each of the subclasses that make up the partitioon and make them pairwise disjoint}} :Good_health_value       a       owl:Class ;       rdfs:subClassOf :Health_Value ;       {{The disjoint axioms make the subclasses partitioning}}       owl:disjointWith :Poor_health_value , :Medium_health_value . :Medium_health_value       a       owl:Class ;       rdfs:subClassOf :Health_Value ;       owl:disjointWith :Poor_health_value , :Good_health_value   :Poor_health_value       a       owl:Class ;       rdfs:subClassOf :Health_Value ;       owl:disjointWith :Good_health_value , :Medium_health_value . {{Define the functional propertyhas_health_status with domain Person and range Health_value}} :has_health_status       {{The property must be functional}}       a       owl:ObjectProperty , owl:FunctionalProperty ;              rdfs:domain :Person ;     {{Domain is optional and might be broader}}       rdfs:range :Health_Value  {{Range is constrained to be Health_value and is mandatory for the pattern}} {{Define The class Person, itssubclassHealthy_person}} :Person       a       owl:Class. {{Define Healthy_person}} {{A Healthy_person is anything that is both a Person and whose health status is in the }} {{Good_health_value subclass of Health_value}} :Healthy_person       a       owl:Class ;       owl:equivalentClass               [ a       owl:Class ;                 owl:intersectionOf (:Person [ a       owl:Restriction ;                             owl:onProperty :has_health_status ;                             owl:someValuesFrom :Good_health_value                           ])               ] . {{Define John as an individual of type person and state that he has a health status Johns_health}} :John       a       :Person ;       :has_health_status :Johns_health . {{Define the individual Johns_health as a Good_health_value}} :johns_health       a       :Good_health_value . Representation using variant 2: Placing an existential restrictionon theindividual It is not actually necessary to create the individual, Johns_healthexplicitly. Instead, it is possible to use anexistential restriction to imply its existence but leave itanonymous. In Figure 3 below this is shown by preceding thename with an underscore and showing the box in dotted lines. Figure 4: Pattern 2 variant 2 with an anonymous individual for John'sHealth To understand how this is done formally, remember that restrictions in OWL are formally just another type of class, so to adda restriction to an individual, you make the individual a type of therestriction. So John is not only of of type Person,but also of type restriction(has_health_status someValuesFrom(GoodHealthStatus )). Or in N3 syntax: {{Define John as an individual of type person and of type has_health_status someValuesFrom Good_health_status}} :John      a      :Person ;           [a      owl:Restriction;                                       owl:onProperty :has_health_status ;                                      owl:someValuesFrom :Good_health_value]. Considerations using Pattern 2: The result is in OWL-DL and classifies correctly using eitherFaCT or Racer - and almost certainly any other reasoner that handlesany reasonable subset of OWL-DL.The semantics faithfully represent thepartitioning of a continuous feature space into a collection ofdiscrete value. The values can be further subpartitioned, e.g. Good_health_valuemight be split into Moderately_good_health_value and Robust_good_health_value,simply by subdividing the Good_health_value partition. There can be several alternative partitionings of the samefeature space. If variant 2 is to be used as part of a database schema orsimilar, then a convention for creating anonymous instances in thedatabase is required. (Logicians call such anonymous instances "skolemconstants".) In practice, this can usually be ignored. A commonconvention is to use the class name or a string derived from it, e.g. "good_health"as the symbol in the database. The fact that, strictly speaking, thesemantics require the symbol to be interpreted in each case as adifferent anonymous instance of the class Good_health_valuewill be irrelevant to most applications and invisible tomost users. A problem only arises if the database is to bere-interpreted in OWL, in which case either variant 1 or variant 2 mustbe chosen and the necessary anonymous variables or restrictionsconstructed for each occurrence of the value in the database. The use of classes for values seems unintuitive to many peoplewho come from the database and frame communities where value sets areusually enumerated lists of symbols. Code for this example [N3][RDF/XMLabbrev] [Abstractsyntax] Additional Considerations We would advise against mixing Pattern 1 and Pattern 2 in thesame ontology because it becomes difficult for authors to remember whento use one and when the other. Maintaining a consistentstyle is almost always to be preferred. In this note we have maintained the naming conventions thatclasses begin with upper case letters and included the suffix "_value"on the subclasses that make up value partitions. Creating a group of pairwise disjoint classes requirescombinatorially many disjoint axioms, i.e. it requires one axiom forevery pair of pairwise disjoint classes. (This does not happenwith individuals because the OWL standard provides an allDifferentaxiom. Unfortunately it does not provide an analogous alllDisjointaxiom.) Tools that implement OWL literally will encounter thisproblem and OWL files implemented literally may grow very large veryquickly. There is a known work around that will be covered in asupplementary note and is being implemented in some tools. Acknowledgements The code in these examples should be viewable with any owl tools.Thefollowing is for information only and with thanks to those involved indeveloping the tools. There is no endorsement intended or implied forthespecific tools. These examples have been produced using the Protege OWlplugin and CO-ODE additional wizards and OwlViz available from http://protege.stanford.edu andfollowing plugins/backends/owl. Some files may require the CO-ODEpluginslinked to that page or at http://www.co-ode.org.Classificationinvolving individuals cannot all be shown in this form and has beentestedusing OilEd available from http://oiled.man.ac.uk.In all cases theRacer classifier has been used, available from http://www.sts.tu-harburg.de/~r.f.moeller/racer/. Special thanks to Matthew Horridge for help with the finaldrawings, to Pat Hayes for help with draft diagrams, and to MikeUschold for detailed reviews. References Rector, A., Modularisation of Domain Ontologies Implemented inDescriptionLogics and related formalisms including OWL. in Knowledge Capture 2003,(Sanibel Island, FL, 2003), ACM, 121-128. pdfhere Welty, C. and Guarino, N. Supporting ontological analysis oftaxonomic relationships. Data and Knowledge Engineering, 39 (1).51-74. pdfhere Appendix: Diagramming conventions Ellipses represent classes, e.g. Squares represent instances., e.g. John Arrows: Closedundecorated arrows (pointing upwards if possible) represent rdfs:subclassOf; Open undecorated arrows indicate rdf:type; arrows decorated with a blob on the originindicaterestrictions if between classes or facts if between individuals. Dotted arrows indicate thatthe information represented is inferrable by a reasoner and not presentexplicitly in the code given. Upwardfacing square union symbols if spanning a set of rdfs:subclassOfarrowsor rdf:type arrowsindicate that the subclasses or individualsexhaust the class - i.e. that they cover all possibilities. Thisis expressed in OWL using owl:unionOf for classes or owl:oneOf for individuals Downwards facing bracesare used to indicate pairwise disjointness between subclasses or owl:allDifferent for individuals. (All siblingclasses are disjoint and all individuals of each type are different inthese examples.)