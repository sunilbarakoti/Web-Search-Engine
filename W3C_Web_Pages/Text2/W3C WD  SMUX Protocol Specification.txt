W3C WD: SMUX Protocol Specification WD-mux-19980710 SMUX Protocol Specification W3C Working Draft 10-July-1998 This version: http://www.w3.org/TR/1998/WD-mux-19980710 Latest public version: http://www.w3.org/TR/WD-mux Authors: Jim Gettys, Compaq Computer Corporation, Visiting Scientist, W3C, <jg@w3.org> Henrik Frystyk Nielsen, W3C, <frystyk@w3.org> Copyright © 1998 W3C (MIT, INRIA, Keio ), All Rights Reserved. W3C liability, trademark, document use and software licensing rules apply. Status of This Document This is a W3C Working Draft for review by W3C members and other interestedparties. It is a draft document and may be updated, replaced or made obsoleteby other documents at any time. It is inappropriate to use W3C Working Draftsas reference material or to cite them as other than "work in progress." Alist of currentW3Cworking drafts is also available. This document describes an experimental design for a multiplexing transport,intended for, but not restricted to use with the Web. SMUX has been implementedas part of the HTTP/NG project. Use of this protocol is EXPERIMENTALat thistime and the protocol may change. In particular, transition strategies touse of SMUX have not been definitively worked out. You have been warned! This document is part of a suite of documents describing the HTTP-NG designand prototype implementation: HTTP-NG Short- and Longterm Goals, WD HTTP-NG Architectural Model, WD HTTP-NG Wire Protocol, WD The Classic Web Interfaces in HTTP-NG, WD The MUX Protocol, WD Description of the HTTP-NG Testbed, Note Note: Since working drafts are subject to frequent change, you areadvised to reference the above URL, rather than the URLs for working draftsthemselves. This work is part of the W3C HTTP/NG Activity (for current status,seehttp://www.w3.org/Protocols/HTTP-NG/Activity). Please send comments on this specification to<www-http-ng-comments@w3.org>. Abstract This document defines the experimental multiplexing protocol referred toas "SMUX". SMUX is a session management protocol separating the underlyingtransport from the upper level application protocols. It provides a lightweightcommunication channel to the application layer by multiplexing data streamson top of a reliable stream oriented transport. By supporting coexistenceof multiple application level protocols (e.g. HTTP and HTTP/NG), SMUX shouldease transitions to future Web protocols, and communications of client appletsusing private protocols with servers over the same TCP connection as theHTTP conversation. Contents Introduction Operation and Deadlock Avoidance SMUX Header Alignment Session ID Allocation Session Establishment Protocol ID's Graceful Release Disgraceful Release Message Boundaries Flow Control Control Messages Remaining Issues for Discussion Closed Issues from Discussion and Email Glossary References Introduction Changes from Previous Version Tried to clarify teminology. Moved comparison between SMUX and SCP(TMP) to end of the document, and extracteda goals section from it. Key Words The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD","SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this documentare to be interpreted as described in RFC 2119 [7]. Purpose The Internet is suffering from the effects of theHTTP/1.0protocol, which was designed without understanding of the underlyingTCP [1] transport protocol. HTTP/1.0 opens a TCP connectionfor each URI [28] retrieved (at a cost of both packetsand round trip times (RTTs)), and then closes the TCP connection. For smallHTTP requests, these TCP connections have poor performance due to TCP slowstart [9] [10] as well asthe round trips required to open and close each TCP connection. There are (at least) three reasons why multiple simultaneous TCP connectionshave come into widespread use on the Internet despite the apparentinefficiencies: A client using multiple TCP connections gains a significant advantage in perceived performance by the end-user, as it allows for early retrieval of metadata (e.g. size) of embedded objects in a page. This allows a client to format a page sooner without suffering annoying reformatting of the page. Clients which open multiple TCP connections in parallel to the same server, however could cause self congestion on heavily congested links, since packets generated by TCP opens and closes are not themselves congestion controlled. The additional TCP opens cause performance problems in the network, but a client that opens multiple TCP connections simultaneously to the same server may also receive an "unfair" bandwidth advantage in the network relative to clients that use a single TCP connection. This problem is not solvable at the application level; only the network itself can enforce such "fairness". To keep low bandwidth/high latency links busy (e.g. dialup lines), more than one TCP connection has been necessary since slow start may cause the line to be partially idle. The "Keep-Alive" extension to HTTP/1.0 is a form of persistent TCP connectionsbut does not work through HTTP/1.0 proxies and does not take pipelining ofrequests into account. Instead a revised version of persistent TCP connectionswas introduced in HTTP/1.1 as the default mode of operation. HTTP/1.1 [6] persistent connections and pipelining[11] will reduce network traffic and theamount of TCP overhead caused by opening and closing TCP connections. However,the serialized behavior of HTTP/1.1 pipelining does not adequately supportsimultaneous rendering of inlined objects - part of most Web pages today;nor does it provide suitable fairness between protocol flows, or allow forgraceful abortion of HTTP transactions without closing the TCP connection(quite common in HTTP operation). Persistent connections and pipelining, however, do not fully address therendering nor the fairness problems described above. A "hack" solutionis possible using HTTP range requests; however, this approach does not, forexample, allow a server to send just the metadata contained in embedded objectbefore sending the object itself, nor does it solve the TCP connection abortproblem. Current TCP implementations do not share congestion information across multiplesimultaneous TCP connections between two peers, which increases theoverhead of opening new TCP connections. We expect that Transactional TCP[5] and sharing of congestion information in TCP controlblocks [8] will improve TCP performance by using lessRTTs and better congestion behavior, making it more suitable for HTTPtransactions. The solution to these problems requires two actions; either by itself willnot entirely discourage opening multiple TCP connections to the same serverfrom a client. Internet service providers should enable the Random Early Detection (RED) [12] or other active congestion control algorithms in their routers to ensure bandwidth fairness to clients when the network is congested. RED also addresses queue length problems observed in routers today. Development and deployment of a multiplexing protocol for use with HTTP (and eventually other protocols), so that multiple objects from a web server can be fetched approximately simultaneously over a single TCP connection, so that the metadata to objects can be sent to clients without other metadata waiting for the rest of the first object requested. This document describes such an experimental multiplexing protocol. It isdesigned to multiplex a TCP connection underneath HTTP so that HTTPitself does not have to change, and allow coexistence of multiple protocols(e.g. HTTP and HTTP/NG), which will ease transitions to future Web protocols,and communications of client applets using private protocols with serversover the same TCP connection as the HTTP conversation. Ideas from this design come from Simon Spero's SCP [15] [16] descriptionand from experience from theX WindowSystem's protocol design [13]. Goals We believe SMUX meets the following goals:: Unconfirmed service without negotiation or round trips to the server simple design high performance deadlock-free (we believe), by a credit based flow control scheme. allow multiple protocols to be multiplexed over same TCP connection allow connections to be established in either direction (enabling callbacks to the session initiator). ability to build a full function socket interface above this protocol. low overhead preserves alignment in the data stream, so that it is easy to use with protocols that marshal their data in a binary form. SMUX Protocol Operation Deadlock Scenario Multiplexing multiple sessions over a single transport TCP connectionintroduces a potential deadlock that SMUX is designed to avoid. Here is an example of potential deadlock: Presume that each session is being handled by an independent thread and that memory available to the SMUX implementation is limited (for example, on a thin client on a meter reader). For the purposes of this example, presume the thin client has 50K bytes of buffer available to its SMUX implementation, and cannot get more. The sender of data decides to send, as part of a session request (SYN message), 100K bytes of initial data. There are no other senders, so all of the data gets transmitted. But the thread to deal with the message is blocked, and cannot make progress. Unless SMUX can buffer all 100K (or 1 meg, or pick your favorite numbers), any other session's data would be blocked behind this initial transmission until and unless SMUX can read and buffer the data someplace (and since it has no buffer available, the deadlock occurs). Many similar (but possibly harder to explain) deadlocks are possible. This example points out that deadlock is possible: SMUX must be able to bufferdata independently of the consumers of the data. It must also havesome way to throttle sessions where the consumer of the data is not responsivein the multiplexing layer (in this example, prevent the transmission of morethan 50 Kbytes of data). Note that this deadlock is independent ofthe size of any multiplexing fragment, but strictly dependent on availabilityof buffer space in SMUX for a particular session. Deadlock Avoidance In SMUX, the receiver makes a promise (sends a credit) to the transmitterthat a certain amount of buffer space is available (or at least that it willconsume the bytes, if not buffer them, e.g. a real time audio protocol wherethe data is disposed of), and the transmitter promises not to send more datathan the receiver has promised (no more than the credit). If thesepromises are met, then SMUX will not deadlock. A SMUX implementation MUST maintain and adhere to the credit system or itcan deadlock. Implementations on systems with large amounts of memory(e.g. VM systems) may be quite different than ones on thin clients with limited,non-virtual memory. It is reasonable on a VM system to hand out creditsfreely (analogous to the virtual socket buffering found in TCP implementations);but your implementation must be careful to test its credit mechanisms sothat they will inter operate with limited memory systems. Credit controlmessages MAY be sent on sessions that are not active. Sessions have an initial credit size (initial_default_credit) of 16KB on each session; there is a SMUX control message to set this initial creditto something larger than the default. Operation and Implementation Considerations A transmitter MUST NOT transmit more data in a fragment than the availablecredit on the session (or it could deadlock). An SMUX implementation MUST fragment streams when transmitting them intofragments. The max_fragment_size, a variable which ismaintained on (currently) a per transport TCP connection basis, determinesthe largest possible fragment a sender should ever send to a receiver. This determines the maximum latency introduced by a SMUX layer above andbeyond the inherent TCP latencies (socket buffering on both sender and receiverand the delay-bandwidth product amount of data that could be in flight atany given instant). A client on a low bandwidth link, or with limitedmemory buffering might decide to set the max_fragment_size down tocontrol latency and buffer space required. If max_fragment_sizeis set to zero, the transmitter is left to determine the fragment size andMAY take into account application protocol knowledge (e.g. a SMUX implementationfor HTTP might send fragments of the metadata of embedded objects, or thenext phase of a progressive image format, which it only knows). Animplementation SHOULD honor the max_fragment_size as it transmitsdata, if it has been set by the receiver. An SMUX implementation that does not have explicit knowledge or experienceof good fragment sizes might use these guidelines as a starting point: The path_MTU of the TCP connection, minus the size of the TCP and IP headers (remember that IPV6 may have longer headers!) and 8 bytes for an XMUX header, if this information is available [3]. The MSS of the TCP connection, if the path_MTU is not available In either case, you probably want to subtract 8 bytes to make sure a SMUX header can be added without forcing another TCP segment. This would result in fragmentation roughly similar to TCP segmentation overmultiple TCP connections. An implementation should round robin between sessions with data to send insome fashion to avoid starving sessions, or allowing a single thread tomonopolize the TCP connection. Exact details of such behavior is leftto the implementation. To achieve highest bandwidth and lowest overheadSMUX behavior, credits should be handed out in reasonably large chunks. TCPimplementations typically send an ack message on every other packet, andit is very hard to arrange to piggyback acks on data segments inimplementations. Therefore, for SMUX to have reasonably low overheadcredits should be handed out in some significant multiple (4 or more timeslarger) than the ~3000 bytes represented by two packets on an ethernet. The outstanding credit balance across active sessions will also have to belarger than the bandwidth/delay product of the TCP connection if SMUX isnot to become a limit on TCP transport performance. Both of these arguments indicate that outstanding credits in many implementationsshould be 10K bytes or more. Implementations SHOULD piggyback creditmessages on data packets where possible, to avoid unneeded packets on thewire. A careful implementation in which both ends of the TCP connectionare regularly sending some payload should be able to avoid sending extrapackets on the network. If necessary, we could add in a future version fragmentation control messagesto do some bandwidth allocation, but for now, we are not bothering. SMUX Header SMUX headers are always in big endian byte order. If people want, we could expand out the union below on a control messagetype basis (e.g. the way the C bindings to X events were written out...).For this draft, I'm not doing so.  #define MUX_CONTROL       0x00800000 #define MUX_SYN           0x00400000 #define MUX_FIN           0x00200000 #define MUX_RST           0x00100000 #define MUX_PUSH          0x00080000 #define MUX_SESSION       0xFF000000 #define MUX_LONG_LENGTH   0xFF040000 #define MUX_LENGTH        0x0003FFFF  typedef unsigned int flagbit; struct w3mux_hdr {     union {        struct {            unsigned int session_id : 8;            flagbit control : 1;            flagbit syn : 1;            flagbit fin : 1;            flagbit rst : 1;            flagbit push : 1;            flagbit long_length : 1;            unsigned int fragment_size : 18;            int long_fragment_size : 32; /* only present if long_length is set */        } data_hdr;         struct {            unsigned int session_id : 8;            flagbit control : 1;            unsigned int control_code : 4;            flagbit long_length : 1;            unsigned int fragment_size : 18;            int long_fragment_size : 32; /* only present if long_length is set */        } control_message;     } contents; }; The fragment_size is always the size in bytes of the fragment, excludingthe SMUX header and any padding. Alignment SMUX headers are always (at least) 32 bit aligned. To find the next SMUXheader, take the fragment_size, and round up to the next 32 bit boundary. Transmitters MAY insert NoOp control messages to force 64bit alignment of the protocol stream. Long Fragments A SMUX header with the long_length bit set must use the 32 bits followingthe SMUX header (the long_fragment_size field) for the value of thefragment_size field, for whatever purpose the fragment_sizefield is being used for. Atoms Atoms are integers that are used as short-hand names for strings, which aredefined using the InternAtom control message. Atoms are onlyused as protocol ID's in this version of SMUX, though they might be usedfor other purposes in future versions. Since the atom might be redefinedat any time, it is not safe to use an atom unless you have defined it (i.e.you cannot use atoms defined by the other end of a mux connection). Atomsare therefore not unique values, and only make sense in the context of aparticular direction of a particular mux connection. This restrictionis to avoid having to define some protocol for deallocating atoms, with anyround trip overhead that would likely imply. Strings are defined to be UTF-8 encoded UNICODE strings. (Note thatan ascii string is valid UTF-8). The definition of structure of thesestrings is outside of the scope of this document, though we expect they willoften be URI's, naming a protocol or stack of protocols. Atoms alwayshave values between 0x20000 and 0x200ff (a maximum of 256 atoms can be defined). Strings used for protocol id's MUST be URIs [28]. Protocol ID's The protocol used by a session is identified by a Protocol ID, which caneither be an IANA port number, or an atom. To allow higher layers to stack protocols (e.g. HTTP on top of deflate compression, on top of TCP). To identify the protocol or protocol stack in use so that application firewall relays can perform sanity checking and policy enforcement on the multiplexed protocols . In the simplest case, a protocol ID is just a value in the range of 0-0x1FFFF,and specifies the TCP port number (0x0000-0xffff) or UDP port number(0x10000-0x1ffff) of the protocol per the IANA port number registry [17]. Firewall proxies can presume that the bytes should conform to thatprotocol. Protocol ID's above 0xfffff are atoms. The scheme name ofthe URI indicates the protocol family being used. Session ID Allocation Each session is allocated a session identifier. Session Identifiers below0 and 1 are reserved for future use. Session IDs allocated by initiator ofthe transport TCP connection are even; those allocated by the receiver ofthe transport connection odd. Proxies that do not understand messages ofreserved Session ID's should forward them unchanged. A session identifierMUST only be deallocated and potentially reused by new sessions when a sessionis fully closed in both directions. Session Establishment To establish a new session, the initiating end sends a SYN message, allocatinga free session number out of its address space. A session is establishedby setting the SYN bit in the first message sent on that session. The sessionis specified by the session_id field. The fragment_size fieldis interpreted as theprotocolID of the session, as discussed above. The receiver MUST either open the reverse path of that session (send a SYNmessage), or it MUST send a FIN message to indicate that the reverse pathis not going to be used further, or send a RST message to indicate anerror. This enables the initiator of a session to know when it is safeto reuse that session ID. Graceful Release A session is ended by sending a fragment with the FIN bit set. Each end ofa MUX connection may be closed independently. MUX uses a half-close mechanism like TCP[1] to close data flowing in eachdirection in a session. After sending a FIN fragment, the sender MUST NOTsend any more payload in that direction. Disgraceful Release A session may be terminated by sending a message with the RST bit set. Allpending data for that session should be discarded. "No such protocol" errorsdetected by the receiver of a new session are signaled to the originatoron session creation by sending a message with the RST bit set. (Same as inTCP). The payload of the fragment containing the RST bit contains the null terminatedstring containing the URI of an error message (note that content negotiationmakes this message potentially multi-lingual), followed by a null terminatedUTF-8 string containing the reason for the reset (in case the URI is notaccessable). Message Boundaries A message boundary is marked by sending a message with the PUSH bit set.The boundary is set between the last octet in this message, including thatoctet, and the first byte of a subsequent message. This differs slightlyfrom TCP, as PUSH can be reliably used as a record mark. Flow Control Flow control is determined by a simple credit scheme described above byusing the AddCredits control message defined below.Fragments transmitted must never exceed the outstanding credit for that session.The initial outstanding credit for a session is 16Kbytes. End Points One of the major design goals of SMUX is to allow callbacks to objects inthe process that initiated the transport TCP connection without requiringadditional TCP connections (with the overhead in both machine resources andtime that this would cause, or the problems with TCP connection establishmentthrough firewalls). The DefineEndpoint control message allows one to advertize that aparticular (set of) URI's are reachable over the transport TCP connection. Control Messages The control bit of the SMUX header is always set in a control message. Controlmessages can be sent on any session, even sessions that are not (yet) open.The control_code reuses the SYN, FIN, RST, and PUSH bits of the SMUXheader. The control_code of the control message determines the controlmessage type. Any unused data in a control message must be ignored. The revised version of SMUX means that a session creation costs 4 bytes(a control message with SYN set, and with the protocol ID in the message). Therefore the first fragment of payload has a total overhead of 8 bytes. (This is presuming using an IANA based protocol, rather than a namedprotocol). This is the same as the previous version, though it meanstwo messages rather than one. The individual control message types are listed below. code Name Dir Description 0 InternAtom Both The session_id is used as the Atom to be defined (offset by 0x2000), so a value of 0 is defining ID 0x2000). The fragment_size field is the length of the UTF-8 encoded string. The fragment itself contains the string to be interned. This allows the interning of 256 strings. (is this enough?). 1 DefineEndpoint Both The session_id is ignored. The fragment_size is interpreted as the protocol ID, naming an endpoint actually available on this transport TCP connection. This enables a single transport TCP connection to be used for callbacks, or to advertise that a protocol endpoint can be reached to the process on the other end of the transport TCP connection. Whether this relative URI naming can be used depends upon the scheme of the URI [20], which defines its structure. For example, a firewall proxy might advertize just "http:" for the proxy, claiming it can be used to contact any HTTP protocol object anywhere, or "http://foo.com/bar/" to indicate that any object below that point in the URI space on the server foo.com may be reached by this TCP connection. A client might advertize that "http://myhost.com/" is available via this transport TCP connection. 2 SetMSS Both This sets a limit on fragment sizes below the outstanding credit limit. The session_id must be zero. The fragment_size field is used as max_fragment_size (the largest fragment that be sent on any session on this transport TCP connection.). A max_fragment_size of zero means there is no limit on the fragment size allowed for this session. 3 AddCredit R->T The session_id specifies the session. The fragment_size specifies the flow control credit granted (to be added to the current outstanding credit balance). A value of zero indicates no limit on how much data may be sent on this session. 4 SetDefaultCredit R->T The session_id must be zero. The fragment_size field is used as to set the initial default credit limit for any incoming MUX connections over this transport TCP connection. (i.e. it is short hand for sending a series of AddCredit messages for each session ID). 5 NoOp Both This control message is defined to perform no function. Any data in the payload should be ignored. 6-15 - Undefined. Reserved for future use. Must be ignored if not understood, and forwarded by any proxies. The fragment_size is always used for the length of the control message, and any data for the control message will be in the payload of the control message (to allow proxies to be able to forward future control messages). Remaining Issues for Discussion When can MUX be used??? What are the appropriate strategies for determining if the simple multiplexing protocol can be used? Name server hack? UPGRADE in HTTP? Remember that previous UPGRADE to use MUX worked? Comparison with SCP (TMP) Note that TIP (Transaction Internet Protocol) [21] definesa version of SCP called TMP . Goals: Unconfirmed service without negotiation. SCP allows data to be sent with the session establishment; the recipient does not confirm successful mux connection establishment, but may reject unsuccessful attempts. This simplifies the design of the protocol, and removes the latency required for a confirmed operation. simple design performance where critical There are five issues that make SCP (TMP) inadequate for our use: SCP can deadlock, unless unlimited amounts of memory is available. it has no provision for multiplexing multiple protocols over the same transport TCP connection, essential for graceful transition without dependency on the currently incomplete NG design, and to allow other uses which could use the same multiplexed connection (e.g. applet communication with serverlets). SCP's 8 byte overhead is not reasonable most of the time. SMUX uses four bytes in the default case. The design below permits an 8 byte header if you care to preserve 64 bit alignment at the cost of bytes. In practice, there seems few data formats or architectures that actually require more than 32 bit alignment. Without some form of flow control, infinite buffering in clients (receivers) would be required. Alignment is preserved in the data stream. This allows compact, high speed (un)marshalling code in implementations of binary protocols, without extra data copies, which in such protocols can be significant overhead. SCP SYN in Version 2 requires a second message, which costs a round trip. So far, SMUX is similar to SCP. There are some important differences: deadlock-free (we believe), by a credit based flow control scheme. allow multiple protocols to be multiplexed over same TCP connection (not available in SCP). lower overhead than SCP, while preserving data alignment (very important for binary protocol marshaling code) ability to build a full function socket interface above this protocol. SMUX avoids the SYN round trip of SCP V2 by session ID's being allocated in independent address spaces. This also avoids many of the state transitions of SCP, simplifying the protocol greatly. Other comment on SCP: SCP has 224 sessions, which seems highly excessive, and reserves1024 of them for future use. Closed Issues from Discussion and Mail Some of the comments below allude to previous versions of the specification,and may not make sense in the context of the current version. Flow control: priority vs. credit schemes Henrik and I have convinced ourselves there are fundamental differences betweena priority scheme and the credit scheme in this draft. They interactquite differently with TCP, and priority schemes have no way to limit thetotal amount of data being transmitted, though priority schemes are bettermatched to what the Web wants. We've decided, at least for now, todefer any priority schemes to higher level protocols. Stacking Protocols and Transports (Stacks) ILU [22] style protocol stacks are a GOOD THING. There have been too manyworries about the birthday problem for people to be comfortable with BillJanssen's hashing schemes (seeHenrikFrystyk Nielsen andRobertThau's mail on this topic). We tried putting this directlyin MUX in a previous version, and experience shows that it didn't reallyhelp an implementer (in particular, Bill Janssen while implementing ILU). This version has just the name of the protocol, and it is left to othersto implement any stacking (e.g. ILU). We believe the name of the protocol is necessary, if SMUX is ever to be usedwith firewalls. Application level firewall relays need the protocolinformation to sanity check the protocol being relayed. Application levelrelays are considered much more secure than just punching holes in the firewallfor particular protocol families, which small organizations often findsufficient, as the relay can sanity check the protocol stream and enablebetter policy decisions (for example, to forbid certain datatypes in HTTPto transit a firewall). Large organizations and large targets typicallyonly run application level proxies. Byte Usage Wasting bytes in general, and in particular at TCP connection establishment,for a multiplexing transport must be avoided. There are several reasons forthis: if the initial segment is too long, a network round trip will be lost to TCP slow start, so bytes near the beginning of a conversation MAY BE much more precious than bytes later in the conversation, once slow start overhead has been paid. If the first segment is too long, you fall off a cliff. Directly affects user perceived response; no cleverness of later packing and batching of request can get the time back; each goes directly to perceived latency when a user talks to the server for the first time. So there is more than the usual tension between generality vs. performance.Performance analysis Human perception is about 30 milliseconds; if much more than this, the userperceives delay. At 14.4 K baud, one byte uncompressed costs .55 milliseconds (ignoring modem latencies). On an airplane via telephone today, you geta munificent 4800 baud, which is 3X slower. Cellular modems transmittingdata (CDPD), as I understand it, will give us around 20Kbaud, when deployed. So basic multiplexing @ 4 byte overhead costs ~ 2 milliseconds on commonmodems. This means basic overhead is small vs. human perception, for mostlow speed situations, a good position to be in. On cMux onnection open, with above protocol we send 4 bytes in the setupmessage, and then must open a session, requiring at least 8 bytes more. 12bytes == 7 milliseconds at 14.4K. Not 64 bit aligned, and 4 bytes costs oforder 2 milliseconds. Ugh... Maybe a setup message isn't a good idea; otheruses (e.g. security) can be dealt with by a control message. Multiple protocols over one SMUX We want to SMUX multiple protocols simultaneously over the same transportTCP connection, so we need to know what protocol is in use with each session,so the demultipexor can hand the data to the right person. (e.g. SUNRPC andDCERCP simultaneously). There are two obvious ways I can see to do this: a) Send a control message when a session is first used, indicating the protocol. Disadvantage: costs probably 8 bytes to do so (4 SMUX overhead, and 4 byte message), and destroys potential 64 bit alignment. b) If syn is set indicating new session, then steal mux_length field to indicate protocol in use on that session. (overhead; 4 bytes for the SMUX header used just to establish the session.) Opinions? Mine is that b) is better than a. Answer: b) is the adopted strategy. Priority... For a given stream, priority will affect which session is handled whenmultiplexing data; sending the priority on every block is unneeded, and wouldwaste bytes. There is one case in which priority might be useful: at anintermediate proxy relaying sessions (and maybe remultiplexing them). If so, it should be sent only when sessions are established or changed. Changescan be handled by a control message. Opinions? A priority field can be hacked into the length field with the protocol fieldusing b) above. So the question is: is it important to send priority at all in this SMUXprotocol? Or should priority control, if needed, be a control message? ; (control message). Answer: Not in this protocol. Opens Pandora's box with remultiplexors, whichcould have denial of service attacks. Setup message Is any setup message needed? I don't think it is,. and initial bytes areprecious (see performance discussion above), and it complicates trivial use.If we move the byte order flag to the SMUX header, and use control messagesif other information needs to be sent, we can dispense with it, and the layeris simpler. This is my current position, and unless someone objects withreasons, I'll nuke it in the next version of this document. Answer: Not needed. Nuked. Byte order flags While higher layer protocols using host dependent byte order can be a performance win (when sending larger objects such as arrays of data), the overheadat this layer isn't much, and may not be worth bothering with. Worst case(naive code) would be four memory reads and 3 shift overhead/payload. Smartcode is one load and appropriate shifts etc. Opinions? I'm still leaning toward swapping bytes here, but there are otherexamples of byte load and shift (particularly slow on Alpha, but not muchof an issue on other systems). Answer: Not sufficient performance gain at SMUX level to be worth doing.Defined as LE byte order for SMUX headers. Error handling There are several error conditions, probably best reported via control messagesfrom server: No such protocol. Some sort of serial number should be reported, I suppose; this serial number can be implicit as in X bad message. Some combinations of flag bits are not legal. Priority if it exists? Any others? Any twists to worry about? Answer: Only error that can occur is no such protocol, given no priorityin the base protocol. May still be some unresolved issues here around "Christmas Tree" message (all bits turned on). Length Field Any reason to believe that the 32 bit length field for a single payload isinadequate? I don't think so, and I live on an Alpha. Answer: 32 bit extended length field for a single fragment is sufficient. Compression Does there need to be a bit saying the payload is compressed to avoid explosionof protocol types? Answer: Yes; introduction of control message to allow specification of transportstacks achieves this. Stacks I think that we should be able to multiplex any TCP, UDP, or IP protocol.Internet protocol numbers are 8 bit fields. So we need 16 bits for TCP, one bit to distinguish TCP and UDP, and one bitmore we can use for IP protocol numbers and address space we can allocateprivately. This argues for an 18 bit length field to allow for this reuse.* 18 bit length field * * 8 bit session field * * 4 control bits * * 1 longlength bit * The last bit is used to define control messages, which reuse the syn, fin,rst, and push bits as a control_code to define the control message. Thereare escapes, both by undefined control codes, and by the reservation of twosessions for further use if there needs to be further extensions. The specabove reflects this. Alignment Back to alignment. If we demand 4 byte alignment, for all requests that donot end up naturally aligned, we waste bytes. Two bytes are wasted on average.At 14.4Kbaud the overhead for protocols that do not pad up would on meanbe 6 bytes or ~3ms, rather than 4 bytes or ~ 2 ms (presuming even distributionsof length). Note that this DOES NOT effect initial request latency (timeto get first URL), and is therefore less critical than elsewhere. I have one related worry; it can sometimes be painful to get padding bytesat the end of a buffer; I've heard of people losing by having data rightup to the end of a page, so implementations are living slightly dangerously if they presume they can send the padding bytes by sending the 1, 2 or3 bytes after the buffer (rather than an independent write to the OS forpadding bytes). Alternatively, the buffer alignment requirement can be satisfied byimplementations remembering how many pad bytes have to be sent, and adjustingthe beginning address of the subsequent write by that many bytes before thebuffer where the SMUX header has been put. Am I being unnecessarily paranoid? Opinion: I believe alignment of fragments in general is a GOOD THING, andwill simplify both the SMUX transport and protocols at higher levels if theycan make this presumption in their implementations. So I believe this overheadis worth the cost; if you want to do better and save these bytes, then startbuilding an application specific compression scheme. If not, please makeyour case. Control bits Are the four bits defined in Simon's flags field what we need? Are thereany others? Answer: no. More bits than we need. Current protocol doesn't use as many.I've ended back at the original bits specified, rather than the smaller setsuggested by Bill Janssen. This enables full emulation of all the detailsof a socket interface, which would not otherwise be possible. See detailsaround TCP and socket handling, discussed in books like "TCP/IP Illustrated,"by W. Richard Stevens. Am I all wet? Opinion: I believe that we should do this. Control Messages Question: do we want/need a short control message? Right now, the out forextensibility are control messages sent in the reserved (and as yet unspecified) control session. This requires a minimum of 8 bytes on the wire. We couldsteal the last available bit, and allow for a 4 byte short control message,that would have 18 bits of payload. Opinion: Flow control needs it; protocol/transport stacks need it. Documentabove now defines some control messages. Simplicity of default Behavior The above specification allows for someone who just wants to SMUX a singleprotocol to entirely ignore protocol ID's. Glossary To be supplied References J. Postel, "Transmission Control Protocol", RFC 793, Network Information Center, SRI International, September 1981 J. Postel, "TCP and IP bake off", RFC 1025, September 1987 J. Mogul, S. Deering, "Path MTU Discovery", RFC 1191, DECWRL, Stanford University, November 1990 T. Berners-Lee, "Universal Resource Identifiers in WWW. A Unifying Syntax for the Expression of Names and Addresses of Objects on the Network as used in the World-Wide Web", RFC 1630, CERN, June 1994. R. Braden, "T/TCP -- TCP Extensions for Transactions: Functional Specification", RFC 1644, USC/ISI, July 1994 R. Fielding, "Relative Uniform Resource Locators", RFC 1808, UC Irvine, June 1995. T. Berners-Lee, R. Fielding, H. Frystyk, "Hypertext Transfer Protocol -- HTTP/1.0", RFC 1945, W3C/MIT, UC Irvine, W3C/MIT, May 1996 R. Fielding, J. Gettys, J. C. Mogul, H. Frystyk, T. Berners-Lee, "Hypertext Transfer Protocol -- HTTP/1.1", RFC 2068, U.C. Irvine, DEC W3C/MIT, DEC, W3C/MIT, W3C/MIT, January 1997 S. Bradner, "Key words for use in RFCs to Indicate Requirement Levels", RFC 2119, Harvard University, March 1997 J. Touch, "TCP Control Block Interdependence", RFC 2140, April 1997 W. Stevens, "TCP Slow Start, Congestion Avoidance, Fast Retransmit, and Fast Recovery Algorithms", RFC 2001, January 1997 V. Jacobson, "Congestion Avoidance and Control", Proceedings of SIGCOMM '88 H. Frystyk Nielsen, J. Gettys, A. Baird-Smith, E. Prud'hommeaux, H. W. Lie, and C. Lilley, "Network Performance Effects of HTTP/1.1, CSS1, and PNG", Proceedings of SIGCOMM '97 S. Floyd and V. Jacobson, "Random Early Detection Gateways for Congestion Avoidance", IEEE/ACM Trans. on Networking, vol. 1, no. 4, Aug. 1993. R.W.Scheifler, J. Gettys, "The X Window System" ACM Transactions on Graphics # 63, Special Issue on User Interface Software, 5(2):79-109 (1986). V. Paxson, "Growth Trends in Wide-Area TCP Connections" IEEE Network, Vol. 8 No. 4, pp. 8-17, July 1994 S. Spero, "Session Control Protocol, Version 1.0" S. Spero, "Session Control Protocol, Version 2.0" Keywords and Port numbers are maintained by IANA in the port-numbers registry. Keywords and Protocol numbers are maintained by IANA in the protocol-numbers registry. W. Richard Stevens, "TCP/IP Illustrated, Volume 1", Addison-Wesley, 1994 Berners-Lee, T., Fielding, R., Masinter, L., "Uniform Resource Identifiers (URI): Generic Syntax and Semantics," Work in Progress of the IETF, November, 1997. J. Lyon, K. Evans, J. Klein, "Transaction Internet Protocol Version 2.0," Work in Progress of the Transaction Internet Protocol Working Group, November, 1997. B. Janssen, M. Spreitzer, "Inter-Language Unification"; in particular see the manual section on Protocols and Transports. @(#) $Id: WD-mux-19980710.html,v 1.2 1998/07/10 17:02:54 frystyk Exp $