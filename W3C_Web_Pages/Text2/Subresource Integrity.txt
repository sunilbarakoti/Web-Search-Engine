Subresource Integrity Subresource Integrity W3C First Public Working Draft 18 March 2014 This version: http://www.w3.org/TR/2014/WD-SRI-20140318/ Latest published version: http://www.w3.org/TR/SRI/ Latest editor's draft: http://w3c.github.io/webappsec/specs/subresourceintegrity/ Editors: Frederik Braun, Mozilla Corporation Devdatta Akhawe, UC Berkeley Joel Weinberger, Google, Inc. Mike West, Google, Inc. Copyright Â© 2014 W3CÂ® (MIT, ERCIM, Keio, Beihang), All Rights Reserved. W3C liability, trademark and document use rules apply. Abstract This specification defines a mechanism by which user agents may verify thata fetched resource has been delivered without unexpected manipulation. Status of This Document This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the W3C technical reports index at http://www.w3.org/TR/. A list of changes to this document may be found athttps://github.com/w3c/webappsec. This document was published by the Web Application Security Working Group as a First Public Working Draft. This document is intended to become a W3C Recommendation. If you wish to make comments regarding this document, please send them to public-webappsec@w3.org (subscribe, archives) with [Integrity] at the start of your email's subject. All comments are welcome. Publication as a First Public Working Draft does not imply endorsement by the W3C Membership. This is a draft document and may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress. This document was produced by a group operating under the 5 February 2004 W3C Patent Policy. W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy. Table of Contents 1. Introduction 1.1 Goals 1.2 Use Cases/Examples 1.2.1 Resource Integrity 1.2.2 Downloads 1.2.3 Fallback 2. Conformance 2.1 Key Concepts and Terminology 3. Framework 3.1 Integrity metadata 3.2 Cryptographic hash functions 3.3 Resource verification algorithms 3.3.1 Apply algorithm to resource 3.3.2 Is resource eligible for integrity validation 3.3.3 Does resource match metadata? 3.4 Modifications to Fetch 3.5 Verification of HTML document subresources 3.5.1 The integrity attribute 3.5.2 The noncanonical-src attribute (TODO) 3.5.3 Element interface extensions 3.5.3.1 HTMLAnchorElement 3.5.3.1.1 Attributes 3.5.3.2 HTMLEmbedElement 3.5.3.2.1 Attributes 3.5.3.3 HTMLIFrameElement 3.5.3.3.1 Attributes 3.5.3.4 HTMLImageElement 3.5.3.4.1 Attributes 3.5.3.5 HTMLLinkElement 3.5.3.5.1 Attributes 3.5.3.6 HTMLMediaElement 3.5.3.6.1 Attributes 3.5.3.7 HTMLObjectElement 3.5.3.7.1 Attributes 3.5.3.8 HTMLScriptElement 3.5.3.8.1 Attributes 3.5.3.9 HTMLTrackElement 3.5.3.9.1 Attributes 3.5.4 Handling integrity violations 3.5.5 Elements 3.5.5.1 The a element 3.5.5.2 The embed element 3.5.5.3 The iframe element 3.5.5.4 The img element 3.5.5.5 The link element 3.5.5.6 The object element 3.5.5.7 The script element 3.5.5.8 The track element 3.5.5.9 The audio element (TODO) 3.5.5.10 The source element (TODO) 3.5.5.11 The video element (TODO) 3.6 Verification of CSS-loaded subresources 3.7 Verification of JS-loaded subresources 3.7.1 Workers 3.7.1.1 Worker extension 3.7.1.1.1 Attributes 3.7.1.2 SharedWorker extension 3.7.1.2.1 Attributes 3.7.1.3 Validation 3.7.2 XMLHttpRequest 3.7.2.1 The integrity attribute 3.7.2.2 Progress events 3.7.2.3 Validation 4. Caching (Optional) 4.1 Risks 4.1.1 Origin confusion 4.1.2 MIME type confusion 4.2 Recommendations 5. Proxies 6. Security Considerations 6.1 Insecure channels remain insecure 6.2 Hash collision attacks 6.3 Cross-origin data leakage 7. Acknowledgements A. References A.1 Normative references 1. Introduction This section is non-normative. Sites and applications on the web are rarely composed of resources fromonly a single origin. Authors pull scripts, images, fonts, etc. from awide variety of services and content delivery networks, and must trustthat the delivered representation is, in fact, what they expected toload. If an attacker can trick a user into downloading content froma hostile server (via DNS poisoning, or other such means), the author hasno recourse. Likewise, an attacker who can replace the file on the CDN serverhas the ability to inject arbitrary content. Delivering resources over a secure channel mitigates some of this risk: withTLS, HSTS, and pinned public keys, a user agent can be fairly certainthat it is indeed speaking with the server it believes itâ€™s talking to. Thesemechanisms, however, authenticate only the server, not the content. Anattacker (or admin!) with access to the server can manipulate content withimpunity. Ideally, authors would not only be able to pin the keys of aserver, but also pin the content, ensuring that an exact representation ofa resource, and only that representation, loads and executes. This document specifies such a validation scheme, extending several HTMLelements with a integrity attribute that contains a cryptographic hash ofthe representation of the resource the author expects to load. For instance,an author may wish to load jQuery from a shared server rather than hosting iton their own origin. Specifying that the expected SHA-256 hash ofhttps://code.jquery.com/jquery-1.10.2.min.jsis C6CB9UYIS9UJeqinPHWTHVqh_E1uhG5Twh-Y5qFQmYg meansthat the user agent can verify that the data it loads from that URL matchesthat expected hash before executing the JavaScript it contains. Thisintegrity verification significantly reduces the risk that an attacker cansubstitute malicious content. This example can be communicated to a user agent by adding the hash to ascript element, like so: Example 1 <script src="https://code.jquery.com/jquery-1.10.2.min.js"        integrity="ni:///sha-256;C6CB9UYIS9UJeqinPHWTHVqh_E1uhG5Twh-Y5qFQmYg?ct=application/javascript"> Scripts, of course, are not the only resource type which would benefitfrom integrity validation. The scheme specified here applies to all HTMLelements which trigger fetches, as well as to fetches triggered from CSSand JavaScript. Moreover, integrity metadata may also be useful for purposes other thanvalidation. User agents may decide to use the integrity metadata as anidentifier in a local cache, for instance, meaning that common resources(for example, JavaScript libraries) could be cached and retrieved once,regardless of the URL from which they are loaded. 1.1 Goals Compromise of the third-party service should not automatically meancompromise of every site which includes its scripts. Content authorswill have a mechanism by which they can specify expectations forcontent they load, meaning for example that they could load aspecific script, and not any script that happens to have aparticular URL. The verification mechanism should extend to all resource types thata page may fetch in the course of its execution and rendering. Activecontent (scripts, style, iframe contents, etc) are, of course,critical, but inactive content such as images and fonts will also becovered. The verification mechanism should have reporting functionality whichwould inform the author that an invalid resource was downloaded.Further it should be possible for an author to choose to run onlythe reporting functionality, allowing potentially corrupt resourcesto run on her site, but flagging violations for manual review. The metadata provided for verification may enable improvements touser agentsâ€™ caching schemes: common resources such as JavaScriptlibraries can be downloaded once, and only once, even if multipleinstances with distinct URLs are requested. (potentially) Relax mixed-content warnings for resources whoseintegrity is verified. If the integrity metadata for a resourceis delivered over a secure channel, the user agent might choose toallow loading the resource over an insecure channel. (potentially) Allow resources to be downloaded from non-canonicalsources (for instance, over an insecure channel) for performance,but fall back to a canonical source if the non-canonical sourcefails an integrity check. Issue 1 Iâ€™m not sure about #5 and #6. Get more detail from the WG about thebenefits that such a fallback system would enable. (mkwst) 1.2 Use Cases/Examples 1.2.1 Resource Integrity An author wants to include JavaScript provided by a third-partyanalytics service on her site. She wants, however, to ensure that onlythe code sheâ€™s carefully reviewed is executed. She can do so by generatingintegrity metadata for the script sheâ€™s planning on including, andadding it to the script element she includes on her page: Example 2 <script src="https://analytics-r-us.com/v1.0/include.js"        integrity="ni:///sha-256;SDfwewFAE...wefjijfE?ct=application/javascript"></script> An advertising network wishes to ensure that advertisements delivered viathird-party servers matches the code which they reviewed in order to reducethe risk of accidental or malicious substitution of unreviewed content. Byadding integrity metadata to the iframe element wrapping theadvertisement, they can ensure that the third-party server delivers onlythe agreed-upon content. Example 3 <iframe src="https://awesome-ads.com/advertisement1.html"        integrity="ni:///sha-256;kasfdsaffs...eoirW-e?ct=text/html"></iframe> A user agent wishes to ensure that pieces of its UI which are rendered viaHTML (for example, Chromeâ€™s New Tab Page) arenâ€™t manipulated before display.Integrity metadata mitigates the risk that altered JavaScript will runin these pageâ€™s high-privilege context. The author of a mash-up wants to make sure her creation remains in a workingstate. Adding integrity metadata to external subresources defines anexpected revision of the included files. The author can then use the reportingfunctionality to be notified of changes to the included resources. 1.2.2 Downloads A software distribution service wants to ensure that files are correctlydownloaded. It can do so by adding integrity metadata to the aelements which users click on to trigger a download: Example 4 <a href="https://software-is-nice.com/awesome.exe"   integrity="ni:///sha-256;fkfrewFRFEFHJR...wfjfrErw?ct=application/octet-stream"   download>...</a> 1.2.3 Fallback An author wishes to load a resource over an insecure channel for performancereasons, but fall back to a secure channel if the insecurely-loaded resourceis manipulated. She can do this by adding integrity metadata and anon-canonical source to the script element: Example 5 <script src="https://rockin-resources.com/script.js"        noncanonical-src="http://insecurity-is-inherent.net/script.js"        integrity="ni:///sha-256;asijfiqu4t12...woeji3W?ct=application/javascript"></script> 2. Conformance As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative. The key words MUST, MUST NOT, REQUIRED, SHOULD, SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL in this specification are to be interpreted as described in [RFC2119]. Conformance requirements phrased as algorithms or specific steps can beimplemented in any manner, so long as the end result is equivalent. Inparticular, the algorithms defined in this specification are intended tobe easy to understand and are not intended to be performant. Implementersare encouraged to optimize. 2.1 Key Concepts and Terminology This section defines several terms used throughout the document. The term digest refers to the base64url-encoded result ofexecuting a cryptographic hash function on an arbitrary block of data. A secure channel is any communication mechanism that the useragent has defined as â€œsecureâ€? (typically limited to HTTP over TransportLayer Security (TLS) [RFC2818]). An insecure channel is any communication mechanism other thanthose the user agent has defined as â€œsecureâ€?. The term origin is defined in the Origin specification.[RFC6454] The MIME type of a resource is a technical hint about the useand format of that resource. [MIMETYPE] The entity body, transfer encoding, contentencoding and message body of a resource is defined by theHTTP 1.1 specification, section 7.2. [HTTP11] A base64url encoding is defined inRFC 4648, section 5. In a nutshell, it replaces the charactersU+002B PLUS SIGN (+) and U+002F SOLIDUS (/) characters in normal base64encoding with the U+002D HYPHEN-MINUS (-) and U+005F LOW LINE (_)characters, respectively. [RFC4648] The Augmented Backus-Naur Form (ABNF) notation used in this document isspecified in RFC 5234. [ABNF] The SHA-256, SHA-384, and SHA-512 are partof the SHA-2 set of cryptographic hash functions defined by theNIST in â€œDescriptions of SHA-256, SHA-384, and SHA-512â€?. 3. Framework The integrity verification mechanism specified here boils down to theprocess of generating a sufficiently strong cryptographic digest for aresource, and transmitting that digest to a user agent so that it may beused when fetching the resource. 3.1 Integrity metadata To verify the integrity of a resource, a user agent requires integritymetadata, which consists of the following pieces of information: cryptographic hash function digest the resourceâ€™s MIME type The hash function and digest MUST be provided in order to validate aresourceâ€™s integrity. The MIME type SHOULD be provided, as it mitigates therisk of certain attack vectors (see MIME Type confusion inthis documentâ€™s Security Considerations section). This metadata is generally encoded as a â€œnamed informationâ€? (ni) URI, asdefined in RFC6920. [RFC6920] For example, given a resource containing only the string â€œHello, world!â€?,an author might choose SHA-256 as a hash function.-MO_YqmqPm_BYZwlDkir51GTc9Pt9BvmLrXcRRma8u8 is the base64url-encodeddigest that results. This can be encoded as an ni URI as follows: Example 6 ni:///sha-256;-MO_YqmqPm_BYZwlDkir51GTc9Pt9BvmLrXcRRma8u8 Or, if the author further wishes to specify the content type (text/plain): Example 7 ni:///sha-256;-MO_YqmqPm_BYZwlDkir51GTc9Pt9BvmLrXcRRma8u8?ct=text/plain Note Digests may be generated using any number of utilities. OpenSSL, forexample, is quite commonly available. The example in this section is theresult of the following command line: echo -n "Hello, world." | openssl dgst -sha256 -binary | openssl enc -base64 | sed -e 's/+/-/g' -e 's/\//_/g' 3.2 Cryptographic hash functions Conformant user agents MUST support the SHA-256 and SHA-512cryptographic hash functions for use as part of a resourceâ€™sintegrity metadata. 3.3 Resource verification algorithms 3.3.1 Apply algorithm to resource If algorithm is not a hash function recognized and supportedby the user agent, return null. Let result be the result of applying algorithm tothe content of the entity body of resource, including anycontent coding that has been applied, but not including anytransfer encoding applied to the message body. Let encodedResult be result of base64url-encodingresult. Strip any trailing U+003D EQUALS SIGN (=) characters fromencodedResult. Return encodedResult. Issue 2 Step 2 is pulled from the content-md5 definition in [HTTP11]. Itâ€™sunclear that itâ€™s what we want. See bzbarskyâ€™s WG post on this topic 3.3.2 Is resource eligible for integrity validation In order to mitigate an attackerâ€™s ability to read data cross-origin bybrute-forcing values via integrity checks, resources are only eligiblefor such checks if they are same-origin, publicly cachable, or are theresult of explicit access granted to the loading origin via CORS. [CORS] Certain HTTP headers can also change the way the resource behaves inways which integrity checking cannot account for. If the resourcecontains these headers, it is ineligible for integrity validation: WWW-Authenticate hides resources behind a login; such non-publicresources are excluded from integrity checks. Refresh can cause IFrame contents to transparently redirect to anunintended target, bypassing the integrity check. Issue 3 Consider the impact of other headers: Content-Length, Content-Range,etc. Is there danger there? The following algorithm details these restrictions: Let request be the request that fetchedresource. If resource contains any of the following HTTP headers,return false: WWW-Authenticate Refresh If the mode of request is CORS,return true. If the origin of request isresourceâ€™s origin, return true. If resource is cachable by a shared cache, as definedin [HTTP11], return true. Return false. Note Step 2 returns true if the resource was a CORS-enabled request. If theresource failed the CORS checks, it wonâ€™t be available to us for integritychecking because it wonâ€™t have loaded successfully. 3.3.3 Does resource match metadata? If metadata is the empty string, return true. If resourceâ€™s URLâ€™s scheme is about, return true. If metadata is not a valid â€œnamed informationâ€? (ni) URI,return false. If resource is not eligible for integrityvaliation, return false. Let algorithm be the alg component ofmetadata. Let expectedValue be the val component ofmetadata. Let expectedType be the value of metadataâ€™s ctquery string parameter. If expectedType is not the empty string, and is not acase-insensitive match for resourceâ€™s MIME type,return false. Let actualValue be the result of applyingalgorithm to resource. If actualValue is null, return false. If actualValue is a case-sensitive match forexpectedValue, return true. Otherwise, return false. Note If expectedType is the empty string in #6, it wouldbe reasonable for the user agent to warn the pageâ€™s author about thedangers of MIME type confusion attacks via its developer console. 3.4 Modifications to Fetch The Fetch specification should contain the following modifications in orderto enable the rest of this specificationâ€™s work: The following text should be added to section 2.2: â€œArequest has an associated integrity metadata.Unless stated otherwise, a requestâ€™s integrity metadata is the emptystring.â€? The following text should be added to section 2.3: â€œAresponse has an associated integrity state, whichis one of indeterminate, pending, corrupt, and intact. Unlessstated otherwise, it is indeterminate. Perform the following steps before executing both the â€œbasic fetchâ€? andâ€œCORS fetch with preflightâ€? algorithms: If requestâ€™s integrity metadata is the empty string, setresponseâ€™s integrity state to indeterminate. Otherwise: Set responseâ€™s integrity state to pending. Include a Cache-Control header whose value is â€œno-transformâ€?. If requestâ€™s integrity metadata contains a contenttype: Set requestâ€™s Accept header value to the valueof requestâ€™s integrity metadataâ€™s content type. Add the following step before step #1 of the handling of 401 statuscodes for both â€œbasic fetchâ€? and â€œCORS fetch with preflightâ€? algorithms: If requestâ€™s integrity state is pending, setresponseâ€™s integrity state to corrupt and returnresponse. Before firing the process request end-of-file event for anyrequest: If the requestâ€™s integrity metadata is the empty string, setthe responseâ€™s integrity state to indeterminate andskip directly to firing the event. If response matches the requestâ€™s integritymetadata, set the responseâ€™s integrity state to intactand skip directly to firing the event. Set the responseâ€™s integrity state to corruptand skip directly to firing the event. 3.5 Verification of HTML document subresources A variety of HTML elements result in requests for resources that are to beembedded into the document, or executed in its context. To support integritymetadata for each of these, and new elements that are added in the future,a new integrity attribute is added to the list of content attributes forthe a, audio, embed, iframe, link, object, script, source,track, and video elements. A corresponding integrity IDL attribute which reflects thevalue each elementâ€™s integrity content attribute is added to theHTMLAnchorElement, HTMLMediaElement, HTMLEmbedElement,HTMLIframeElement, HTMLLinkElement, HTMLObjectElement,HTMLScriptElement, HTMLSourceElement, and HTMLTrackElementinterfaces. 3.5.1 The integrity attribute The integrity attribute represents integrity metadata for an element.The value of the attribute MUST be either the empty string, or onevalid â€œnamed informationâ€? (ni) URI [RFC6920], as described by thefollowing ABNF grammar: integrity-metatata = "" / 1#( *WSP NI-URL ) *WSP ] The NI-URL rule is defined in RFC6920, section 3, figure 4. The integrity IDL attribute must reflect the integrity content attribute. Issue 4 We should consider supporting multiple ni URLs, which could allow migrationbetween algorithms. 3.5.2 The noncanonical-src attribute (TODO) Authors MAY opt-in to a fallback mechanism whereby user agents would initiallyattempt to load resources from a non-canonical source (perhaps over HTTP, forperformance and caching reasons). If that fetch failed an integrity check, theuser agent would report a violation, and retry the fetch using a canonicalURL (perhaps over HTTPS). The non-canonical URL is specified via a noncanonical-src attribute. Forexample: Example 8 <script src="http://example.com/script.js"        noncanonical-src="http://cdn.example.com/script.js"        integrity="ni:///sha-256;jsdfhiuwergn...vaaetgoifq?ct=application/javascript"></script> The noncanonicalSrc IDL attribute MUST reflect the noncanonical-srccontent attribute. The noncanonical resource MUST be fetched with its omit credentialsmode set to always, to prevent leakage of cookies across insecurechannels. Issue 5 This attribute (and fallback in general) only makes sense if we careabout allowing cache-friendly (read â€œHTTPâ€?) URLs to load in an HTTPS contextwithout warnings. Iâ€™m not sure we do, so Iâ€™m not going to put too muchthought into the details here before we discuss things a bit more. (mkwst) 3.5.3 Element interface extensions 3.5.3.1 HTMLAnchorElement partial interface HTMLAnchorElement {                attribute DOMString integrity;}; 3.5.3.1.1 Attributes integrity of type DOMString, The value of this elementâ€™s integrity attribute 3.5.3.2 HTMLEmbedElement partial interface HTMLObjectElement {                attribute DOMString integrity;}; 3.5.3.2.1 Attributes integrity of type DOMString, The value of this elementâ€™s integrity attribute 3.5.3.3 HTMLIFrameElement partial interface HTMLIFrameElement {                attribute DOMString integrity;}; 3.5.3.3.1 Attributes integrity of type DOMString, The value of this elementâ€™s integrity attribute 3.5.3.4 HTMLImageElement partial interface HTMLImageElement {                attribute DOMString integrity;}; 3.5.3.4.1 Attributes integrity of type DOMString, The value of this elementâ€™s integrity attribute 3.5.3.5 HTMLLinkElement partial interface HTMLLinkElement {                attribute DOMString integrity;}; 3.5.3.5.1 Attributes integrity of type DOMString, The value of this elementâ€™s integrity attribute 3.5.3.6 HTMLMediaElement partial interface HTMLMediaElement {                attribute DOMString integrity;}; 3.5.3.6.1 Attributes integrity of type DOMString, The value of this elementâ€™s integrity attribute 3.5.3.7 HTMLObjectElement partial interface HTMLObjectElement {                attribute DOMString integrity;}; 3.5.3.7.1 Attributes integrity of type DOMString, The value of this elementâ€™s integrity attribute 3.5.3.8 HTMLScriptElement partial interface HTMLScriptElement {                attribute DOMString integrity;}; 3.5.3.8.1 Attributes integrity of type DOMString, The value of this elementâ€™s integrity attribute 3.5.3.9 HTMLTrackElement partial interface HTMLTrackElement {                attribute DOMString integrity;}; 3.5.3.9.1 Attributes integrity of type DOMString, The value of this elementâ€™s integrity attribute 3.5.4 Handling integrity violations Documents may specify the behavior of a failed integrity check by deliveringa Content Security Policy which contains an integrity-policydirective, defined by the following ABNF grammar: directive-name  = "integrity-policy"directive-value = 1#failure-mode [ "require-for-all" ]failure-mode    = ( "block" / "report" / "fallback" ) A documentâ€™s integrity policy is the value of theintegrity-policy directive, if explicitly provided as part of thedocumentâ€™s Content Security Policy, or block otherwise. If the documentâ€™s integrity policy contains block, the user agent MUST refuseto render or execute resources that fail an integrity check, and MUSTreport a violation. If the documentâ€™s integrity policy contains report, the user agent MAY renderor execute resources that fail an integrity check, but MUSTreport a violation. Issue 6 If the documentâ€™s integrity policy contains fallback, the user agent MUSTrefuse to render or execute resources that fail an integrity check, andMUST report a violation. The user agent MAY additionally choose to loada fallback resource as specified for each relevant element. If the fallbackresource fails an integrity check, the user agent MUST refuse to render orexecute the resource, and MUST report a(nother)violation. (See the noncanonical-srcattribute for a strawman of how that might look). Issue 7 If the documentâ€™s integrity policy contains require-for-all, the user agentMUST treat the lack of integrity metadata for an resource as automaticfailure, refuse to fetch the resource, and report a violation. 3.5.5 Elements 3.5.5.1 The a element If an a element has both integrity and download attributes, the useragent has all the data it needs in order to verify the integrity of thedownloaded resource. This is the only type of download we can safely makepromises about, so it is the only type of download that we support. Ifintegrity metadata is added to any a element that does not explicitlyrequest that the resource it points to be downloaded, user agents MUSTtreat the link as broken. Before following a hyperlink, the user agent MUST run the following steps: If subject has an integrity attribute whose value is not theempty string, then: The user agent MAY report an error to the user in auser-agent-specific manner. Abort the following a hyperlink algorithm. Replace step 6 of the downloads a hyperlink algorithm with the following: If the integrity attribute of that element is not the empty string, andthe element does not have a download attribute, abort these steps. Fetch URL with integrity metadata set to the value of theintegrity attribute of that element, and handle the resulting resourceas a download. When handling a resource as a download, perform the following step beforeproviding a user with a way to save the resource for later use: If responseâ€™s integrity state is corrupt and the documentâ€™sintegrity policy is block, the user agent MUST report a violation,and MUST abort the download. Note Note that this will cover only downloads triggered explicitly by adding adownload attribute to an a element. Such a link might look like the following: Example 9 <a href="https://example.com/file.zip"   integrity="ni:///sha256;skjdsfkafinqfb...ihja_gqg?ct=application/octet-stream"   download>Download!</a> 3.5.5.2 The embed element When fetching an URL via step 2 of the embed element setup stepsalgorithm: Set the integrity metadata of the request to the valueof the elementâ€™s integrity attribute. Before running the task queued by the networking task source once the URL hasbeen fetched, first perform the following steps: If the responseâ€™s integrity state is corrupt: If the documentâ€™s integrity policy is block: Set the elementâ€™s type attribute to the empty string. Skip to step 4 of the algorithm. Report a violation. 3.5.5.3 The iframe element When content is to be loaded into the child browsing context createdby an iframe, perform fetches with the integrity metadata set to thevalue of the iframe elementâ€™s integrity attribute. Moreover: If the documentâ€™s integrity policy is block, then the useragent MUST delay rendering the content until thefetching algorithmâ€™s task to process request end-of-filecompletes. When the process request end-of-file task completes: If the requestâ€™s integrity state is corrupt: If resource is same origin with the documentâ€™sbrowsing context owner iframe elementâ€™s Documentâ€™s origin, thenqueue a task to fire a simple event named error at theiframe element (this will not fire for cross-origin requests, toavoid leaking data about those resourceâ€™s content). Report a violation. Navigate the child browsing context to about:blank. Note Note that this will only check the integrity of the iframeâ€™s document source.No subsequent verification for the documentâ€™s subresources is perfomed.If integrity checks for the documentâ€™s subresources are desirable, the documentloaded into the iframe needs to include integrity metadata for its subresources. Issue 8 How does this effect things like the preload scanner? How much work is itgoing to be for vendors to change the â€œdisplay whatever weâ€™ve got, ASAP!â€?behavior that makes things fast for users? How much impact will there beon user experience, especially for things like ads, where this kind ofvalidation has the most value? Issue 9 How do we deal with navigations in the child browsing context? Are theysimply disallowed? If so, does that make sense? It might for ads, butwhat about other use-cases? 3.5.5.4 The img element When fetching an image via step 12 of the update the image dataalgorithm: Set the integrity metadata of the request to the valueof the elementâ€™s integrity attribute. Before jumping one of the entries from the list in step 14 of theupdate the image data algorithm, first perform the followingsteps: If the responseâ€™s integrity state is corrupt: If the documentâ€™s integrity policy is block: Abort the jump in progress. Perform the steps in the entry labeled â€œOtherwiseâ€? under step 14. Report a violation. 3.5.5.5 The link element Whenever a user agent attempts to obtain a resource pointed to by alink element: Set the integrity metadata of the request to the valueof the elementâ€™s integrity attribute. Additionally, perform the following steps before firing a load event atthe element: If the responseâ€™s integrity state is corrupt: If the documentâ€™s integrity policy is block: Abort the load event, and treat the resource as having failedto load. If resource is same origin with the origin ofthe link elementâ€™s Document, then queue a task tofire a simple event named error at the link element. Report a violation. 3.5.5.6 The object element When fetching an image via step 4 of step 4 of the â€œdetermine what theobject element representsâ€? algorithm: Set the integrity metadata of the request to the valueof the elementâ€™s integrity attribute. Before step 7 of the â€œdetermine what the object element representsâ€?algorithm, first perform the following steps: If the responseâ€™s integrity state is corrupt: If the documentâ€™s integrity policy is block: Fire a simple event named error at the element. Jump to the step labeled fallback. Report a violation. 3.5.5.7 The script element When executing step 5 of step 14 of HTML5â€™sâ€œprepare a scriptâ€? algorithm: Set the integrity metadata of the request to the valueof the elementâ€™s integrity attribute. Insert the following steps after step 5 of step 14 of HTML5â€™sâ€œprepare a scriptâ€? algorithm: Once the fetching algorithm has completed: If the responseâ€™s integrity state is corrupt: If the documentâ€™s integrity policy is block: If resource is same origin with the linkelementâ€™s Documentâ€™s origin, then queue a task tofire a simple event named error at the element, andabort these steps. Report a violation. 3.5.5.8 The track element When fetching the track URL in step 10 of the start the trackprocessing model algorithm: Set the integrity metadata of the request to the valueof the elementâ€™s integrity attribute. Additionally, perform the following steps before performing the stepsspecified for a successful track fetch: If the responseâ€™s integrity state is corrupt: If the documentâ€™s integrity policy is block: Perform the steps specified for a failed track fetch. Abort the steps specified for a successful track fetch. Report a violation. 3.5.5.9 The audio element (TODO) Issue 10 TODO: Write this section? Might want to delay media elements until we have a solution to streaming. 3.5.5.10 The source element (TODO) Issue 11 TODO: Write this section? Might want to delay media elements until we have a solution to streaming. 3.5.5.11 The video element (TODO) Issue 12 TODO: Write this section? Might want to delay media elements until we have a solution to streaming. 3.6 Verification of CSS-loaded subresources Issue 13 Tab and Anne are poking at adding fetch() to some spec somewherewhich would allow CSS files to specify various arguments to the fetchalgorithm while requesting resources. Detail on the proposal is athttp://lists.w3.org/Archives/Public/public-webappsec/2014Jan/0129.html.Once that is specified, we can proceed defining an integrity argumentthat would allow integrity checks in CSS. 3.7 Verification of JS-loaded subresources Issue 14 These sections are less fleshed out and debated than the HTML sections, wherethe WG has concentrated most of its time thus far. 3.7.1 Workers To validate the integrity of scripts which are to be run as workers, a newconstructor is added for Worker and SharedWorker which accepts a secondargument containing integrity metadata. This information is used whenrunning a worker to perform validation, as outlined in thefollowing sections: [WEBWORKERS] 3.7.1.1 Worker extension [Constructor (DOMString scriptURL, DOMString integrityMetadata)]partial interface Worker : EventTarget {                attribute DOMString integrity;}; 3.7.1.1.1 Attributes integrity of type DOMString, The value of the Workerâ€™s integrity attribute. Defaults to the empty string. When the Worker(scriptURL, integrityMetadata) constructor is invoked: If integrityMetadata is not a valid â€œnamed informationâ€? (ni) URL,throw a SyntaxError exception and abort these steps. Execute the Worker(scriptURL) constructor, and set the newly createdWorker objectâ€™s integrity attribute to integrityMetadata. 3.7.1.2 SharedWorker extension [Constructor (DOMString scriptURL, DOMString name, DOMString integrityMetadata)]partial interface Worker : EventTarget {                attribute DOMString integrity;}; 3.7.1.2.1 Attributes integrity of type DOMString, The value of the SharedWorkerâ€™s integrity attribute. Defaults to the empty string. When the SharedWorker(scriptURL, name, integrityMetadata) constructor isinvoked: If integrityMetadata is not a valid â€œnamed informationâ€? (ni) URL,throw a SyntaxError exception and abort these steps. Execute the SharedWorker(scriptURL, name) constructor, and set thenewly created SharedWorker objectâ€™s integrity attribute tointegrityMetadata. 3.7.1.3 Validation Add the following step directly after step 4 of the run a workeralgorithm: If the script resource fetched in step 4 has an integrity status ofcorrupt, then for each Worker or SharedWorker object associatedwith worker global scope, queue a task to fire asimple event named error at that object. Abort these steps. 3.7.2 XMLHttpRequest To validate the integrity of resources loaded via XMLHttpRequest, a newintegrity attribute is added to the XMLHttpRequest object. If set, theintegrity metadata in this attribute is used to validate the resourcebefore triggering the load event. [XMLHTTPREQUEST] 3.7.2.1 The integrity attribute The integrity attribute must return its value. Initially its value MUSTbe the empty string. Setting the integrity attribute MUST run these steps: If the state is not UNSENT or OPENED, throw an InvalidStateErrorexception and abort these steps. If the value provided is not a valid â€œnamed informationâ€? (ni) URL,throw a â€œSyntaxError` exception and abort these steps. Set the integrity attributeâ€™s value to the value provided. 3.7.2.2 Progress events Validation only takes place when the entire resource body has beendownloaded. Data processed before the resource has completelyloaded (or failed to load) is unvalidated, and potentially corrupt.For that reason, if the documentâ€™s integrity policyis block, progress events will not fire until the fetch hascompleted, one way or another. If the documentâ€™s integrity policy is not block, developers whocare about integrity validation SHOULD still ignore progress eventsfired while the resource is downloading, and instead listen only forthe load, abort, and error events. If the documentâ€™s integrity policy is block, then: Before executing step 3.2 of the â€œprocess responseâ€? algorithm instep 13 of XMLHttpRequestâ€™s send(data) method: If the objectâ€™s integrity attribute is not the empty stringthe user agent MUST abort the â€œprocess responseâ€? algorithm, andMUST NOT fire the readystatechange event. Before executing step 2.2 of the â€œprocess response bodyâ€? algorithm instep 13 of XMLHttpRequestâ€™s send(data) method: If the objectâ€™s integrity attribute is not the empty stringthe user agent MUST abort the â€œprocess response bodyâ€? algorithm,and MUST NOT fire the readystatechange event. Before executing step 4 of the â€œprocess response bodyâ€? algorithm instep 13 of XMLHttpRequestâ€™s send(data) method: If the objectâ€™s integrity attribute is not the empty stringthe user agent MUST abort the â€œprocess response bodyâ€? algorithm,and MUST NOT fire the progress event. 3.7.2.3 Validation Whenever the user agent would switch an XMLHttpRequest object to theDONE state, then perform the following steps beforeswitching state: If the responseâ€™s integrity state is intact or indeterminate,then abort these steps, and continue toswitch to the DONE state. Otherwise, report a violation, and run the following stepsif the documentâ€™s integrity policy is block: Set the response entity body to null Run the request error steps for exceptionNetworkError and event error. Do not continue to switch to the DONE state. 4. Caching (Optional) The caching mechanism described in this section is OPTIONAL. JavaScript libraries are a good example of resources that are often loadedand reloaded from different locations as users browse the web:http://cdnjs.cloudflare.com/ajax/libs/jquery/1.10.2/jquery.min.js isexactly the same file ashttps://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js. Bothfiles are identifiable via the ni URLni:///sha-256;iaFenEC8axSAnyNu6M0-0epCOTwfbKVceFXNd5s_ki4?ct=application/javascript. To reduce the performance impact of reloading the same data, user agentsMAY use integrity metadata as a new index to a local cache, meaning thata user who had already loaded a version of the file from ajax.googleapis.comwouldnâ€™t have to touch the network to load the cdnjs.cloudflare.com version.The user agent knows that the content is the same, and would be free to treatthe latter as a cache hit, regardless of the location mismatch. 4.1 Risks This approach is good for performance, but can have security implications. Seethe origin confusion and MIME type confusion sections below for somedetails. 4.1.1 Origin confusion User agents which set up a caching mechanism that uses only the integritymetadata to identify a resource are vulnerable to attacks which bypasssame-origin restrictions unless they are very careful when choosing whetheror not to read data straight from the cache. For instance: Runtime script errors are sanitized for resources that areCORS-cross-origin to the page into which they are loaded. [HTML5] XMLHttpRequest may only load data from same-origin resources, or fromresources delivered with proper CORS headers. [XMLHTTPREQUEST] Content Security Policy performs origin-based security checks. [CSP] Issue 15 More? Note The simple cache-poisoning version of this attack can be mitigated byrequiring strong hash functions for cachable resources. More complexvariants are more difficult to mitigate. Consider the following: An attacker lures Alice to a page containing the following code: Example 10 <script src="http://evil.com/evil.js" digest="ni://sha-256;123...789"> Aliceâ€™s user agent loads evil.js, and stores it in her cache. Though bank.com is protected by a CSP which allows only script frombank.com, the attacker may still be able to exploit an XSS vulnerabilityin bank.com which allows the injection of: Example 11 <script src="http://bank.com/awesome.js" digest="ni://sha-256;123...789"> Since the script appears to come from bank.com, CSP allows it, even thoughit doesnâ€™t actually exist on that server. 4.1.2 MIME type confusion User agents which set up a caching mechanism that uses only the integritymetadata to identify a resource are vulnerable to attacks which createresources that behave differently based on the context in which they areloaded. Gifar is the canonical example of such an attack. Authors SHOULD mitigate this risk by specifying the expected content typealong with the digest, as specified in RFC 6920, section 3.1.This means that the content type will be verified along with the digest whendetermining whether a resource matches certain integritymetadata. 4.2 Recommendations To mitigate the risk of cross-origin data leakage or type-sniffingexploitation, user agents that take this approach to caching MUST NOTuse integrity metadata as a cache identifier unless the followingare all true: The integrity metadata contains a content type. The resource was delivered in response to an HTTP GET request (and notPOST, OPTIONS, TRACE, etc.) The resource was delivered with an Access-Control-Allow-Origin HTTPheader with a value of * [CORS] The integrity metadata uses a hash function with very strong uniquenesscharacteristics: SHA-512 or better. If a Content Security Policy is active in a context, the script orlink element which triggered the resourceâ€™s fetch has a valid nonce. Issue 16 More ideas? Limiting to resources with wide-open CORS headers and stronghash functions seems like a reasonable startâ€¦ 5. Proxies Optimizing proxies and other intermediate servers which modify thecontent of fetched resources MUST ensure that the digest associatedwith those resources stays in sync with the new content. One optionis to ensure that the integrity metadata associated withresources is updated along with the resource itself. Anotherwould be simply to deliver only the canonical version of resourcesfor which a page author has requested integrity verification. Tosupport this latter option, user agents MAY send aCache-Control header with a value ofno-transform. Issue 17 Think about how integrity checks would effect vary headersin general. 6. Security Considerations 6.1 Insecure channels remain insecure Integrity metadata delivered over an insecure channel provides no securitybenefit. Attackers can alter the digest in-flight (or remove it entirely (ordo absolutely anything else to the document)), just as they could alter theresource the hash is meant to validate. Authors who desire any sort ofsecurity whatsoever SHOULD deliver resources containing digests oversecure channels. 6.2 Hash collision attacks Digests are only as strong as the hash function used to generate them. Useragents SHOULD refuse to support known-weak hashing functions like MD5, andSHOULD restrict supported hashing functions to those known to becollision-resistant. At the time of writing, SHA-256 is a good baseline.Moreover, user agents SHOULD reevaluate their supported hashing functionson a regular basis, and deprecate support for those functions shown to beinsecure. 6.3 Cross-origin data leakage Attackers can determine whether some cross-origin resource has certaincontent by attempting to load it with a known digest, and watching forload failure. If the load fails, the attacker can surmise that theresource didnâ€™t match the hash, and thereby gain some insight into itscontents. This might reveal, for example, whether or not a user islogged into a particular service. Moreover, attackers can brute-force specific values in an otherwisestatic resource: consider a document that looks like this: Example 12 <html>{static content}<h1>Hello, $username!</h1>{static content}</html> An attacker can precompute hashes for the page with a variety ofcommon usernames, and specify those hashes while repeatedly attemptingto load the document. By examining the reported violations, the attackercan obtain a userâ€™s username. User agents SHOULD mitigate the risk by refusing to fire error eventson elements which loaded cross-origin resources, but some side-channelswill likely be difficult to avoid (imageâ€™s naturalHeight andnaturalWidth for instance). 7. Acknowledgements None of this is new. Much of the content here is inspired heavily by GervaseMarkhamâ€™s Link Fingerprints concept, as well as WHATWGâ€™s Link Hashes. A. References A.1 Normative references [ABNF] D. Crocker; P. Overell. Augmented BNF for Syntax Specifications: ABNF. January 2008. STD. URL: http://www.ietf.org/rfc/rfc5234.txt [CORS] Anne van Kesteren. Cross-Origin Resource Sharing. 16 January 2014. W3C Recommendation. URL: http://www.w3.org/TR/cors/ [CSP] Adam Barth; Dan Veditz; Mike West. Content Security Policy 1.1. Working Draft. URL: http://w3.org/TR/CSP11 [HTML5] Robin Berjon; Steve Faulkner; Travis Leithead; Erika Doyle Navara; Edward O'Connor; Silvia Pfeiffer. HTML5. 4 February 2014. W3C Candidate Recommendation. URL: http://www.w3.org/TR/html5/ [HTTP11] R. Fielding et al. Hypertext Transfer Protocol - HTTP/1.1. June 1999. RFC. URL: http://www.ietf.org/rfc/rfc2616.txt [MIMETYPE] Ned Freed; Nathaniel S. Borenstein. Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types. Draft Standard. URL: http://tools.ietf.org/html/rfc2046 [RFC2119] S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Internet RFC 2119. URL: http://www.ietf.org/rfc/rfc2119.txt [RFC2818] E. Rescorla. HTTP Over TLS. May 2000. RFC. URL: http://www.ietf.org/rfc/rfc2818.txt [RFC4648] Simon Josefsson. The Base16, Base32, and Base64 Data Encodings. Proposed Standard. URL: http://tools.ietf.org/html/rfc4648 [RFC6454] A. Barth. The Web Origin Concept. December 2011. RFC. URL: http://www.ietf.org/rfc/rfc6454.txt [RFC6920] Stephen Farrell; Dirk Kutscher; Christian Dannewitz; Borje Ohlman; Ari Keranen; Phillip Hallam-Baker. Naming Things with Hashes. Proposed Standard. URL: http://tools.ietf.org/html/rfc6920 [WEBWORKERS] Ian Hickson. Web Workers. 1 May 2012. W3C Candidate Recommendation. URL: http://www.w3.org/TR/workers/ [XMLHTTPREQUEST] Anne van Kesteren; Julian Aubourg; Jungkee Song; Hallvord Steen et al. XMLHttpRequest Level 1. 30 January 2014. W3C Working Draft. URL: http://www.w3.org/TR/XMLHttpRequest/