XPath and XQuery Functions and Operators 3.0 XPath and XQuery Functions andOperators 3.0 W3C Recommendation08 April 2014 This version: http://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/ Latest version of XPath and XQuery Functions and Operators3.0: http://www.w3.org/TR/xpath-functions-30/ Previous versions of XPath and XQuery Functions and Operators3.0: http://www.w3.org/TR/2013/PR-xpath-functions-30-20131022/,http://www.w3.org/TR/2013/CR-xpath-functions-30-20130521/,http://www.w3.org/TR/2013/CR-xpath-functions-30-20130108/,http://www.w3.org/TR/2011/WD-xpath-functions-30-20111213/,http://www.w3.org/TR/2011/WD-xpath-functions-30-20110614/,http://www.w3.org/TR/2010/WD-xpath-functions-30-20101214/,http://www.w3.org/TR/2009/WD-xpath-functions-11-20091215/ Most recent version of XPath and XQuery Functions and Operators3: http://www.w3.org/TR/xpath-functions-3/ Most recent Recommendation of XPath and XQuery Functions andOperators: http://www.w3.org/TR/2010/REC-xpath-functions-20101214/ Editor: Michael Kay (XSL WG), Saxonica <http://www.saxonica.com/> Please check the errata for any errors or issues reported sincepublication. See also translations. This document is also available in these non-normative formats:XML and Changemarkings relative to previous edition. Copyright Â© 2014 W3CÂ®(MIT, ERCIM,Keio, Beihang), All Rights Reserved. W3Cliability,trademarkand documentuse rules apply. Abstract Change markings are relative to the Recommendation of 23 January2007. This document defines constructor functions, operators, andfunctions on the datatypes defined in [XMLSchema Part 2: Datatypes Second Edition] and the datatypesdefined in [XQuery and XPath DataModel (XDM) 3.0]. It also defines functions and operators onnodes and node sequences as defined in the [XQuery and XPath Data Model (XDM) 3.0].These functions and operators are defined for use in [XML Path Language (XPath) 3.0], [XQuery 3.0: An XML Query Language] and [XSL Transformations (XSLT) Version 3.0] and otherrelated XML standards. The signatures and summaries of functionsdefined in this document are available at: http://www.w3.org/2005/xpath-functions/. This is the third version of the specification of this functionlibrary. The first version was included as an intrinsic part of the[XML Path Language (XPath) Version 1.0]specification published on 16 November 1999. The second version waspublished under the title XQuery 1.0 and XPath 2.0 Functionsand Operators on 23 January 2007, subsequently revised in asecond edition published on 14 December 2010. This third version isthe first to carry its own version number, which has been set at3.0 to align with the version numbering for XPath, XQuery, andXSLT. Status of this Document This section describes the status of this document at thetime of its publication. Other documents may supersede thisdocument. A list of current W3C publications and the latestrevision of this technical report can be found in the W3C technical reports index athttp://www.w3.org/TR/. This is one document in a set of six documents that have beenprogressed to Recommendation together (XQuery 3.0, XQueryX 3.0,XPath 3.0, Data Model 3.0, Functions and Operators 3.0, andSerialization 3.0). This is a Recommendationof the W3C. It was jointly developed by the W3C XML Query Working Group and theW3C XSLT Working Group,each of which is part of the XML Activity. This Recommendation of XPath and XQuery Functions and Operators3.0 represents the second version of aprevious W3C Recommendation. This specification is designed to be referenced normatively fromother specifications defining a host language for it; it is notintended to be implemented outside a host language. Theimplementability of this specification has been tested in thecontext of its normative inclusion in host languages defined by theXQuery 3.0 and XSLT3.0 (expected in 2014) specifications; see the XQuery3.0 implementation report (and, in the future, the WGs expectthat there will also be a â€” possibly member-only â€” XSLT 3.0implementation report) for details. This document incorporates minor changes made against theProposedRecommendation of 22 October 2013. Changes to this documentsince the ProposedRecommendation are detailed in EChanges since previous Recommendation. Please report errors in this document using W3C's public Bugzilla system(instructions can be found at http://www.w3.org/XML/2005/04/qt-bugzilla).If access to that system is not feasible, you may send yourcomments to the W3C XSLT/XPath/XQuery public comments mailing list,public-qt-comments@w3.org.It will be very helpful if you include the string â€œ[FO30]â€? in thesubject line of your report, whether made in Bugzilla or in email.Please use multiple Bugzilla entries (or, if necessary, multipleemail messages) if you have more than one comment to make. Archivesof the comments and responses are available at http://lists.w3.org/Archives/Public/public-qt-comments/. This document has been reviewed by W3C Members, by softwaredevelopers, and by other W3C groups and interested parties, and isendorsed by the Director as a W3C Recommendation. It is a stabledocument and may be used as reference material or cited fromanother document. W3C's role in making the Recommendation is todraw attention to the specification and to promote its widespreaddeployment. This enhances the functionality and interoperability ofthe Web. This document was produced by groups operating under the5February 2004 W3C Patent Policy. W3C maintains a publiclist of any patent disclosures made in connection with thedeliverables of the XML Query Working Group and also maintains apubliclist of any patent disclosures made in connection with thedeliverables of the XSL Working Group; those pages also includeinstructions for disclosing a patent. An individual who has actualknowledge of a patent which the individual believes containsEssential Claim(s) must disclose the information in accordancewith section 6 of the W3C Patent Policy. QuickContents abs acos add-dayTimeDurations add-dayTimeDuration-to-date add-dayTimeDuration-to-dateTime add-dayTimeDuration-to-time add-yearMonthDurations add-yearMonthDuration-to-date add-yearMonthDuration-to-dateTime adjust-dateTime-to-timezone adjust-date-to-timezone adjust-time-to-timezone analyze-string asin atan atan2 available-environment-variables avg base64Binary-equal base-uri boolean boolean-equal boolean-greater-than boolean-less-than ceiling codepoint-equal codepoints-to-string collection compare concat concatenate contains cos count current-date current-dateTime current-time data date-equal date-greater-than date-less-than dateTime dateTime-equal dateTime-greater-than dateTime-less-than day-from-date day-from-dateTime days-from-duration dayTimeDuration-greater-than dayTimeDuration-less-than deep-equal default-collation distinct-values divide-dayTimeDuration divide-dayTimeDuration-by-dayTimeDuration divide-yearMonthDuration divide-yearMonthDuration-by-yearMonthDuration doc doc-available document-uri duration-equal element-with-id empty encode-for-uri ends-with environment-variable error escape-html-uri exactly-one except exists exp exp10 false filter floor fold-left fold-right for-each for-each-pair format-date format-dateTime format-integer format-number format-time function-arity function-lookup function-name gDay-equal generate-id gMonthDay-equal gMonth-equal gYear-equal gYearMonth-equal has-children head hexBinary-equal hours-from-dateTime hours-from-duration hours-from-time id idref implicit-timezone index-of innermost in-scope-prefixes insert-before intersect iri-to-uri is-same-node lang last local-name local-name-from-QName log log10 lower-case matches max min minutes-from-dateTime minutes-from-duration minutes-from-time month-from-date month-from-dateTime months-from-duration multiply-dayTimeDuration multiply-yearMonthDuration name namespace-uri namespace-uri-for-prefix namespace-uri-from-QName nilled node-after node-before node-name normalize-space normalize-unicode not NOTATION-equal number numeric-add numeric-divide numeric-equal numeric-greater-than numeric-integer-divide numeric-less-than numeric-mod numeric-multiply numeric-subtract numeric-unary-minus numeric-unary-plus one-or-more outermost parse-xml parse-xml-fragment path pi position pow prefix-from-QName QName QName-equal remove replace resolve-QName resolve-uri reverse root round round-half-to-even seconds-from-dateTime seconds-from-duration seconds-from-time serialize sin sqrt starts-with static-base-uri string string-join string-length string-to-codepoints subsequence substring substring-after substring-before subtract-dates subtract-dateTimes subtract-dayTimeDuration-from-date subtract-dayTimeDuration-from-dateTime subtract-dayTimeDuration-from-time subtract-dayTimeDurations subtract-times subtract-yearMonthDuration-from-date subtract-yearMonthDuration-from-dateTime subtract-yearMonthDurations sum tail tan time-equal time-greater-than time-less-than timezone-from-date timezone-from-dateTime timezone-from-time to tokenize trace translate true union unordered unparsed-text unparsed-text-available unparsed-text-lines upper-case uri-collection year-from-date year-from-dateTime yearMonthDuration-greater-than yearMonthDuration-less-than years-from-duration zero-or-one Table of Contents 1 Introduction 1.1 Conformance 1.2 Namespaces and prefixes 1.3 Functionoverloading 1.4 Functionsignatures and descriptions 1.5 Typesystem 1.6 Terminology 1.6.1 Strings, characters, andcodepoints 1.6.2 Namespaces and URIs 1.6.3 Conformance terminology 1.6.4 Properties of functions 2 Accessors 2.1 fn:node-name 2.2 fn:nilled 2.3 fn:string 2.4 fn:data 2.5 fn:base-uri 2.6 fn:document-uri 3 Errors anddiagnostics 3.1 Raisingerrors 3.1.1 fn:error 3.2 Diagnostictracing 3.2.1 fn:trace 4 Functions and operators onnumerics 4.1 Numerictypes 4.2 Arithmeticoperators on numeric values 4.2.1 op:numeric-add 4.2.2 op:numeric-subtract 4.2.3 op:numeric-multiply 4.2.4 op:numeric-divide 4.2.5 op:numeric-integer-divide 4.2.6 op:numeric-mod 4.2.7 op:numeric-unary-plus 4.2.8 op:numeric-unary-minus 4.3 Comparisonoperators on numeric values 4.3.1 op:numeric-equal 4.3.2 op:numeric-less-than 4.3.3 op:numeric-greater-than 4.4 Functions on numeric values 4.4.1 fn:abs 4.4.2 fn:ceiling 4.4.3 fn:floor 4.4.4 fn:round 4.4.5 fn:round-half-to-even 4.5 Parsingnumbers 4.5.1 fn:number 4.6 Formatting integers 4.6.1 fn:format-integer 4.7 Formatting numbers 4.7.1 Defining a decimal format 4.7.2 fn:format-number 4.7.3 Syntax of the picture string 4.7.4 Analysing the picture string 4.7.5 Formatting the number 4.8 Trigonometricand exponential functions 4.8.1 math:pi 4.8.2 math:exp 4.8.3 math:exp10 4.8.4 math:log 4.8.5 math:log10 4.8.6 math:pow 4.8.7 math:sqrt 4.8.8 math:sin 4.8.9 math:cos 4.8.10 math:tan 4.8.11 math:asin 4.8.12 math:acos 4.8.13 math:atan 4.8.14 math:atan2 5 Functions on strings 5.1 Stringtypes 5.2 Functions to assemble anddisassemble strings 5.2.1 fn:codepoints-to-string 5.2.2 fn:string-to-codepoints 5.3 Comparison ofstrings 5.3.1 Collations 5.3.2 The Unicode Codepoint Collation 5.3.3 Choosing a collation 5.3.4 fn:compare 5.3.5 fn:codepoint-equal 5.4 Functions on string values 5.4.1 fn:concat 5.4.2 fn:string-join 5.4.3 fn:substring 5.4.4 fn:string-length 5.4.5 fn:normalize-space 5.4.6 fn:normalize-unicode 5.4.7 fn:upper-case 5.4.8 fn:lower-case 5.4.9 fn:translate 5.5 Functions based on substringmatching 5.5.1 fn:contains 5.5.2 fn:starts-with 5.5.3 fn:ends-with 5.5.4 fn:substring-before 5.5.5 fn:substring-after 5.6 Stringfunctions that use regular expressions 5.6.1 Regular expression syntax 5.6.2 fn:matches 5.6.3 fn:replace 5.6.4 fn:tokenize 5.6.5 fn:analyze-string 6 Functions that manipulateURIs 6.1 fn:resolve-uri 6.2 fn:encode-for-uri 6.3 fn:iri-to-uri 6.4 fn:escape-html-uri 7 Functions and operators on Booleanvalues 7.1 Booleanconstant functions 7.1.1 fn:true 7.1.2 fn:false 7.2 Operators onBoolean values 7.2.1 op:boolean-equal 7.2.2 op:boolean-less-than 7.2.3 op:boolean-greater-than 7.3 Functions on Boolean values 7.3.1 fn:boolean 7.3.2 fn:not 8 Functions and operators ondurations 8.1 Twototally ordered subtypes of duration 8.1.1 xs:yearMonthDuration 8.1.2 xs:dayTimeDuration 8.2 Comparisonoperators on durations 8.2.1 op:yearMonthDuration-less-than 8.2.2 op:yearMonthDuration-greater-than 8.2.3 op:dayTimeDuration-less-than 8.2.4 op:dayTimeDuration-greater-than 8.2.5 op:duration-equal 8.3 Component extraction functions ondurations 8.3.1 fn:years-from-duration 8.3.2 fn:months-from-duration 8.3.3 fn:days-from-duration 8.3.4 fn:hours-from-duration 8.3.5 fn:minutes-from-duration 8.3.6 fn:seconds-from-duration 8.4 Arithmetic operators on durations 8.4.1 op:add-yearMonthDurations 8.4.2 op:subtract-yearMonthDurations 8.4.3 op:multiply-yearMonthDuration 8.4.4 op:divide-yearMonthDuration 8.4.5 op:divide-yearMonthDuration-by-yearMonthDuration 8.4.6 op:add-dayTimeDurations 8.4.7 op:subtract-dayTimeDurations 8.4.8 op:multiply-dayTimeDuration 8.4.9 op:divide-dayTimeDuration 8.4.10 op:divide-dayTimeDuration-by-dayTimeDuration 9 Functions and operators on dates andtimes 9.1 Date andtime types 9.1.1 Limits and precision 9.2 Date/timedatatype values 9.2.1 Examples 9.3 Constructing a dateTime 9.3.1 fn:dateTime 9.4 Comparisonoperators on duration, date and time values 9.4.1 op:dateTime-equal 9.4.2 op:dateTime-less-than 9.4.3 op:dateTime-greater-than 9.4.4 op:date-equal 9.4.5 op:date-less-than 9.4.6 op:date-greater-than 9.4.7 op:time-equal 9.4.8 op:time-less-than 9.4.9 op:time-greater-than 9.4.10 op:gYearMonth-equal 9.4.11 op:gYear-equal 9.4.12 op:gMonthDay-equal 9.4.13 op:gMonth-equal 9.4.14 op:gDay-equal 9.5 Component extraction functions ondates and times 9.5.1 fn:year-from-dateTime 9.5.2 fn:month-from-dateTime 9.5.3 fn:day-from-dateTime 9.5.4 fn:hours-from-dateTime 9.5.5 fn:minutes-from-dateTime 9.5.6 fn:seconds-from-dateTime 9.5.7 fn:timezone-from-dateTime 9.5.8 fn:year-from-date 9.5.9 fn:month-from-date 9.5.10 fn:day-from-date 9.5.11 fn:timezone-from-date 9.5.12 fn:hours-from-time 9.5.13 fn:minutes-from-time 9.5.14 fn:seconds-from-time 9.5.15 fn:timezone-from-time 9.6 Timezoneadjustment functions on dates and time values 9.6.1 fn:adjust-dateTime-to-timezone 9.6.2 fn:adjust-date-to-timezone 9.6.3 fn:adjust-time-to-timezone 9.7 Arithmetic operators on durations, dates andtimes 9.7.1 Limits and precision 9.7.2 op:subtract-dateTimes 9.7.3 op:subtract-dates 9.7.4 op:subtract-times 9.7.5 op:add-yearMonthDuration-to-dateTime 9.7.6 op:add-dayTimeDuration-to-dateTime 9.7.7 op:subtract-yearMonthDuration-from-dateTime 9.7.8 op:subtract-dayTimeDuration-from-dateTime 9.7.9 op:add-yearMonthDuration-to-date 9.7.10 op:add-dayTimeDuration-to-date 9.7.11 op:subtract-yearMonthDuration-from-date 9.7.12 op:subtract-dayTimeDuration-from-date 9.7.13 op:add-dayTimeDuration-to-time 9.7.14 op:subtract-dayTimeDuration-from-time 9.8 Formatting dates and times 9.8.1 fn:format-dateTime 9.8.2 fn:format-date 9.8.3 fn:format-time 9.8.4 The date/time formattingfunctions 9.8.5 Examples of date and timeformatting 10 Functions related to QNames 10.1 Functions to create a QName 10.1.1 fn:resolve-QName 10.1.2 fn:QName 10.2 Functionsand operators related to QNames 10.2.1 op:QName-equal 10.2.2 fn:prefix-from-QName 10.2.3 fn:local-name-from-QName 10.2.4 fn:namespace-uri-from-QName 10.2.5 fn:namespace-uri-for-prefix 10.2.6 fn:in-scope-prefixes 11 Operators on base64Binary andhexBinary 11.1 Comparisons of base64Binary andhexBinary values 11.1.1 op:hexBinary-equal 11.1.2 op:base64Binary-equal 12 Operators on NOTATION 12.1 op:NOTATION-equal 13 Functions and operators onnodes 13.1 fn:name 13.2 fn:local-name 13.3 fn:namespace-uri 13.4 fn:lang 13.5 op:is-same-node 13.6 op:node-before 13.7 op:node-after 13.8 fn:root 13.9 fn:path 13.10 fn:has-children 13.11 fn:innermost 13.12 fn:outermost 14 Functions and operators onsequences 14.1 Generalfunctions and operators on sequences 14.1.1 op:concatenate 14.1.2 fn:empty 14.1.3 fn:exists 14.1.4 fn:head 14.1.5 fn:tail 14.1.6 fn:insert-before 14.1.7 fn:remove 14.1.8 fn:reverse 14.1.9 fn:subsequence 14.1.10 fn:unordered 14.2 Functions that compare values insequences 14.2.1 fn:distinct-values 14.2.2 fn:index-of 14.2.3 fn:deep-equal 14.3 Functions that test the cardinality ofsequences 14.3.1 fn:zero-or-one 14.3.2 fn:one-or-more 14.3.3 fn:exactly-one 14.4 Union, intersection anddifference 14.4.1 op:union 14.4.2 op:intersect 14.4.3 op:except 14.5 Aggregate functions 14.5.1 fn:count 14.5.2 fn:avg 14.5.3 fn:max 14.5.4 fn:min 14.5.5 fn:sum 14.6 Functions and operators thatgenerate sequences 14.6.1 op:to 14.7 Functions on node identifiers 14.7.1 fn:id 14.7.2 fn:element-with-id 14.7.3 fn:idref 14.7.4 fn:generate-id 14.8 Functionsgiving access to external information 14.8.1 fn:doc 14.8.2 fn:doc-available 14.8.3 fn:collection 14.8.4 fn:uri-collection 14.8.5 fn:unparsed-text 14.8.6 fn:unparsed-text-lines 14.8.7 fn:unparsed-text-available 14.8.8 fn:environment-variable 14.8.9 fn:available-environment-variables 14.9 Parsing and serializing 14.9.1 fn:parse-xml 14.9.2 fn:parse-xml-fragment 14.9.3 fn:serialize 15 Context functions 15.1 fn:position 15.2 fn:last 15.3 fn:current-dateTime 15.4 fn:current-date 15.5 fn:current-time 15.6 fn:implicit-timezone 15.7 fn:default-collation 15.8 fn:static-base-uri 16 Higher-orderfunctions 16.1 Functions on functions 16.1.1 fn:function-lookup 16.1.2 fn:function-name 16.1.3 fn:function-arity 16.2 Basichigher-order functions 16.2.1 fn:for-each 16.2.2 fn:filter 16.2.3 fn:fold-left 16.2.4 fn:fold-right 16.2.5 fn:for-each-pair 17 Constructor functions 17.1 Constructor functions forXML Schema built-in atomic types 17.2 Constructor functions for xs:QNameand xs:NOTATION 17.3 Constructor functionsfor XML Schema built-in list types 17.4 Constructor functionsfor XML Schema built-in union types 17.5 Constructorfunctions for user-defined types 18 Casting 18.1 Casting from primitive typesto primitive types 18.1.1 Casting to xs:string andxs:untypedAtomic 18.1.2 Casting to numeric types 18.1.3 Casting to duration types 18.1.4 Casting to date and time types 18.1.5 Casting to xs:boolean 18.1.6 Casting to xs:base64Binary andxs:hexBinary 18.1.7 Casting to xs:anyURI 18.1.8 Casting to xs:QName andxs:NOTATION 18.1.9 Casting to xs:ENTITY 18.2 Casting from xs:string andxs:untypedAtomic 18.3 Casting involving non-primitivetypes 18.3.1 Casting to derived types 18.3.2 Casting from derived types toparent types 18.3.3 Casting within a branch of the typehierarchy 18.3.4 Casting across the typehierarchy 18.3.5 Casting to union types 18.3.6 Casting to list types Appendices A References A.1 Normativereferences A.2 Non-normative references B Error summary C Illustrative user-written functions(Non-Normative) C.1 eg:if-empty and eg:if-absent C.1.1 eg:if-empty C.1.2 eg:if-absent C.2 Union, intersection anddifference on sequences of values C.2.1 eg:value-union C.2.2 eg:value-intersect C.2.3 eg:value-except C.3 eg:index-of-node C.4 eg:string-pad C.5 eg:distinct-nodes-stable C.6 Findingminima and maxima C.6.1 eg:highest C.6.2 eg:lowest C.7 Sorting D Checklist of implementation-definedfeatures (Non-Normative) E Changes since previous Recommendation(Non-Normative) E.1 Substantive changes (15 December2009) E.2 Substantive changes (18 June2012) E.3 Substantive changes (CandidateRecommendation) E.4 Substantive changes (post CandidateRecommendation) E.5 Editorialchanges E.6 Changessince the Proposed Recommendation F Compatibility with PreviousVersions (Non-Normative) F.1 Compatibility between XPath 2.0 and XPath1.0 F.2 Compatibility between XPath 3.0 and XPath2.0 1 Introduction The purpose of this document is to catalog the functions andoperators required for XPath 3.0, XQuery 3.0 and XSLT 3.0. Theexact syntax used to call these functions and operators isspecified in [XML Path Language (XPath)3.0], [XQuery 3.0: An XML QueryLanguage] and [XSL Transformations (XSLT)Version 3.0]. This document defines constructor functions and functions thattake typed values as arguments. Some of the functions specify thesemantics of operators defined in [XML PathLanguage (XPath) 3.0] and [XQuery 3.0: AnXML Query Language]. [XML Schema Part 2: Datatypes SecondEdition] defines a number of primitive and derived datatypes,collectively known as built-in datatypes. This document definesfunctions and operations on these datatypes as well as thedatatypes defined in Section 2.7 SchemaInformation DM30 of the [XQuery and XPath Data Model (XDM) 3.0].These functions and operations are defined for use in [XML Path Language (XPath) 3.0], [XQuery 3.0: An XML Query Language] and [XSL Transformations (XSLT) Version 3.0] and relatedXML standards. This document also defines functions and operatorson nodes and node sequences as defined in the [XQuery and XPath Data Model (XDM) 3.0]for use in [XML Path Language (XPath) 3.0],[XQuery 3.0: An XML Query Language] and[XSL Transformations (XSLT) Version 3.0] andother related XML standards. [Schema 1.1 Part 2] adds to thedata types defined in [XML Schema Part 2:Datatypes Second Edition]. It introduces a new derived typexs:dateTimeStamp, and it incorporates as built-intypes the two types xs:yearMonthDuration andxs:dayTimeDuration which were previously XDM additionsto the type system. In addition, XSD 1.1 clarifies and updates manyaspects of the definitions of the existing data types: for example,it extends the value space of xs:double to allow bothpositive and negative zero, and extends the lexical space to allow+INF; it modifies the value space ofxs:Name to permit additional Unicode characters; itallows year zero and disallows leap seconds inxs:dateTime values; and it allows any character stringto appear as the value of an xs:anyURI item.Implementations of this specification may supporteither XSD 1.0 or XSD 1.1 or both. References to specific sections of some of the above documentsare indicated by cross-document links in this document. Each suchlink consists of a pointer to a specific section followed asuperscript specifying the linked document. The superscripts havethe following meanings: 'XQ' [XQuery 3.0: AnXML Query Language], 'XT' [XSLTransformations (XSLT) Version 3.0], 'XP' [XML Path Language (XPath) 3.0], and 'DM' [XQuery and XPath Data Model (XDM)3.0]. 1.1 Conformance The Functions and Operators specification is intended primarilyas a component that can be used by other specifications. Therefore,Functions and Operators relies on specifications that use it (suchas [XML Path Language (XPath) 3.0],[XSL Transformations (XSLT) Version 3.0] and[XQuery 3.0: An XML Query Language]) tospecify conformance criteria for their respective environments. Authors of conformance criteria for the use of the Functions andOperators should pay particular attention to the followingfeatures: It is Â·implementation-definedÂ· which version of Unicode is supported, but itis recommended that the most recent version of Unicode be used. It is Â·implementation-definedÂ· whether the type system is based on XML Schema1.0 or XML Schema 1.1. Support for XML 1.0 and XML 1.1 by the datatypes used inFunctions and Operators. Note: The XML Schema 1.1 recommendation introduces one new concretedata type: xs:dateTimeStamp; it also incorporates thetypes xs:dayTimeDuration,xs:yearMonthDuration, andxs:anyAtomicType which were previously defined as partof [XQuery and XPath Data Model (XDM)3.0]. Furthermore, XSD 1.1 includes the option of supportingrevised definitions of types such as xs:NCName basedon the rules in XML 1.1 rather than 1.0. In this document, text labeled as an example or as a Note isprovided for explanatory purposes and is not normative. 1.2Namespaces and prefixes The functions and operators defined in this document arecontained in one of several namespaces (see [Namespaces in XML]) and referenced using anxs:QName. This document uses conventional prefixes to refer to thesenamespaces. User-written applications can choose a different prefixto refer to the namespace, so long as it is bound to the correctURI. The host language may also define a default namespace forfunction calls, in which case function names in that namespace neednot be prefixed at all. In many cases the default namespace will behttp://www.w3.org/2005/xpath-functions, allowing acall on the fn:name function(for example) to be written as name() rather thanfn:name(); in this document,however, all example function calls are explicitly prefixed. The URIs of the namespaces and the conventional prefixesassociated with them are: http://www.w3.org/2001/XMLSchema for constructors â€”associated with xs. The section 17 Constructorfunctions defines constructor functions for the built-indatatypes defined in [XML Schema Part 2:Datatypes Second Edition] and in Section 2.7 SchemaInformation DM30 of [XQuery and XPath Data Model (XDM) 3.0].These datatypes and the corresponding constructor functions are inthe XML Schema namespace,http://www.w3.org/2001/XMLSchema, and are named inthis document using the xs prefix. http://www.w3.org/2005/xpath-functions forfunctions â€” associated with fn. The namespace prefix used in this document for most functionsthat are available to users is fn. http://www.w3.org/2005/xpath-functions/math forfunctions â€” associated with math. This namespace is used for some mathematical functions. Thenamespace prefix used in this document for these functions ismath. These functions are available to users inexactly the same way as those in the fn namespace. http://www.w3.org/2005/xqt-errors â€” associated witherr. There are no functions in this namespace; it is used for errorcodes. This document uses the prefix err to represent thenamespace URI http://www.w3.org/2005/xqt-errors, whichis the namespace for all XPath and XQuery error codes and messages.This namespace prefix is not predeclared and its use in thisdocument is not normative. Note: The namespace URI associated with the err prefix isnot expected to change from one version of this document toanother. The contents of this namespace may be extended to allowadditional errors to be returned. http://www.w3.org/2010/xslt-xquery-serialization â€”associated with output. There are no functions in this namespace: it is used forserialization parameters, as described in [XSLT and XQuery Serialization3.0] Functions defined with the op prefix are describedhere to underpin the definitions of the operators in [XML Path Language (XPath) 3.0], [XQuery 3.0: An XML Query Language] and [XSL Transformations (XSLT) Version 3.0]. Thesefunctions are not available directly to users, and there is norequirement that implementations should actually provide thesefunctions. For this reason, no namespace is associated with theop prefix. For example, multiplication is generallyassociated with the * operator, but it is described asa function in this document: fn:numeric-multiply($arg1 as numeric,$arg2 as numeric) as numeric 1.3Function overloading In general, the specifications named above do not supportfunction overloading in the sense that functions that have multiplesignatures with the same name and the same number of parameters arenot supported. Consequently, there are no such overloaded functionsin this document except for legacy [XML PathLanguage (XPath) Version 1.0] functions such as fn:string, which accepts a singleparameter of a variety of types. In addition, it should be notedthat the functions defined in 4Functions and operators on numerics that acceptnumeric parameters accept arguments of typexs:integer, xs:decimal,xs:float or xs:double. See 1.4 Function signatures anddescriptions. Operators such as "+" may be overloaded. Thisdocument does define some functions with more than one signaturewith the same name and different number of parameters. User-definedfunctions with more than one signature with the same name anddifferent number of parameters are also supported. 1.4 Functionsignatures and descriptions Each function is defined by specifying its signature, adescription of the return type and each of the parameters and itssemantics. For many functions, examples are included to illustratetheir use. Each function's signature is presented in a form like this: fn:function-name($parameter-name as parameter-type,...) as return-type In this notation, function-name, in bold-face, is thename of the function whose signature is being specified. If thefunction takes no parameters, then the name is followed by an emptyparameter list: "()"; otherwise, the name is followedby a parenthesized list of parameter declarations, each declarationspecifies the static type of the parameter, in italics, and adescriptive, but non-normative, name. If there are two or moreparameter declarations, they are separated by a comma. Thereturn-type , also in italics, specifies thestatic type of the value returned by the function. The dynamic typeof the value returned by the function is the same as its statictype or derived from the static type. All parameter types andreturn types are specified using the SequenceType notation definedin Section2.5.4 SequenceType Syntax XP30. One function, fn:concat,has a variable number of arguments (two or more). More strictly,there is an infinite set of functions having the name fn:concat, with arity ranging from2 to infinity. For this special case, a single function signatureis given, with an ellipsis indicating an indefinite number ofarguments. In some cases the word " numeric " is used infunction signatures as a shorthand to indicate the four numerictypes: xs:integer, xs:decimal,xs:float and xs:double. For example, afunction with the signature: fn:numeric-function($arg as numeric) as ... represents the following four function signatures: fn:numeric-function($arg as xs:integer) as ... fn:numeric-function($arg as xs:decimal) as ... fn:numeric-function($arg as xs:float) as ... fn:numeric-function($arg as xs:double) as ... For most functions there is an initial paragraph describing whatthe function does followed by semantic rules. These rules are meantto be followed in the order that they appear in this document. The function name is a QName as defined in [XML Schema Part 2: Datatypes Second Edition]and must adhere to its syntactic conventions. Following theprecedent set by [XML Path Language (XPath)Version 1.0], function names are generally composed of Englishwords separated by hyphens ("-"). If a function name contains a[XML Schema Part 2: Datatypes SecondEdition] datatype name, it may have intercapitalized spellingand is used in the function name as such. For example, fn:timezone-from-dateTime. Rules for passing parameters to operators are described in therelevant sections of [XQuery 3.0: An XML QueryLanguage] and [XML Path Language (XPath)3.0]. For example, the rules for passing parameters toarithmetic operators are described in Section 3.5Arithmetic Expressions XP30.Specifically, rules for parameters of typexs:untypedAtomic and the empty sequence are specifiedin this section. As is customary, the parameter type name indicates that thefunction or operator accepts arguments of that type, or typesderived from it, in that position. This is called subtypesubstitution (See Section2.5.5 SequenceType Matching XP30). Inaddition, numeric type instances and instances of typexs:anyURI can be promoted to produce an argument ofthe required type. (See Section B.1 TypePromotion XP30). Subtype Substitution: A derived type may substitute forits base type. In particular, xs:integer may be usedwhere xs:decimal is expected. Numeric Type Promotion: xs:decimal may bepromoted to xs:float or xs:double.Promotion to xs:double should be done directly, notvia xs:float, to avoid loss of precision. anyURI Type Promotion: A value of typexs:anyURI can be promoted to the typexs:string. Some functions accept a single value or the empty sequence as anargument and some may return a single value or the empty sequence.This is indicated in the function signature by following theparameter or return type name with a question mark:"?", indicating that either a single value or theempty sequence must appear. See below. fn:function-name($parameter-name as parameter-type?) as return-type? Note that this function signature is different from a signaturein which the parameter is omitted. See, for example, the twosignatures for fn:string.In the first signature, the parameter is omitted and the argumentdefaults to the context item, referred to as ".". In the secondsignature, the argument must be present but may be the emptysequence, written as (). Some functions accept a sequence of zero or more values as anargument. This is indicated by following the name of the type ofthe items in the sequence with *. The sequence maycontain zero or more items of the named type. For example, thefunction below accepts a sequence of xs:double andreturns a xs:double or the empty sequence. fn:median($arg as xs:double*) as xs:double? 1.5 Type system The diagrams below show how nodes, function items, primitivesimple types, and user defined types fit together into a typesystem. This type system comprises two distinct hierarchies thatboth include the primitive simple types. In the diagrams,connecting lines represent relationships between derived types andthe types from which they are derived; the arrowheads point towardthe type from which they are derived. The dashed line representsrelationships not present in this diagram, but that appear in oneof the other diagrams. Dotted lines represent additionalrelationships that follow an evident pattern. The information thatappears in each diagram is recapitulated in tabular form. The xs:IDREFS, xs:NMTOKENS, andxs:ENTITIES types and the user-defined list andunion types are special types in that these types are listsor unions rather than types derived by extension orrestriction. The first diagram and its corresponding table illustrate therelationship of various item types. Item types in the data modelform a lattice rather than a hierarchy: in the relationship definedby the derived-from(A, B) function, some types arederived from more than one other type. Examples include functions(function(xs:string) as xs:int is substitutable forfunction(xs:NCName) as xs:int and also forfunction(xs:string) as xs:decimal), and union types(A is substitutable for union(A, B) andalso for union(A, C). In XDM, item types include nodetypes, function types, and built-in atomic types. The diagram,which shows only hierarchic relationships, is therefore asimplification of the full model. In the table, each type whose name is indented is derived fromthe type whose name appears nearest above it with one less level ofindentation. item xs:anyAtomicType function(*) function(item()*) as item()* function(item()*) as item() function(item()*) as item()? function(item()*, item()*) as item()* node attribute user-definedattribute types comment document user-defineddocument types element user-definedelement types namespace processing-instruction text The next diagram and table illustrate the "any type" typehierarchy, in which all types are derived from distinguished typexs:anyType. In the table, each type whose name is indented is derived fromthe type whose name appears nearest above it with one less level ofindentation. xs:anyType user-definedcomplex types xs:untyped xs:anySimpleType user-definedlist and union types xs:IDREFS xs:NMTOKENS xs:ENTITIES xs:anyAtomicType The final diagram and table show all of the atomic types,including the primitive simple types and the built-in types derivedfrom the primitive simple types. This includes all the built-indatatypes defined in [XML Schema Part 2:Datatypes Second Edition] as well as the two totally orderedsubtypes of duration defined in 8.1Two totally ordered subtypes of duration. In the table, each type whose name is indented is derived fromthe type whose name appears nearest above it with one less level ofindentation. xs:untypedAtomic xs:dateTime xs:dateTimeStamp xs:date xs:time xs:duration xs:yearMonthDuration xs:dayTimeDuration xs:float xs:double xs:decimal xs:integer xs:nonPositiveInteger xs:negativeInteger xs:long xs:int xs:short xs:byte xs:nonNegativeInteger xs:unsignedLong xs:unsignedInt xs:unsignedShort xs:unsignedByte xs:positiveInteger xs:gYearMonth xs:gYear xs:gMonthDay xs:gDay xs:gMonth xs:string xs:normalizedString xs:token xs:language xs:NMTOKEN xs:Name xs:NCName xs:ID xs:IDREF xs:ENTITY xs:boolean xs:base64Binary xs:hexBinary xs:anyURI xs:QName xs:NOTATION 1.6 Terminology The terminology used to describe the functions and operators on[XML Schema Part 2: Datatypes SecondEdition] is defined in the body of this specification. Theterms defined in this section are used in building thosedefinitions 1.6.1 Strings, characters, andcodepoints This document uses the terms string,character, and codepoint with thefollowing meanings: [Definition] A character is an instance ofthe CharXMLproduction of [Extensible Markup Language (XML) 1.0(Fifth Edition)]. Note: This definition excludes Unicode characters in the surrogateblocks as well as xFFFE and xFFFF, while including characters withcodepoints greater than xFFFF which some programming languagestreat as two characters. The valid characters are defined by theircodepoints, and include some whose codepoints have not beenassigned by the Unicode consortium to any character. [Definition] A string is a sequence of zero ormore Â·charactersÂ·, or equivalently, a value in the value spaceof the xs:string data type. [Definition] A codepoint is a non-negativeinteger assigned to a Â·characterÂ· by the Unicode consortium, or reserved forfuture assignment to a character. Note: The set of codepoints is thus wider than the set ofcharacters. This specification spells "codepoint" as one word; the Unicodespecification spells it as "code point". Equivalent terms found inother specifications are "character number" or "code position". See[Character Model for the World Wide Web 1.0:Fundamentals] Because these terms appear so frequently, they are hyperlinkedto the definition only when there is a particular desire to drawthe reader's attention to the definition; the absence of ahyperlink does not mean that the term is being used in some othersense. It is Â·implementation-definedÂ· which version of [TheUnicode Standard] is supported, but it is recommended that themost recent version of Unicode be used. Unless explicitly stated, the xs:string valuesreturned by the functions in this document are not normalized inthe sense of [Character Model for the World WideWeb 1.0: Fundamentals]. Notes: In functions that involve character counting such as fn:substring, fn:string-length andfn:translate, what iscounted is the number of XML Â·charactersÂ· in thestring (or equivalently, the number of Unicode codepoints). Someimplementations may represent a codepoint above xFFFF using two16-bit values known as a surrogate pair. A surrogate pair counts asone character, not two. 1.6.2 Namespaces and URIs This document uses the phrase "namespace URI" to identify theconcept identified in [Namespaces in XML]as "namespace name", and the phrase "local name" to identify theconcept identified in [Namespaces in XML]as "local part". It also uses the term "expanded-QName" defined below. [Definition] An expanded-QName is a pairof values consisting of a namespace URI and a local name. Theybelong to the value space of the [XML SchemaPart 2: Datatypes Second Edition] datatypexs:QName. When this document refers toxs:QName we always mean the value space, i.e. anamespace URI, local name pair (and not the lexical space referringto constructs of the form prefix:local-name). The term URI is used as follows: [Definition] Within this specification, the termURI refers to Universal Resource Identifiers as defined in[RFC 3986] and extended in [RFC 3987] with a new name IRI. The termURI Reference, unless otherwise stated, refers to a stringin the lexical space of the xs:anyURI datatype asdefined in [XML Schema Part 2: DatatypesSecond Edition]. Note: Note that this means, in practice, that where this specificationrequires a "URI Reference", an IRI as defined in [RFC 3987] will be accepted, provided that otherrelevant specifications also permit an IRI. The term URI has beenretained in preference to IRI to avoid introducing new names forconcepts such as "Base URI" that are defined or referenced acrossthe whole family of XML specifications. Note also that thedefinition of xs:anyURI is a wider definition than thedefinition in [RFC 3987]; for example itdoes not require non-ASCII characters to be escaped. 1.6.3 Conformance terminology [Definition] forcompatibility A feature of this specification included to ensure thatimplementations that use this feature remain compatible with[XML Path Language (XPath) Version 1.0] [Definition] may Conforming documents and processors are permitted to, but neednot, behave as described. [Definition] must Conforming documents and processors are required to behave asdescribed; otherwise, they are either non-conformant or else inerror. [Definition]implementation-defined Possibly differing between implementations, but specified anddocumented by the implementor for each particularimplementation. [Definition]implementation-dependent Possibly differing between implementations, but not specified bythis or other W3C specification, and not required to be specifiedby the implementor for any particular implementation. 1.6.4 Properties of functions This section is concerned with the question of whether two callson a function, with the same arguments, may produce differentresults. [Definition] Two function calls are said tobe within the same execution scope if the host environmentdefines them as such. In XSLT, any two calls executed during thesame transformation are in the same execution scope. In XQuery, anytwo calls executed during the evaluation of a top-level expressionare in the same execution scope. In other contexts, the executionscope is specified by the host environment that invokes thefunction library. The following definition explains more precisely what it meansfor two function calls to return the same result: [Definition] Two values are defined to beidentical if they contain the same number of items and theitems are pairwise identical. Two items are identical if and onlyif one of the following conditions applies: Both items are atomic values, of precisely the same type, andthe values are equal as defined using the eq operator,using the Unicode codepoint collation when comparing strings Both items are nodes, and represent the same node Both items are function items, and have the same name (orabsence of a name), arity, function signature, and closure. (Notethat there is no function or operator defined in the specificationthat tests whether two function items are identical.) Some functions produce results that depend not only on theirexplicit arguments, but also on the static and dynamic context. [Definition] A function may have theproperty of being context-dependent: the result of such afunction depends on the values of properties in the static anddynamic evaluation context as well as on the actual suppliedarguments (if any). [Definition] A function that is notÂ·context-dependentÂ·is called context-independent. A function that is context-dependent can be used as a namedfunction reference, can be partially applied, and can be foundusing fn:function-lookup. Theprinciple in such cases is that the static context used for thefunction evaluation is taken from the static context of the namedfunction reference, partial function application, or the call onfn:function-lookup; andthe dynamic context for the function evaluation is taken from thedynamic context of the evaluation of the named function reference,partial function application, or the call of fn:function-lookup. Ineffect, the static and dynamic part of the context thus act as partof the closure of the function item. Context-dependent functions fall into a number ofcategories: The functions fn:current-date, fn:current-dateTime,fn:current-time,fn:implicit-timezone,fn:adjust-date-to-timezone,fn:adjust-dateTime-to-timezone,and fn:adjust-time-to-timezonedepend on properties of the dynamic context that are fixed withinthe Â·executionscopeÂ·. The same applies to a numberof functions in the op: namespace that manipulatedates and times and that make use of the implicit timezone. Thesefunctions will return the same result if called repeatedly during asingle Â·executionscopeÂ·. A number of functions including fn:base-uri#0, fn:data#0, fn:document-uri#0, fn:position, fn:last, fn:id#1, fn:idref#1, fn:element-with-id#1,fn:lang#1, fn:local-name#0, fn:name#0, fn:namespace-uri#0, fn:normalize-space#0,fn:number#0, fn:root#0, fn:string#0, fn:string-length#0, andfn:path#0 depend on thefocus. These functions will in general return different results ondifferent calls if the focus is different. [Definition] A function isfocus-dependent if its result depends on the focus (that is,the context item, position, or size). [Definition] A function that is notÂ·focus-dependentÂ· iscalled focus-independent The function fn:default-collation andmany string-handling operators and functions depend on the defaultcollation and the in-scope collations, which are both properties ofthe static context. If a particular call of one of these functionsis evaluated twice with the same arguments then it will return thesame result each time (because the static context, by definition,does not change at run time). However, two distinct calls (that is,two calls on the function appearing in different places in thesource code) may produce different results even if the explicitarguments are the same. Functions such as fn:static-base-uri,fn:doc, and fn:collection depend on otheraspects of the static context. As with functions that depend oncollations, a single call will produce the same results on eachcall if the explicit arguments are the same, but two callsappearing in different places in the source code may producedifferent results. The fn:function-lookupfunction is a special case because it is potentially dependent oneverything in the static and dynamic context. This is because thestatic and dynamic context of the call to fn:function-lookup areused as the static and dynamic context of the function thatfn:function-lookupreturns. [Definition] For a Â·context-dependentÂ·function, the parts of the context on which it depends are referredto as implicit arguments. [Definition] A function that is guaranteedto produce Â·identicalÂ· results from repeated calls within asingle Â·executionscopeÂ· if the explicit andimplicit arguments are identical is referred to asdeterministic. [Definition] A function that is notÂ·deterministicÂ· isreferred to as nondeterministic. All functions defined in this specification are Â·deterministicÂ·unless otherwise stated. Exceptions include the following: Some functions (such as fn:distinct-values andfn:unordered) produceresults in an Â·implementation-definedÂ· or Â·implementation-dependentÂ· order. In such cases there is no guaranteethat the order of results from different calls will be the same.These functions are said to be non-deterministic with respect toordering. The function fn:analyze-stringconstructs an element node to represent its results. There is noguarantee that repeated calls with the same arguments will returnthe same identical node (in the sense of the isoperator). However, if non-identical nodes are returned, theircontent will be the same in the sense of the fn:deep-equal function. Such afunction is said to be non-deterministic with respect to nodeidentity. Some functions (such as fn:doc and fn:collection) create new nodesby reading external documents. Such functions are guaranteed to beÂ·deterministicÂ· withthe exception that an implementation is allowed to make themnon-deterministic as a user option. Where the results of a function are described as being (to agreater or lesser extent) Â·implementation-definedÂ· or Â·implementation-dependentÂ·, this does not by itself remove therequirement that the results should be deterministic: that is, thatrepeated calls with the same explicit and implicit argumentsmust return identical results. 2 Accessors Accessors and their semantics are described in [XQuery and XPath Data Model (XDM) 3.0].Some of these accessors are exposed to the user through thefunctions described below. Function Accessor Accepts Returns fn:node-name node-name an optional node zero or one xs:QName fn:nilled nilled a node an optional xs:boolean fn:string string-value an optional item or no argument xs:string fn:data typed-value zero or more items a sequence of atomic values fn:base-uri base-uri an optional node or no argument zero or one xs:anyURI fn:document-uri document-uri an optional node zero or one xs:anyURI 2.1fn:node-name Summary Returns the name of a node, as an xs:QName. Signatures fn:node-name() as xs:QName? fn:node-name($arg as node()?) as xs:QName? Properties The zero-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The one-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the argument is omitted, it defaults to the context item(.). The behavior of the function if the argument isomitted is exactly the same as if the context item had been passedas the argument. If $arg is the empty sequence, the empty sequenceis returned. Otherwise, the function returns the result of thedm:node-name accessor as defined in [XQuery and XPath Data Model (XDM) 3.0](see Section5.11 node-name Accessor DM30). Error Conditions The following errors may be raised when $arg isomitted: If the context item is absentDM30,dynamic error [err:XPDY0002]XP30 If the context item is not a node, type error[err:XPTY0004]XP30. Notes For element and attribute nodes, the name of the node isreturned as an xs:QName, retaining the prefix,namespace URI, and local part. For processing instructions, the name of the node is returned asan xs:QName in which the prefix and namespace URI areabsentDM30. For a namespace node, the function returns an empty sequence ifthe node represents the default namespace; otherwise it returns anxs:QName in which prefix and namespace URI areabsentDM30and the local part is the namespace prefix being bound). For all other kinds of node, the function returns the emptysequence. 2.2 fn:nilled Summary Returns true for an element that is nilled. Signatures fn:nilled() as xs:boolean fn:nilled($arg as node()?) as xs:boolean? Properties The zero-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The one-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the argument is omitted, it defaults to the context item(.). The behavior of the function if the argument isomitted is exactly the same as if the context item had been passedas the argument. If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise the function returns the result of thedm:nilled accessor as defined in [XQuery and XPath Data Model (XDM) 3.0](see Section 5.9nilled Accessor DM30). Error Conditions The following errors may be raised when $arg isomitted: If the context item is absentDM30,dynamic error [err:XPDY0002]XP30 If the context item is not a node, type error[err:XPTY0004]XP30. Notes If $arg is not an element node, the functionreturns the empty sequence. If $arg is an untyped element node, the functionreturns false. In practice, the function returns true only for anelement node that has the attribute xsi:nil="true" andthat is successfully validated against a schema that defines theelement to be nillable; the detailed rules, however, are defined in[XQuery and XPath Data Model (XDM)3.0]. 2.3 fn:string Summary Returns the value of $arg represented as anxs:string. Signatures fn:string() as xs:string fn:string($arg as item()?) as xs:string Properties The zero-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The one-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules In the zero-argument version of the function, $argdefaults to the context item. That is, callingfn:string() is equivalent to callingfn:string(.). If $arg is the empty sequence, the function returnsthe zero-length string. If $arg is a node, the function returns thestring-value of the node, as obtained using thedm:string-value accessor defined in [XQuery and XPath Data Model (XDM) 3.0](see Section5.13 string-value Accessor DM30). If $arg is an atomic value, the function returnsthe result of the expression $arg cast as xs:string(see 18 Casting). Error Conditions A dynamic error is raised [err:XPDY0002]XP30 bythe zero-argument version of the function if the context item isabsentDM30. A type error is raised [err:FOTY0014] if $arg is afunction item. Examples The expression string(23) returns"23". The expression string(false()) returns"false". The expression string("Paris") returns"Paris". The expression string(abs#1) raises errorFOTY0014. let $para := <para>In a hole in the ground there lived a <term author="Tolkein">hobbit</term>.</para>         The expression string($para) returns "In ahole in the ground there lived a hobbit.". 2.4 fn:data Summary Returns the result of atomizing a sequence, that is, replacingall nodes in the sequence by their typed values. Signatures fn:data() as xs:anyAtomicType* fn:data($arg as item()*) as xs:anyAtomicType* Properties The zero-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The one-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the argument is omitted, it defaults to the context item(.). The behavior of the function if the argument isomitted is exactly the same as if the context item had been passedas the argument. The result of fn:data is the sequence of atomicvalues produced by applying the following rules to each item in$arg: If the item is an atomic value, it is appended to the resultsequence. If the item is a node, the typed value of the node is appendedto the result sequence. The typed value is a sequence of zero ormore atomic values: specifically, the result of thedm:typed-value accessor as defined in [XQuery and XPath Data Model (XDM) 3.0](See Section5.15 typed-value Accessor DM30). Error Conditions A type error is raised [err:FOTY0012] if an item in the sequence$arg is a node that does not have a typed value. A type error is raised [err:FOTY0013] if an item in the sequence$arg is a function item. A dynamic error is raised if $arg isomitted and the context item is absentDM30. Notes The process of applying the fn:data function to asequence is referred to as atomization. In many casesan explicit call on fn:data is not required, becauseatomization is invoked implicitly when a node or sequence of nodesis supplied in a context where an atomic value or sequence ofatomic values is required. Examples The expression data(123) returns123. let $para := <para>In a hole in the ground there lived a <term author="Tolkein">hobbit</term>.</para>            The expression data($para) returnsxs:untypedAtomic("In a hole in the ground there lived ahobbit."). The expression data($para/term/@author) returnsxs:untypedAtomic("Tolkein"). The expression data(abs#1) raises errorFOTY0013. 2.5fn:base-uri Summary Returns the base URI of a node. Signatures fn:base-uri() as xs:anyURI? fn:base-uri($arg as node()?) as xs:anyURI? Properties The zero-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The one-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The zero-argument version of the function returns the base URIof the context node: it is equivalent to callingfn:base-uri(.). The single-argument version of the function behaves asfollows: If $arg is the empty sequence, the functionreturns the empty sequence. Otherwise, the function returns the value of thedm:base-uri accessor applied to the node$arg. This accessor is defined, for each kind of node,in the XDM specification (See Section 5.2base-uri Accessor DM30). Note: As explained in XDM, document, element and processing-instructionnodes have a base-uri property which may be empty. The base-uriproperty for all other node kinds is the empty sequence. Thedm:base-uri accessor returns the base-uri property of a node if itexists and is non-empty; otherwise it returns the result ofapplying the dm:base-uri accessor to its parent, recursively. Ifthe node does not have a parent, or if the recursive ascent up theancestor chain encounters a parentless node whose base-uri propertyis empty, the empty sequence is returned. In the case of namespacenodes, however, the result is always an empty sequence -- it doesnot depend on the base URI of the parent element. See also fn:static-base-uri. Error Conditions The following errors may be raised when $arg isomitted: If the context item is absentDM30,dynamic error [err:XPDY0002]XP30 If the context item is not a node, type error[err:XPTY0004]XP30. 2.6fn:document-uri Summary Returns the URI of a resource where a document can be found, ifavailable. Signatures fn:document-uri() as xs:anyURI? fn:document-uri($arg as node()?) as xs:anyURI? Properties The zero-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The one-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the argument is omitted, it defaults to the context item(.). The behavior of the function if the argument isomitted is exactly the same as if the context item had been passedas the argument. If $arg is the empty sequence, the function returnsthe empty sequence. If $arg is not a document node, the functionreturns the empty sequence. Otherwise, the function returns the value of thedocument-uri accessor applied to $arg, asdefined in [XQuery and XPath DataModel (XDM) 3.0] (See Section6.1.2 Accessors DM30). Error Conditions The following errors may be raised when $arg isomitted: If the context item is absentDM30,dynamic error [err:XPDY0002]XP30 If the context item is not a node, type error[err:XPTY0004]XP30. Notes In the case of a document node $D returned by thefn:doc function, or a documentnode at the root of a tree containing a node returned by thefn:collection function,it will always be true that either fn:document-uri($D)returns the empty sequence, or that the following expression istrue: fn:doc(fn:document-uri($D)) is$D. It is Â·implementation-definedÂ· whether this guarantee also holds for documentnodes obtained by other means, for example a document node passedas the initial context node of a query or transformation. 3 Errors and diagnostics 3.1 Raising errors In this document, as well as in [XQuery3.0: An XML Query Language] and [XML PathLanguage (XPath) 3.0], the phrase "an error is raised" is used.Raising an error is equivalent to calling the fn:error function defined in thissection with the provided error code. The above phrase is normally accompanied by specification of aspecific error, to wit: "an error is raised [error code]".Each error defined in this document is identified by anxs:QName that is in thehttp://www.w3.org/2005/xqt-errors namespace,represented in this document by the err prefix. It isthis xs:QName that is actually passed as an argumentto the fn:error function.Calling this function raises an error. For a more detailedtreatment of error handing, see Section 2.3.3Handling Dynamic Errors XP30. The fn:error function isa general function that may be called as above but may also becalled from [XQuery 3.0: An XML QueryLanguage] or [XML Path Language (XPath)3.0] applications with, for example, an xs:QNameargument. 3.1.1 fn:error Summary Calling the fn:error function raises anapplication-defined error. Signatures fn:error() as none fn:error($code as xs:QName) as none fn:error($code as xs:QName?,$description as xs:string) as none fn:error( $code as xs:QName?, $description as xs:string, $error-object as item()*) as none Properties This function is Â·nondeterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules This function never returns a value. Instead it always raises anerror. The effect of the error is identical to the effect ofdynamic errors raised implicitly, for example when an incorrectargument is supplied to a function. The parameters to the fn:error function supplyinformation that is associated with the error condition and that ismade available to a caller that asks for information about theerror. The error may be caught either by the host language (using atry/catch construct in XSLT or XQuery, for example), or by thecalling application or external processing environment. The way inwhich error information is returned to the external processingenvironment is Â·implementation dependentÂ· If fn:error is called with no arguments, then itsbehavior is the same as the function call:  fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')) If $code is the empty sequence then the effectivevalue is the xs:QName constructed by:  fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000') There are three pieces of information that may be associatedwith an error: The $code is an error code that distinguishes thiserror from others. It is an xs:QName; the namespaceURI conventionally identifies the component, subsystem, orauthority responsible for defining the meaning of the error code,while the local part identifies the specific error condition. Thenamespace URI http://www.w3.org/2005/xqt-errors isused for errors defined in this specification; other namespace URIsmay be used for errors defined by the application. If the external processing environment expects the error code tobe returned as a URI or a string rather than as anxs:QName, then an error code with namespace URINS and local part LP will be returned inthe form NS#LP. The namespace URI part of the errorcode should therefore not include a fragment identifier. The $description is a natural-language descriptionof the error condition. The $error-object is an arbitrary value used toconvey additional information about the error, and may be used inany way the application chooses. Error Conditions This function always raises a dynamic error. Bydefault, it raises [err:FOER0000] Notes The value of the $description parameter may need tobe localized. The type "none" is a special type defined in [XQuery 1.0 and XPath 2.0 Formal Semantics]and is not available to the user. It indicates that the functionnever returns and ensures that it has the correct static type. Any QName may be used as an error code; there are no reservednames or namespaces. The error is always classified as a dynamicerror, even if the error code used is one that is normally used forstatic errors or type errors. Examples The expression fn:error() raises errorFOER0000. (This returns the URIhttp://www.w3.org/2005/xqt-errors#FOER0000 (or thecorresponding xs:QName) to the external processingenvironment, unless the error is caught using a try/catch constructin the host language.). The expressionfn:error(fn:QName('http://www.example.com/HR','myerr:toohighsal'), 'Does not apply because salary is toohigh') raises error myerr:toohighsal. (Thisreturns http://www.example.com/HR#toohighsal and thexs:string "Does not apply because salary is toohigh" (or the corresponding xs:QName) to theexternal processing environment, unless the error is caught using atry/catch construct in the host language.). 3.2 Diagnostictracing 3.2.1 fn:trace Summary Provides an execution trace intended to be used in debuggingqueries. Signature fn:trace($value as item()*,$label as xs:string) as item()* Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns the value of $value,unchanged. In addition, the values of $value, converted to anxs:string, and $labelmay be directed to a trace data set. Thedestination of the trace output is Â·implementation-definedÂ·. The format of the trace output is Â·implementation dependentÂ·. The ordering of output from calls of thefn:trace function is Â·implementation dependentÂ·. Examples Consider a situation in which a user wants to investigate theactual value passed to a function. Assume that in a particularexecution, $v is an xs:decimal with value124.84. Writing fn:trace($v, 'the value of $vis:') will put the strings "124.84" and"the value of $v is:" in the trace data set inimplementation dependent order. 4Functions and operators on numerics This section specifies arithmetic operators on the numericdatatypes defined in [XML Schema Part 2:Datatypes Second Edition]. It uses an approach that permitslightweight implementation whenever possible. 4.1 Numerictypes The operators described in this section are defined on thefollowing numeric types. Each type whose name is indented isderived from the type whose name appears nearest above with oneless level of indentation. xs:decimal xs:integer xs:float xs:double They also apply to types derived by restriction from the abovetypes. Note: This specification uses [IEEE754-2008] arithmetic for xs:float andxs:double values. One consequence of this isthat some operations result in the value NaN (not-anumber), which has the unusual property that it is not equal toitself. Another consequence is that some operations return thevalue negative zero. This differs from [XML Schema Part 2: Datatypes Second Edition]which defines NaN as being equal to itself and definesonly a single zero in the value space. The text accompanyingseveral functions defines behavior for both positive and negativezero inputs and outputs in the interest of alignment with [IEEE 754-2008]. A conformantimplementation must respect these semantics. In consequence, theexpression -0.0e0 (which is actually a unary minusoperator applied to an xs:double value) will alwaysreturn negative zero: see 4.2.8op:numeric-unary-minus. As a concession to implementationsthat rely on implementations of XSD 1.0, however, when casting fromstring to double the lexical form -0may be converted to positive zero, though negativezero is recommended. XML Schema 1.1 introduces support for positive and negative zeroas distinct values, and also uses the [IEEE754-2008] semantics for comparisons involvingNaN. 4.2 Arithmeticoperators on numeric values The following functions define the semantics of arithmeticoperators defined in [XQuery 3.0: An XML QueryLanguage] and [XML Path Language (XPath)3.0] on these numeric types. Operators Meaning op:numeric-add Addition op:numeric-subtract Subtraction op:numeric-multiply Multiplication op:numeric-divide Division op:numeric-integer-divide Integer division op:numeric-mod Modulus op:numeric-unary-plus Unary plus op:numeric-unary-minus Unary minus (negation) The parameters and return types for the above operators are thebasic numeric types: xs:integer,xs:decimal, xs:float andxs:double, and types derived from them. The word "numeric " in function signatures signifies these fourtypes. For simplicity, each operator is defined to operate onoperands of the same type and return the same type. The exceptionsare op:numeric-divide, whichreturns an xs:decimal if called with twoxs:integer operands and op:numeric-integer-dividewhich always returns an xs:integer. If the two operands are not of the same type, subtypesubstitution and numeric type promotion are used toobtain two operands of the same type. Section B.1 TypePromotion XP30 and Section B.2 OperatorMapping XP30 describe the semanticsof these operations in detail. The result type of operations depends on their argumentdatatypes and is defined in the following table: Operator Returns op:operation(xs:integer, xs:integer) xs:integer (except for op:numeric-divide(integer,integer), which returns xs:decimal) op:operation(xs:decimal, xs:decimal) xs:decimal op:operation(xs:float, xs:float) xs:float op:operation(xs:double, xs:double) xs:double op:operation(xs:integer) xs:integer op:operation(xs:decimal) xs:decimal op:operation(xs:float) xs:float op:operation(xs:double) xs:double These rules define any operation on any pair of arithmetictypes. Consider the following example: op:operation(xs:int, xs:double) => op:operation(xs:double, xs:double) For this operation, xs:int must be converted toxs:double. This can be done, since by the rules above:xs:int can be substituted for xs:integer,xs:integer can be substituted forxs:decimal, xs:decimal can be promoted toxs:double. As far as possible, the promotions shouldbe done in a single step. Specifically, when anxs:decimal is promoted to an xs:double,it should not be converted to an xs:float and then toxs:double, as this risks loss of precision. As another example, a user may define height as aderived type of xs:integer with a minimum value of 20and a maximum value of 100. He may then derivefenceHeight using an enumeration to restrict thepermitted set of values to, say, 36, 48 and 60. op:operation(fenceHeight, xs:integer) => op:operation(xs:integer, xs:integer) fenceHeight can be substituted for its base typeheight and height can be substituted forits base type xs:integer. The basic rules for addition, subtraction, and multiplication ofordinary numbers are not set out in this specification; they aretaken as given. In the case of xs:double andxs:float the rules are as defined in [IEEE 754-2008]. The rules for handlingdivision and modulus operations, as well as the rules for handlingspecial values such as infinity and NaN, and exceptionconditions such as overflow and underflow, are described moreexplicitly since they are not necessarily obvious. On overflow and underflow situations during arithmeticoperations conforming implementations Â·mustÂ· behave as follows: For xs:float and xs:double operations,overflow behavior Â·mustÂ· be conformant with [IEEE 754-2008]. This specification allows thefollowing options: Raising a dynamic error [err:FOAR0002] via an overflow trap. Returning INF or -INF. Returning the largest (positive or negative) non-infinitenumber. For xs:float and xs:double operations,underflow behavior Â·mustÂ· be conformant with [IEEE 754-2008]. This specification allows thefollowing options: Raising a dynamic error [err:FOAR0002] via an underflow trap. Returning 0.0E0 or +/- 2**Emin or adenormalized value; where Emin is the smallestpossible xs:float or xs:doubleexponent. For xs:decimal operations, overflow behaviorÂ·mustÂ· raise adynamic error [err:FOAR0002]. On underflow, 0.0must be returned. For xs:integer operations, implementations thatsupport limited-precision integer operations Â·mustÂ· select from the following options: They Â·mayÂ· choose toalways raise a dynamic error [err:FOAR0002]. They Â·mayÂ· provide anÂ·implementation-definedÂ· mechanism that allows users to choose betweenraising an error and returning a result that is modulo the largestrepresentable integer value. See [ISO10967]. The functions op:numeric-add, op:numeric-subtract,op:numeric-multiply,op:numeric-divide,op:numeric-integer-divideand op:numeric-mod areeach defined for pairs of numeric operands, each of which has thesame type:xs:integer, xs:decimal,xs:float, or xs:double. The functionsop:numeric-unary-plusand op:numeric-unary-minusare defined for a single operand whose type is one of those samenumeric types. For xs:float and xs:double arguments,if either argument is NaN, the result isNaN. For xs:decimal values the number of digits ofprecision returned by the numeric operators is Â·implementation-definedÂ·. If the number of digits in the result exceedsthe number of digits that the implementation supports, the resultis truncated or rounded in an Â·implementation-definedÂ· manner. The [IEEE 754-2008] specificationalso describes handling of two exception conditions calleddivideByZero and invalidOperation. TheIEEE divideByZero exception is raised not only by adirect attempt to divide by zero, but also by operations such aslog(0). The IEEE invalidOperationexception is raised by attempts to call a function with an argumentthat is outside the function's domain (for example,sqrt(-1) or log(-1). These IEEEexceptions do not cause a dynamic error at the application level;rather they result in the relevant function or operator returningNaN. The underlying IEEE exceptionmay be notified to the application or to the userby some Â·implementation-definedÂ· warning condition, but the observable effecton an application using the functions and operators defined in thisspecification is simply to return NaN with noerror. The [IEEE 754-2008] specificationdistinguishes two NaN values, a quiet NaN and a signaling NaN.These two values are not distinguishable in the XDM model: thevalue spaces of xs:float and xs:doubleeach include only a single NaN value. This does notprevent the implementation distinguishing them internally, andtriggering different Â·implementation-definedÂ· warning conditions, but such distinctions donot affect the observable behavior of an application using thefunctions and operators defined in this specification. 4.2.1op:numeric-add Summary Returns the arithmetic sum of its operands: ($arg1 +$arg2). Operator Mapping Defines the semantics of the "+" operator when applied to twonumeric values Signature op:numeric-add($arg1 as numeric,$arg2 as numeric) as numeric Rules General rules: see 4.2 Arithmeticoperators on numeric values. Notes For xs:float or xs:double values, ifone of the operands is a zero or a finite number and the other isINF or -INF, INF or-INF is returned. If both operands areINF, INF is returned. If both operandsare -INF, -INF is returned. If one of theoperands is INF and the other is -INF,NaN is returned. 4.2.2 op:numeric-subtract Summary Returns the arithmetic difference of its operands: ($arg1- $arg2). Operator Mapping Defines the semantics of the "-" operator when applied to twonumeric values. Signature op:numeric-subtract($arg1 as numeric,$arg2 as numeric) as numeric Rules General rules: see 4.2 Arithmeticoperators on numeric values. Notes For xs:float or xs:double values, ifone of the operands is a zero or a finite number and the other isINF or -INF, an infinity of theappropriate sign is returned. If both operands are INFor -INF, NaN is returned. If one of theoperands is INF and the other is -INF, aninfinity of the appropriate sign is returned. 4.2.3 op:numeric-multiply Summary Returns the arithmetic product of its operands: ($arg1 *$arg2). Operator Mapping Defines the semantics of the "*" operator when applied to twonumeric values. Signature op:numeric-multiply($arg1 as numeric,$arg2 as numeric) as numeric Rules General rules: see 4.2 Arithmeticoperators on numeric values. Notes For xs:float or xs:double values, ifone of the operands is a zero and the other is an infinity,NaN is returned. If one of the operands is a non-zeronumber and the other is an infinity, an infinity with theappropriate sign is returned. 4.2.4 op:numeric-divide Summary Returns the arithmetic quotient of its operands: ($arg1div $arg2). Operator Mapping Defines the semantics of the "div" operator when applied to twonumeric values. Signature op:numeric-divide($arg1 as numeric,$arg2 as numeric) as numeric Rules General rules: see 4.2 Arithmeticoperators on numeric values. As a special case, if the types of both $arg1 and$arg2 are xs:integer, then the returntype is xs:decimal. Error Conditions A dynamic error is raised [err:FOAR0001] for xs:decimaland xs:integer operands, if the divisor is (positiveor negative) zero. Notes For xs:float and xs:double operands,floating point division is performed as specified in [IEEE 754-2008]. A positive number divided bypositive zero returns INF. A negative number dividedby positive zero returns -INF. Division by negativezero returns -INF and INF, respectively.Positive or negative zero divided by positive or negative zeroreturns NaN. Also, INF or-INF divided by INF or -INFreturns NaN. 4.2.5op:numeric-integer-divide Summary Performs an integer division. Operator Mapping Defines the semantics of the "idiv" operator when applied to twonumeric values. Signature op:numeric-integer-divide($arg1 as numeric,$arg2 as numeric) as xs:integer Rules General rules: see 4.2 Arithmeticoperators on numeric values. If $arg2 is INF or -INF,and $arg1 is not INF or-INF, then the result is zero. Otherwise, subject to limits of precision and overflow/underflowconditions, the result is the largest (furthest from zero)xs:integer value $N such that fn:abs($N * $arg2) le fn:abs($arg1) andfn:compare($N * $arg2, 0) eq fn:compare($arg1, 0). Note: The second term in this condition ensures that the result hasthe correct sign. The implementation may adopt a different algorithm provided thatit is equivalent to this formulation in all cases where Â·implementation-dependentÂ· or Â·implementation-definedÂ· behavior does not affect the outcome, forexample, the implementation-defined precision of the result ofxs:decimal division. Error Conditions A dynamic error is raised [err:FOAR0001] if the divisor is (positiveor negative) zero. A dynamic error is raised [err:FOAR0002] if either operand isNaN or if $arg1 is INF or-INF. Notes Except in situations involving errors, loss of precision, oroverflow/underflow, the result of $a idiv $b is thesame as ($a div $b) cast as xs:integer. The semantics of this function are different from integerdivision as defined in programming languages such as Java andC++. Examples The expression op:numeric-integer-divide(10,3)returns 3. The expression op:numeric-integer-divide(3,-2)returns -1. The expression op:numeric-integer-divide(-3,2)returns -1. The expression op:numeric-integer-divide(-3,-2)returns 1. The expression op:numeric-integer-divide(9.0,3)returns 3. The expression op:numeric-integer-divide(-3.5,3)returns -1. The expression op:numeric-integer-divide(3.0,4)returns 0. The expression op:numeric-integer-divide(3.1E1,6)returns 5. The expression op:numeric-integer-divide(3.1E1,7)returns 4. 4.2.6op:numeric-mod Summary Returns the remainder resulting from dividing$arg1, the dividend, by $arg2, thedivisor. Operator Mapping Defines the semantics of the "mod" operator when applied to twonumeric values. Signature op:numeric-mod($arg1 as numeric,$arg2 as numeric) as numeric Rules General rules: see 4.2 Arithmeticoperators on numeric values. The operation a mod b for operands that arexs:integer or xs:decimal, or typesderived from them, produces a result such that (a idivb)*b+(a mod b) is equal to a and the magnitudeof the result is always less than the magnitude of b.This identity holds even in the special case that the dividend isthe negative integer of largest possible magnitude for its type andthe divisor is -1 (the remainder is 0). It follows from this rulethat the sign of the result is the sign of the dividend. For xs:float and xs:double operandsthe following rules apply: If either operand is NaN, the result isNaN. If the dividend is positive or negative infinity, or the divisoris positive or negative zero (0), or both, the result isNaN. If the dividend is finite and the divisor is an infinity, theresult equals the dividend. If the dividend is positive or negative zero and the divisor isfinite, the result is the same as the dividend. In the remaining cases, where neither positive or negativeinfinity, nor positive or negative zero, nor NaN isinvolved, the result obeys (a idiv b)*b+(a mod b) =a. Division is truncating division, analogous tointeger division, not [IEEE 754-2008]rounding division i.e. additional digits are truncated, not roundedto the required precision. Error Conditions A dynamic error is raised [err:FOAR0001] for xs:integerand xs:decimal operands, if $arg2 iszero. Examples The expression op:numeric-mod(10,3) returns1. The expression op:numeric-mod(6,-2) returns0. The expression op:numeric-mod(4.5,1.2) returns0.9. The expression op:numeric-mod(1.23E2, 0.6E1)returns 3.0E0. 4.2.7 op:numeric-unary-plus Summary Returns its operand with the sign unchanged: (+$arg). Operator Mapping Defines the semantics of the unary "+" operator applied to anumeric value. Signature op:numeric-unary-plus($arg as numeric) as numeric Rules General rules: see 4.2 Arithmeticoperators on numeric values. The returned value is equal to $arg, and is aninstance of xs:integer, xs:decimal,xs:double, or xs:float depending on thetype of $arg. Notes Because function conversion rules are applied in the normal way,the unary + operator can be used to force conversionof an untyped node to a number: the result of +@priceis the same as xs:double(@price) if the type of@price is xs:untypedAtomic. 4.2.8 op:numeric-unary-minus Summary Returns its operand with the sign reversed: (-$arg). Operator Mapping Defines the semantics of the unary "-" operator when applied toa numeric value. Signature op:numeric-unary-minus($arg as numeric) as numeric Rules General rules: see 4.2 Arithmeticoperators on numeric values. The returned value is an instance of xs:integer,xs:decimal, xs:double, orxs:float depending on the type of$arg. For xs:integer and xs:decimalarguments, 0 and 0.0 return0 and 0.0, respectively. Forxs:float and xs:double arguments,NaN returns NaN, 0.0E0returns -0.0E0 and vice versa. INFreturns -INF. -INF returnsINF. 4.3 Comparisonoperators on numeric values This specification defines the following comparison operators onnumeric values. Comparisons take two arguments of the same type. Ifthe arguments are of different types, one argument is promoted tothe type of the other as described above in 4.2 Arithmetic operators on numericvalues. Each comparison operator returns a boolean value.If either, or both, operands are NaN,false is returned. Function Meaning op:numeric-equal Returns true if and only if the value of $arg1 isequal to the value of $arg2. op:numeric-less-than Returns true if and only if $arg1 isnumerically less than $arg2. op:numeric-greater-than Returns true if and only if $arg1 isnumerically greater than $arg2. 4.3.1op:numeric-equal Summary Returns true if and only if the value of $arg1 isequal to the value of $arg2. Operator Mapping Defines the semantics of the "eq" operator when applied to twonumeric values, and is also used in defining the semantics of "ne","le" and "ge". Signature op:numeric-equal($arg1 as numeric,$arg2 as numeric) as xs:boolean Rules General rules: see 4.2 Arithmeticoperators on numeric values and 4.3 Comparison operators on numericvalues. For xs:float and xs:double values,positive zero and negative zero compare equal. INFequals INF, and -INF equals-INF. NaN does not equal itself. 4.3.2 op:numeric-less-than Summary Returns true if and only if $arg1 isnumerically less than $arg2. Operator Mapping Defines the semantics of the "lt" operator when applied to twonumeric values, and is also used in defining the semantics of"le". Signature op:numeric-less-than($arg1 as numeric,$arg2 as numeric) as xs:boolean Rules General rules: see 4.2 Arithmeticoperators on numeric values and 4.3 Comparison operators on numericvalues. For xs:float and xs:double values,positive infinity is greater than all other non-NaNvalues; negative infinity is less than all othernon-NaN values. If $arg1 or$arg2 is NaN, the function returnsfalse. 4.3.3 op:numeric-greater-than Summary Returns true if and only if $arg1 isnumerically greater than $arg2. Operator Mapping Defines the semantics of the "gt" operator when applied to twonumeric values, and is also used in defining the semantics of"ge". Signature op:numeric-greater-than($arg1 as numeric,$arg2 as numeric) as xs:boolean Rules The function call op:numeric-greater-than($A, $B)is defined to return the same result as op:numeric-less-than($B,$A) 4.4 Functions on numeric values The following functions are defined on numeric types. Eachfunction returns a value of the same type as the type of itsargument. If the argument is the empty sequence, the empty sequence isreturned. For xs:float and xs:double arguments,if the argument is "NaN", "NaN" is returned. Except for fn:abs, forxs:float and xs:double arguments, if theargument is positive or negative infinity, positive or negativeinfinity is returned. Function Meaning fn:abs Returns the absolute value of $arg. fn:ceiling Rounds $arg upwards to a whole number. fn:floor Rounds $arg downwards to a whole number. fn:round Rounds a value to a specified number of decimal places,rounding upwards if two such values are equally near. fn:round-half-to-even Rounds a value to a specified number of decimal places,rounding to make the last digit even if two such values are equallynear. Note: fn:round and fn:round-half-to-evenproduce the same result in all cases except when the argument isexactly midway between two values with the required precision. Other ways of rounding midway values can be achieved asfollows: Towards negative infinity: -fn:round(-$x) Away from zero: fn:round(fn:abs($x))*fn:compare($x,0) Towards zero: fn:abs(fn:round(-$x))*-fn:compare($x,0) 4.4.1 fn:abs Summary Returns the absolute value of $arg. Signature fn:abs($arg as numeric?) as numeric? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules General rules: see 4.4Functions on numeric values. If $arg is negative the function returns-$arg, otherwise it returns $arg. If the type of $arg is one of the four numerictypes xs:float, xs:double,xs:decimal or xs:integer the type of theresult is the same as the type of $arg. If the type of$arg is a type derived from one of the numeric types,the result is an instance of the base numeric type. For xs:float and xs:double arguments,if the argument is positive zero or negative zero, then positivezero is returned. If the argument is positive or negative infinity,positive infinity is returned. Examples The expression fn:abs(10.5) returns10.5. The expression fn:abs(-10.5) returns10.5. 4.4.2fn:ceiling Summary Rounds $arg upwards to a whole number. Signature fn:ceiling($arg as numeric?) as numeric? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules General rules: see 4.4Functions on numeric values. The function returns the smallest (closest to negative infinity)number with no fractional part that is not less than the value of$arg. If the type of $arg is one of the four numerictypes xs:float, xs:double,xs:decimal or xs:integer the type of theresult is the same as the type of $arg. If the type of$arg is a type derived from one of the numeric types,the result is an instance of the base numeric type. For xs:float and xs:double arguments,if the argument is positive zero, then positive zero is returned.If the argument is negative zero, then negative zero is returned.If the argument is less than zero and greater than -1, negativezero is returned. Examples The expression fn:ceiling(10.5) returns11. The expression fn:ceiling(-10.5) returns-10. 4.4.3 fn:floor Summary Rounds $arg downwards to a whole number. Signature fn:floor($arg as numeric?) as numeric? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules General rules: see 4.4Functions on numeric values. The function returns the largest (closest to positive infinity)number with no fractional part that is not greater than the valueof $arg. If the type of $arg is one of the four numerictypes xs:float, xs:double,xs:decimal or xs:integer the type of theresult is the same as the type of $arg. If the type of$arg is a type derived from one of the numeric types,the result is an instance of the base numeric type. For xs:float and xs:double arguments,if the argument is positive zero, then positive zero is returned.If the argument is negative zero, then negative zero isreturned. Examples The expression fn:floor(10.5) returns10. The expression fn:floor(-10.5) returns-11. 4.4.4 fn:round Summary Rounds a value to a specified number of decimal places, roundingupwards if two such values are equally near. Signatures fn:round($arg as numeric?) as numeric? fn:round($arg as numeric?, $precision as xs:integer) as numeric? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules General rules: see 4.4Functions on numeric values. The function returns the nearest (that is, numerically closest)value to $arg that is a multiple of ten to the powerof minus $precision. If two such values are equallynear (for example, if the fractional part in $arg isexactly .5), the function returns the one that is closest topositive infinity. If the type of $arg is one of the four numerictypes xs:float, xs:double,xs:decimal or xs:integer the type of theresult is the same as the type of $arg. If the type of$arg is a type derived from one of the numeric types,the result is an instance of the base numeric type. The single-argument version of this function produces the sameresult as the two-argument version with $precision=0(that is, it rounds to a whole number). When $arg is of type xs:float andxs:double: If $arg is NaN, positive or negative zero, orpositive or negative infinity, then the result is the same as theargument. For other values, the argument is cast toxs:decimal using an implementation ofxs:decimal that imposes no limits on the number ofdigits that can be represented. The function is applied to thisxs:decimal value, and the resultingxs:decimal is cast back to xs:float orxs:double as appropriate to form the function result.If the resulting xs:decimal value is zero, thenpositive or negative zero is returned according to the sign of$arg. Notes This function is typically used with a non-zero$precision in financial applications where theargument is of type xs:decimal. For arguments of typexs:float and xs:double the results may becounter-intuitive. For example, consider round(35.425e0,2). The result is not 35.43, as might be expected, but35.42. This is because the xs:double written as35.425e0 has an exact value equal to 35.42499999999..., which iscloser to 35.42 than to 35.43. Examples The expression fn:round(2.5) returns3.0. The expression fn:round(2.4999) returns2.0. The expression fn:round(-2.5) returns-2.0. (Not the possible alternative,-3). The expression fn:round(1.125, 2) returns1.13. The expression fn:round(8452, -2) returns8500. The expression fn:round(3.1415e0, 2) returns3.14e0. 4.4.5 fn:round-half-to-even Summary Rounds a value to a specified number of decimal places, roundingto make the last digit even if two such values are equallynear. Signatures fn:round-half-to-even($arg as numeric?) as numeric? fn:round-half-to-even($arg as numeric?, $precision as xs:integer) as numeric? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules General rules: see 4.4Functions on numeric values. The function returns the nearest (that is, numerically closest)value to $arg that is a multiple of ten to the powerof minus $precision. If two such values are equallynear (e.g. if the fractional part in $arg is exactly.500...), the function returns the one whose least significantdigit is even. If the type of $arg is one of the four numerictypes xs:float, xs:double,xs:decimal or xs:integer the type of theresult is the same as the type of $arg. If the type of$arg is a type derived from one of the numeric types,the result is an instance of the base numeric type. The first signature of this function produces the same result asthe second signature with $precision=0. For arguments of type xs:float andxs:double: If the argument is NaN, positive or negative zero,or positive or negative infinity, then the result is the same asthe argument. In all other cases, the argument is cast toxs:decimal using an implementation of xs:decimalthat imposes no limits on the number of digits that can berepresented. The function is applied to thisxs:decimal value, and the resultingxs:decimal is cast back to xs:float orxs:double as appropriate to form the function result.If the resulting xs:decimal value is zero, thenpositive or negative zero is returned according to the sign of theoriginal argument. Notes This function is typically used in financial applications wherethe argument is of type xs:decimal. For arguments oftype xs:float and xs:double the resultsmay be counter-intuitive. For example, considerround-half-to-even(xs:float(150.015), 2). The resultis not 150.02 as might be expected, but 150.01. This is because theconversion of the xs:float value represented by theliteral 150.015 to an xs:decimal produces thexs:decimal value 150.014999389..., which is closer to150.01 than to 150.02. Examples The expression fn:round-half-to-even(0.5) returns0.0. The expression fn:round-half-to-even(1.5) returns2.0. The expression fn:round-half-to-even(2.5) returns2.0. The expression fn:round-half-to-even(3.567812e+3,2) returns 3567.81e0. The expression fn:round-half-to-even(4.7564e-3, 2)returns 0.0e0. The expression fn:round-half-to-even(35612.25, -2)returns 35600. 4.5 Parsingnumbers It is possible to convert strings to values of typexs:integer, xs:float,xs:decimal, or xs:double using theconstructor functions described in 17 Constructor functions orusing cast expressions as described in 18 Casting. In addition the fn:number function is available toconvert strings to values of type xs:double. Itdiffers from the xs:double constructor function inthat any value outside the lexical space of thexs:double datatype is converted to thexs:double value NaN. 4.5.1 fn:number Summary Returns the value indicated by $arg or, if$arg is not specified, the context item afteratomization, converted to an xs:double. Signatures fn:number() as xs:double fn:number($arg as xs:anyAtomicType?) as xs:double Properties The zero-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The one-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules Calling the zero-argument version of the function is defined togive the same result as calling the single-argument version withthe context item (.). That is,fn:number() is equivalent tofn:number(.), as defined by the rules that follow. If $arg is the empty sequence or if$arg cannot be converted to an xs:double,the xs:double value NaN is returned. Otherwise, $arg is converted to anxs:double following the rules of 18.1.2.2 Casting to xs:double. Ifthe conversion to xs:double fails, thexs:double value NaN is returned. Error Conditions A dynamic error is raised [err:XPDY0002]XP30 if$arg is omitted and the context item is absentDM30. As a consequence of the rules given above, a type error occursif the context item cannot be atomized, or if the result ofatomizing the context item is a sequence containing more than oneatomic value. Notes XSD 1.1 allows the string +INF as a representationof positive infinity; XSD 1.0 does not. It is Â·implementation-definedÂ· whether XSD 1.1 is supported. Generally fn:number returns NaN ratherthan raising a dynamic error if the argument cannot be converted toxs:double. However, a type error is raised in theusual way if the supplied argument cannot be atomized or if theresult of atomization does not match the required argumenttype. Examples The expression fn:number($item1/quantity) returns5.0e0. The expression fn:number($item2/description)returns xs:double('NaN'). Assume that the context item is the xs:string value"15". Then fn:number() returns1.5e1. 4.6Formatting integers 4.6.1 fn:format-integer Summary Formats an integer according to a given picture string, usingthe conventions of a given natural language if specified. Signatures fn:format-integer($value as xs:integer?,$picture as xs:string) as xs:string fn:format-integer( $value as xs:integer?, $picture as xs:string, $lang as xs:string?) as xs:string Properties The two-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on default language. The three-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $value is an empty sequence, the functionreturns a zero-length string. In all other cases, the $picture argument describesthe format in which $value is output. The rules that follow describe how non-negative numbers areoutput. If the value of $value is negative, the rulesbelow are applied to the absolute value of $value, anda minus sign is prepended to the result. The value of $picture consists of a primary formattoken, optionally followed by a format modifier. The primary formattoken is always present and must not bezero-length. If the string contains one or more semicolons theneverything that precedes the last semicolon is taken as the primaryformat token and everything that follows is taken as the formatmodifier; if the string contains no semicolon then the entirepicture is taken as the primary format token, and the formatmodifier is taken to be absent (which is equivalent to supplying azero-length string). The primary format token is classified as one of thefollowing: A decimal-digit-pattern made up ofoptional-digit-signs, mandatory-digit-signs,and grouping-separator-signs. The optional-digit-sign is the character "#". A mandatory-digit-sign is a Â·characterÂ· inUnicode category Nd. All mandatory-digit-signs withinthe format token must be from the same digitfamily, where a digit family is a sequence of ten consecutivecharacters in Unicode category Nd, having digit values 0 through 9.Within the format token, these digits are interchangeable: athree-digit number may thus be indicated equivalently by000, 001, or 999. a grouping-separator-sign is a non-alphanumericcharacter, that is a Â·characterÂ· whose Unicode category is other than Nd, Nl,No, Lu, Ll, Lt, Lm or Lo. If the primary format token contains at least one Unicode digitthen it is taken as a decimal digit pattern, and in this case itmust match the regular expression^((\p{Nd}|#|[^\p{N}\p{L}])+?)$. If it contains a digitbut does not match this pattern, a dynamic error israised [err:FODF1310]. Note: If a semicolon is to be used as a grouping separator, then theprimary format token as a whole must be followed by anothersemicolon, to ensure that the grouping separator is not mistaken asa separator between the primary format token and the formatmodifier. There must be at least onemandatory-digit-sign. There may be zero or moreoptional-digit-signs, and (if present) thesemust precede all mandatory-digit-signs.There may be zero or more grouping-separator-signs. Agrouping-separator-sign must not appearat the start or end of the decimal-digit-pattern, noradjacent to another grouping-separator-sign. The corresponding output format is a decimal number, using thisdigit family, with at least as many digits as there aremandatory-digit-signs in the format token. Thus, aformat token 1 generates the sequence 0 1 2 ...10 11 12 ..., and a format token 01 (orequivalently, 00 or 99) generates thesequence 00 01 02 ... 09 10 11 12 ... 99 100 101. Aformat token of &#x661; (Arabic-Indic digit one)generates the sequence Ù¡ then Ù¢ thenÙ£ ... The grouping-separator-signs are handled as follows.The position of grouping separators within the format token,counting backwards from the last digit, indicates the position ofgrouping separators to appear within the formatted number, and thecharacter used as the grouping-separator-sign within theformat token indicates the character to be used as thecorresponding grouping separator in the formatted number. Ifgrouping-separator-signs appear at regular intervalswithin the format token, that is if the same grouping separatorappears at positions forming a sequence N,2N, 3N, ... for some integer valueN (including the case where there is only one number inthe list), then the sequence is extrapolated to the left, sogrouping separators will be used in the formatted number at everymultiple of N. For example, if the format token is0'000 then the number one million will be formatted as1'000'000, while the number fifteen will be formattedas 0'015. The only purpose of optional-digit-signs is to markthe position of grouping-separator-signs. For example,if the format token is #'##0 then the number onemillion will be formatted as 1'000'000, while thenumber fifteen will be formatted as 15. A groupingseparator is included in the formatted number only if there is adigit to its left, which will only be the case if either (a) thenumber is large enough to require that digit, or (b) the number ofmandatory-digit-signs in the format token requiresinsignificant leading zeros to be present. Note: Numbers will never be truncated. Given thedecimal-digit-pattern 01, the number threehundred will be output as 300, despite the absence ofany optional-digit-sign. The format token A, which generates the sequenceA B C ... Z AA AB AC.... The format token a, which generates the sequencea b c ... z aa ab ac.... The format token i, which generates the sequencei ii iii iv v vi vii viii ix x .... The format token I, which generates the sequenceI II III IV V VI VII VIII IX X .... The format token w, which generates numbers writtenas lower-case words, for example in English, one two threefour ... The format token W, which generates numbers writtenas upper-case words, for example in English, ONE TWO THREEFOUR ... The format token Ww, which generates numberswritten as title-case words, for example in English, One TwoThree Four ... Any other format token, which indicates a numbering sequence inwhich that token represents the number 1 (one) (but see the notebelow). It is Â·implementation-definedÂ· which numbering sequences, additional to thoselisted above, are supported. If an implementation does not supporta numbering sequence represented by the given token, itmust use a format token of 1. Note: In some traditional numbering sequences additional signs areadded to denote that the letters should be interpreted as numbers;these are not included in the format token. An example (see alsothe example below) is classical Greek where a dexia keraia(x0374, Í´) and sometimes an aristeri keraia (x0375, Íµ) isadded. For all format tokens other than the first kind above (one thatconsists of decimal digits), there may beÂ·implementation-definedÂ· lower and upper bounds on the range of numbersthat can be formatted using this format token; indeed, for somenumbering sequences there may be intrinsic limits. For example, theformat token &#x2460; (circled digit one, â‘ ) has arange imposed by the Unicode character repertoire â€” 1 to 20in Unicode versions prior to 4.0, increased in subsequentversions. For the numbering sequences described above anyupper bound imposed by the implementation must notbe less than 1000 (one thousand) and any lower bound must not begreater than 1. Numbers that fall outside this rangemust be formatted using the format token1. The above expansions of numbering sequences for format tokenssuch as a and i are indicative but notprescriptive. There are various conventions in use for howalphabetic sequences continue when the alphabet is exhausted, anddiffering conventions for how roman numerals are written (forexample, IV versus IIII as therepresentation of the number 4). Sometimes alphabetic sequences areused that omit letters such as i and o.This specification does not prescribe the detail of any sequenceother than those sequences consisting entirely of decimaldigits. Many numbering sequences are language-sensitive. This appliesespecially to the sequence selected by the tokens w,W and Ww. It also applies to othersequences, for example different languages using the Cyrillicalphabet use different sequences of characters, each starting withthe letter #x410 (Cyrillic capital letter A). In such cases, the$lang argument specifies which language's conventionsare to be used. If the argument is specified, the valueshould be either an empty sequence or a value thatwould be valid for the xml:lang attribute (see[Extensible Markup Language (XML) 1.0 (FifthEdition)]). Note that this permits the identification ofsublanguages based on country codes (from ISO 3166-1) as well asidentification of dialects and regions within acountry.. The set of languages for which numbering is supported isÂ·implementation-definedÂ·. If the $lang argument is absent,or is set to an empty sequence, or is invalid, or is not a languagesupported by the implementation, then the number is formatted usingthe default language from the dynamic context. The format modifier must be a string thatmatches the regular expression^([co](\(.+\))?)?[at]?$. That is, if it ispresent it must consist of one or more of thefollowing, in order: either c or o, optionally followed bya sequence of characters enclosed between parentheses, to indicatecardinal or ordinal numbering respectively, the default beingcardinal numbering either a or t, to indicate alphabeticor traditional numbering respectively, the default being Â·implementation-definedÂ·. If the o modifier is present, this indicates arequest to output ordinal numbers rather than cardinal numbers. Forexample, in English, when used with the format token1, this outputs the sequence 1st 2nd 3rd 4th..., and when used with the format token woutputs the sequence first second third fourth.... The string of characters between the parentheses, if present, isused to select between other possible variations of cardinal orordinal numbering sequences. The interpretation of this string isÂ·implementation-definedÂ·. No error occurs if the implementation doesnot define any interpretation for the defined string. For example, in some languages, ordinal numbers vary dependingon the grammatical context: they may have different genders and maydecline with the noun that they qualify. In such cases the stringappearing in parentheses after the letter o may beused to indicate the variation of the ordinal number required. Theway in which the variation is indicated will depend on theconventions of the language. For inflected languages that vary theending of the word, the recommended approach is toindicate the required ending, preceded by a hyphen: for example inGerman, appropriate values are o(-e),o(-er), o(-es), o(-en). It is Â·implementation-definedÂ· what combinations of values of the formattoken, the language, and the cardinal/ordinal modifier aresupported. If ordinal numbering is not supported for thecombination of the format token, the language, and the stringappearing in parentheses, the request is ignored and cardinalnumbers are generated instead. Example: Ordinal Numbering in Italian The specification "1;o(-Âº)" with $langequal to it, if supported, should produce thesequence: 1Âº 2Âº 3Âº 4Âº ... The specification "Ww;o" with $langequal to it, if supported, should produce thesequence: Primo Secondo Terzo Quarto Quinto ... The use of the a or tmodifier disambiguates between numbering sequences that useletters. In many languages there are two commonly used numberingsequences that use letters. One numbering sequence assigns numericvalues to letters in alphabetic sequence, and the other assignsnumeric values to each letter in some other manner traditional inthat language. In English, these would correspond to the numberingsequences specified by the format tokens a andi. In some languages, the first member of eachsequence is the same, and so the format token alone would beambiguous. In the absence of the a ort modifier, the default is Â·implementation-definedÂ·. Error Conditions A dynamic error is raised [err:FODF1310] if the format token isinvalid, that is, if it violates any mandatory rules (indicated byan emphasized must or requiredkeyword in the above rules). For example, the error is raised ifthe primary format token contains a digit but does not match therequired regular expression. Notes Note the careful distinction between conditions that are errorsand conditions where fallback occurs. The principle is that anerror in the syntax of the format picture will be reported by allprocessors, while a construct that is recognized by someimplementations but not others will never result in an error, butwill instead cause a fallback representation of the integer to beused. Examples The expression format-integer(123, '0000') returns"0123". format-integer(123, 'w') might return "onehundred and twenty-three" The expression format-integer(21, '1;o', 'en')returns "21st". format-integer(14, 'Ww;o(-e)', 'de') might return"Vierzehnte" The expression format-integer(7, 'a') returns"g". The expression format-integer(57, 'I') returns"LVII". The expression format-integer(1234, '#;##0;')returns "1;234". 4.7Formatting numbers This section defines a function for formatting decimal andfloating point numbers. Function Meaning fn:format-number Returns a string containing a number formatted according to agiven picture string, taking account of decimal formats specifiedin the static context. Note: This function can be used to format any numeric quantity,including an integer. For integers, however, the fn:format-integer functionoffers additional possibilities. Note also that the picture stringsused by the two functions are not 100% compatible, though theyshare some options in common. 4.7.1 Defining a decimal format Decimal formats are defined in the static context, and the waythey are defined is therefore outside the scope of thisspecification. XSLT and XQuery both provide custom syntax forcreating a decimal format. The static context provides a set of decimal formats. One of thedecimal formats is unnamed, the others (if any) are identified by aQName. There is always an unnamed decimal format available, but itscontents are Â·implementation-definedÂ·. Each decimal format provides a set of namedproperties, described in the following table: Name Type Usage (non-normative) decimal-separator-sign A single Â·characterÂ· Defines the character used to represent thedecimal point (typically ".") both in the picture string and in theformatted number grouping-separator-sign A single Â·characterÂ· Defines the character used to separate groups ofdigits (typically ",") both in the picture string and in theformatted number infinity A Â·stringÂ· Defines the string used to represent the valuepositive or negative infinity in the formatted number (typically"Infinity") minus-sign A single Â·characterÂ· Defines the character used as a minus sign in theformatted number if there is no subpicture for formatting negativenumbers (typically "-", x2D) NaN A Â·stringÂ· Defines the string used to represent the valueNaN in the formatted number percent-sign A single Â·characterÂ· Defines the character used as a percent sign(typically "%") both in the picture string and in the formattednumber per-mille-sign A single Â·characterÂ· Defines the character used as a per-mille sign(typically "â€°", x2030) both in the picture string and in theformatted number mandatory-digit-sign A single Â·characterÂ·, which must be a character in Unicodecategory Nd with decimal digit value 0 (zero) Defines the characters used in the picture stringto represent a mandatory digit: for example, if themandatory-digit-sign is "0" then any of the digits "0" to "9" maybe used (interchangeably) in the picture string to represent amandatory digit, and in the formatted number the characters "0" to"9" will be used to represent the digits one to nine. optional-digit-sign A single Â·characterÂ· Defines the character used in the picture stringto represent an optional digit (typically "#") pattern-separator-sign A single Â·characterÂ· Defines the character used in the picture stringto separate the positive and negative subpictures (typically";") [Definition] The decimal digitfamily of a decimal format is the sequence of ten digits withconsecutive Unicode Â·codepointsÂ· starting with themandatory-digit-sign. It is a constraint that, for any named or unnamed decimalformat, the properties representing characters used ina Â·picturestringÂ· must have distinct values.These properties aredecimal-separator-sign,grouping-separator-sign, percent-sign,per-mille-sign, optional-digit-sign, andpattern-separator-sign. Furthermore, none of theseproperties may be equal to any Â·characterÂ· in theÂ·decimaldigit familyÂ·. 4.7.2fn:format-number Summary Returns a string containing a number formatted according to agiven picture string, taking account of decimal formats specifiedin the static context. Signatures fn:format-number($value as numeric?,$picture as xs:string) as xs:string fn:format-number( $value as numeric?, $picture as xs:string, $decimal-format-name as xs:string?) as xs:string Properties The two-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. The three-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on decimal formats, and namespaces. Rules The effect of the two-argument form of the function isequivalent to calling the three-argument form with an emptysequence as the value of the third argument. The function formats $value as a string using theÂ·picturestringÂ· specified by the$picture argument and the decimal-format named by the$decimal-format-name argument, or the defaultdecimal-format, if there is no $decimal-format-nameargument. The syntax of the picture string is described in 4.7.3 Syntax of the picturestring. The $value argument may be of any numeric data type(xs:double, xs:float,xs:decimal, or their subtypes includingxs:integer). Note that if an xs:decimalis supplied, it is not automatically promoted to anxs:double, as such promotion can involve a loss ofprecision. If the supplied value of the $value argument is anempty sequence, the function behaves as if the supplied value werethe xs:double value NaN. The value of $decimal-format-name, if presentand non-empty, must be a string whichafter removal of leading and trailing whitespace is in the form ofan an EQName as defined in the XPath 3.0 grammar, thatis one of the following: A lexical QName, which is expanded using the staticallyknown namespaces. The default namespace is not used (noprefix means no namespace). A URIQualifiedName using the syntaxQ{uri}local, where the URI can be zero-length toindicate a name in no namespace. The decimal format that is used is the decimal format in thestatic context whose name matches $decimal-format-nameif supplied, or the default decimal format in the static contextotherwise. The evaluation of the format-number function takesplace in two phases, an analysis phase described in 4.7.4 Analysing the picturestring and a formatting phase described in 4.7.5 Formatting thenumber. The analysis phase takes as its inputs the Â·picturestringÂ· and the variables derivedfrom the relevant decimal format in the static context, andproduces as its output a number of variables with defined values.The formatting phase takes as its inputs the number to be formattedand the variables produced by the analysis phase, and produces asits output a string containing a formatted representation of thenumber. The result of the function is the formatted stringrepresentation of the supplied number. Error Conditions A dynamic error is raised [err:FODF1280] if the name specified as the$decimal-format-name argument is neither a validlexical QName nor a valid URIQualifiedName, orif it uses a prefix that is not found in the statically knownnamespaces, or if the static context does not contain adeclaration of a decimal-format with a matching expanded QName. Ifthe processor is able to detect the error statically (for example,when the argument is supplied as a string literal), then theprocessor may optionally signal this as a staticerror. Notes Numbers will always be formatted with the most significant digiton the left. Examples The following examples assume a default decimal format in whichthe chosen digits are the ASCII digits 0-9, the decimal separatoris ".", the grouping separator is ",", the minus-sign is "-", thepercent-sign is "%", and the exponent separator is"e". The expression format-number(12345.6, '#,###.00')returns "12,345.60". The expression format-number(12345678.9,'9,999.99') returns "12,345,678.90". The expression format-number(123.9, '9999') returns"0124". The expression format-number(0.14, '01%') returns"14%". The expression format-number(-6, '000') returns"-006". The expression format-number(12.34, '0.000e00')returns "1.234e01". The expression format-number(12.34, '#.000e0')returns "0.123e2". The following example assumes the existence of a decimal formatnamed 'ch' in which the grouping separator is Ê¹ andthe decimal separator is Â·: The expression format-number(1234.5678, '#Ê¹##0Â·00','ch') returns "1Ê¹234Â·57". 4.7.3 Syntax of the picturestring Note: This differs from the format-number functionpreviously defined in XSLT 2.0 in that any digit can be used in thepicture string to represent a mandatory digit: for example thepicture strings '000', '001', and '999' are equivalent. Thedigits used must all be from the same decimal digit family,specifically, the sequence of ten consecutive digits starting withthe mandatory-digit-sign. This change is to alignformat-number (which previously used '000') withformat-dateTime (which used '001'). [Definition] The formatting of a number iscontrolled by a picture string. The picture string is asequence of Â·charactersÂ·, in which the characters assigned to theproperties decimal-separator-sign,grouping-sign, decimal-digit-family,optional-digit-sign andpattern-separator-sign are classified as activecharacters, and all other characters (including thepercent-sign and per-mille-sign) areclassified as passive characters. The integer part of the sub-picture is defined as thepart that appears to the left of thedecimal-separator-sign if there is one, or the entiresub-picture otherwise. The fractional part of thesub-picture is defined as the part that appears to the right of thedecimal-separator-sign if there is one, or thepart that appears to the right of the rightmost active characterotherwise. The fractional part may be zero-length. A dynamic error is raised [err:FODF1310] if the Â·picturestringÂ· does not conform to thefollowing rules. Note that in these rules the words "preceded" and"followed" refer to characters anywhere in the string, they are notto be read as "immediately preceded" and "immediatelyfollowed". A picture-string consists either of a sub-picture, or of twosub-pictures separated by a pattern-separator-sign. Apicture-string must not contain more than onepattern-separator-sign. If the picture-string containstwo sub-pictures, the first is used for positive values and thesecond for negative values. A sub-picture must not contain more than onedecimal-separator-sign. A sub-picture must not contain more than onepercent-sign or per-mille-sign, and itmust not contain one of each. A sub-picture must contain at least onecharacter that is an optional-digit-sign or a member ofthe decimal-digit-family. A sub-picture must not contain a passivecharacter that is preceded by an active character and that isfollowed by another active character. A sub-picture must not contain agrouping-separator-sign adjacent to adecimal-separator-sign. The integer part of a sub-picture must notcontain a member of the decimal-digit-family that isfollowed by an optional-digit-sign. The fractional partof a sub-picture must not contain anoptional-digit-sign that is followed by a member of thedecimal-digit-family. 4.7.4 Analysing the picturestring This phase of the algorithm analyses the Â·picturestringÂ· and theproperties from the selected decimal format in thestatic context, and it has the effect of setting the values ofvarious variables, which are used in the subsequent formattingphase. These variables are listed below. Each is shown with itsinitial setting and its data type. Several variables are associated with each sub-picture. If thereare two sub-pictures, then these rules are applied to onesub-picture to obtain the values that apply to positive numbers,and to the other to obtain the values that apply to negativenumbers. If there is only one sub-picture, then the values for bothcases are derived from this sub-picture. The variables are as follows: The integer-part-grouping-positions is a sequence ofintegers representing the positions of grouping separators withinthe integer part of the sub-picture. For eachgrouping-separator-sign that appears within the integerpart of the sub-picture, this sequence contains an integer that isequal to the total number of optional-digit-sign anddecimal-digit-family characters that appear within theinteger part of the sub-picture and to the right of thegrouping-separator-sign. In addition, if theseinteger-part-grouping-positions are at regular intervals(that is, if they form a sequence N, 2N,3N, ... for some integer value N, includingthe case where there is only one number in the list), then thesequence contains all integer multiples of N as far asnecessary to accommodate the largest possible number. The minimum-integer-part-size is an integerindicating the minimum number of digits that will appear to theleft of the decimal-separator-sign. It is normally setto the number of decimal-digit-family characters foundin the integer part of the sub-picture. But if the sub-picturecontains no decimal-digit-family character and nodecimal-separator-sign, it is set to one. Note: There is no maximum integer part size. All significant digits inthe integer part of the number will be displayed, even if thisexceeds the number of optional-digit-sign anddecimal-digit-family characters in the subpicture. The prefix is set to contain all passive charactersin the sub-picture to the left of the leftmost active character. Ifthe picture string contains only one sub-picture, theprefix for the negative sub-picture is set byconcatenating the minus-sign character and theprefix for the positive sub-picture (if any), in thatorder. The fractional-part-grouping-positions is a sequenceof integers representing the positions of grouping separatorswithin the fractional part of the sub-picture. For eachgrouping-separator-sign that appears within thefractional part of the sub-picture, this sequence contains aninteger that is equal to the total number ofoptional-digit-sign and decimal-digit-familycharacters that appear within the fractional part of thesub-picture and to the left of thegrouping-separator-sign. Note: There is no need to extrapolate grouping positions on thefractional side, because the number of digits in the output willnever exceed the number of optional-digit-sign anddecimal-digit-family in the fractional part of thesub-picture. The minimum-fractional-part-size is set to the numberof decimal-digit-family characters found in thefractional part of the sub-picture. The maximum-fractional-part-size is set to the totalnumber of optional-digit-sign anddecimal-digit-family characters found in the fractionalpart of the sub-picture. The suffix is set to contain all passive charactersto the right of the rightmost active character in thesub-picture. Note: If there is only one sub-picture, then all variables forpositive numbers and negative numbers will be the same, except forprefix: the prefix for negative numbers will be precededby the minus-sign character. 4.7.5 Formatting the number This section describes the second phase of processing of thefn:format-numberfunction. This phase takes as input a number to be formatted(referred to as the input number), and the variables setup by analysing the decimal format in the static context and theÂ·picturestringÂ·, as described above. Theresult of this phase is a string, which forms the return value ofthe fn:format-numberfunction. The algorithm for this second stage of processing is asfollows: If the input number is NaN (not a number), the result is thespecified NaN-symbol (with no prefix orsuffix). In the rules below, the positive sub-picture and its associatedvariables are used if the input number is positive, and thenegative sub-picture and its associated variables are usedotherwise. Negative zero is taken as negative, positive zero aspositive. If the input number is positive or negative infinity, the resultis the concatenation of the appropriate prefix, theinfinity-symbol, and the appropriatesuffix. If the sub-picture contains a percent-sign, thenumber is multiplied by 100. If the sub-picture contains aper-mille-sign, the number is multiplied by 1000. Theresulting number is referred to below as the adjustednumber. The adjusted number is converted (if necessary) to anxs:decimal value, using an implementation ofxs:decimal that imposes no limits on thetotalDigits or fractionDigits facets. Ifthere are several such values that are numerically equal to theadjusted number (bearing in mind that if theadjusted number is an xs:double orxs:float, the comparison will be done by convertingthe decimal value back to an xs:double orxs:float), the one that is chosenshould be one with the smallest possible number ofdigits not counting leading or trailing zeroes (whether significantor insignificant). For example, 1.0 is preferred to 0.9999999999,and 100000000 is preferred to 100000001. This value is then roundedso that it uses no more thanmaximum-fractional-part-size digits in its fractionalpart. The rounded number is defined to be the result ofconverting the adjusted number to anxs:decimal value, as described above, and then callingthe function fn:round-half-to-evenwith this converted number as the first argument and themaximum-fractional-part-size as the second argument,again with no limits on the totalDigits orfractionDigits in the result. The absolute value of the rounded number is convertedto a string in decimal notation, with no insignificant leading ortrailing zeroes, using the digits in thedecimal-digit-family to represent the ten decimaldigits, and the decimal-separator-sign to separate theinteger part and the fractional part. (The value zero will at thisstage be represented by a decimal-separator-sign on itsown.) If the number of digits to the left of thedecimal-separator-sign is less thanminimum-integer-part-size, leadingzero-digit-sign characters are added to pad out to thatsize. If the number of digits to the right of thedecimal-separator-sign is less thanminimum-fractional-part-size, trailingzero-digit-sign characters are added to pad out to thatsize. For each integer N in theinteger-part-grouping-positions list, agrouping-separator-sign character is inserted into thestring immediately after that digit that appears in the integerpart of the number and has N digits between it and thedecimal-separator-sign, if there is such a digit. For each integer N in thefractional-part-grouping-positions list, agrouping-separator-sign character is inserted into thestring immediately before that digit that appears in the fractionalpart of the number and has N digits between it and thedecimal-separator-sign, if there is such a digit. If there is no decimal-separator-sign in thesub-picture, or if there are no digits to the right of thedecimal-separator-sign character in the string, then thedecimal-separator-sign character is removed from thestring (it will be the rightmost character in the string). The result of the function is the concatenation of theappropriate prefix, the string conversion of the numberas obtained above, and the appropriate suffix. 4.8 Trigonometricand exponential functions The functions in this section perform trigonometric and othermathematical calculations on xs:double values. Theyare provided primarily for use in applications performinggeometrical computation, for example when generating SVGgraphics. Functions are provided to support the six most commonly usedtrigonometric calculations: sine, cosine and tangent, and theirinverses arc sine, arc cosine, and arc tangent. Other functionssuch as secant, cosecant, and cotangent are not provided becausethey are easily computed in terms of these six. The functions in this section (with the exception of math:pi) are specified byreference to [IEEE 754-2008], wherethey appear as Recommended operations in section 9. IEEEdefines these functions for a variety of floating point formats;this specification defines them only for xs:doublevalues. The IEEE specification applies with the followingcaveats: IEEE states that the preferred quantum is language-defined. Inthis specification, it is Â·implementation-definedÂ·. IEEE states that certain functions should raise the inexactexception if the result is inexact. In this specification, thisexception if it occurs does not result in an error. Any diagnosticinformation is outside the scope of this specification. IEEE defines various rounding algorithms for inexact results,and states that the choice of rounding direction, and themechanisms for influencing this choice, are language-defined. Inthis specification, the rounding direction and any mechanisms forinfluencing it are Â·implementation-definedÂ·. Certain operations (such as taking the square root of a negativenumber) are defined in IEEE to signal the invalid operationexception and return a quiet NaN. In this specification, suchoperations return NaN and do not raise an error. Thesame policy applies to operations (such as taking the logarithm ofzero) that raise a divide-by-zero exception. Any diagnosticinformation is outside the scope of this specification. Operations whose mathematical result is greater than the largestfinite xs:double value are defined in IEEE to signalthe overflow exception; operations whose mathematical result iscloser to zero than the smallest non-zero xs:doublevalue are similarly defined in IEEE to signal the underflowexception. The treatment of these exceptions in this specificationis defined in 4.2 Arithmetic operators onnumeric values. Function Meaning math:pi Returns an approximation to the mathematical constantÏ€. math:exp Returns the value of ex. math:exp10 Returns the value of10x. math:log Returns the natural logarithm of the argument. math:log10 Returns the base-ten logarithm of the argument. math:pow Returns the result of raising the first argument to the powerof the second. math:sqrt Returns the non-negative square root of the argument. math:sin Returns the sine of the argument, expressed in radians. math:cos Returns the cosine of the argument, expressed in radians. math:tan Returns the tangent of the argument, expressed in radians. math:asin Returns the arc sine of the argument, the result being in therange -Ï€/2 to +Ï€/2 radians. math:acos Returns the arc cosine of the argument, the result being in therange zero to +Ï€ radians. math:atan Returns the arc tangent of the argument, the result being inthe range -Ï€/2 to +Ï€/2 radians. math:atan2 Returns the angle in radians subtended at the origin by thepoint on a plane with coordinates (x, y) and the positive x-axis,the result being in the range -Ï€ to +Ï€. 4.8.1 math:pi Summary Returns an approximation to the mathematical constantÏ€. Signature math:pi() as xs:double Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules This function returns the xs:double value whoselexical representation is 3.141592653589793e0 Examples The expression 2*math:pi() returns6.283185307179586e0. The expression 60 * (math:pi() div 180) converts anangle of 60 degrees to radians. 4.8.2math:exp Summary Returns the value of ex. Signature math:exp($arg as xs:double?) as xs:double? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise the result is the mathematical constant eraised to the power of $arg, as defined in the[IEEE 754-2008] specification of theexp function applied to 64-bit binary floating pointvalues. Notes The treatment of overflow and underflow is defined in 4.2 Arithmetic operators on numericvalues. Examples The expression math:exp(()) returns(). The expression math:exp(0) returns1.0e0. The expression math:exp(1) returns2.7182818284590455e0. The expression math:exp(2) returns7.38905609893065e0. The expression math:exp(-1) returns0.36787944117144233e0. The expression math:exp(math:pi()) returns23.140692632779267e0. The expression math:exp(xs:double('NaN')) returnsxs:double('NaN'). The expression math:exp(xs:double('INF')) returnsxs:double('INF'). The expression math:exp(xs:double('-INF')) returns0.0e0. 4.8.3math:exp10 Summary Returns the value of 10x. Signature math:exp10($arg as xs:double?) as xs:double? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise the result is ten raised to the power of$arg, as defined in the [IEEE754-2008] specification of the exp10 functionapplied to 64-bit binary floating point values. Notes The treatment of overflow and underflow is defined in 4.2 Arithmetic operators on numericvalues. Examples The expression math:exp10(()) returns(). The expression math:exp10(0) returns1.0e0. The expression math:exp10(1) returns1.0e1. The expression math:exp10(0.5) returns3.1622776601683795e0. The expression math:exp10(-1) returns1.0e-1. The expression math:exp10(xs:double('NaN')) returnsxs:double('NaN'). The expression math:exp10(xs:double('INF')) returnsxs:double('INF'). The expression math:exp10(xs:double('-INF'))returns 0.0e0. 4.8.4math:log Summary Returns the natural logarithm of the argument. Signature math:log($arg as xs:double?) as xs:double? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise the result is the natural logarithm of$arg, as defined in the [IEEE754-2008] specification of the log functionapplied to 64-bit binary floating point values. Notes The treatment of divideByZero andinvalidOperation exceptions is defined in 4.2 Arithmetic operators on numericvalues. The effect is that if the argument is less than orequal to zero, the result is NaN. Examples The expression math:log(()) returns(). The expression math:log(0) returnsxs:double('-INF'). The expression math:log(math:exp(1)) returns1.0e0. The expression math:log(1.0e-3) returns-6.907755278982137e0. The expression math:log(2) returns0.6931471805599453e0. The expression math:log(-1) returnsxs:double('NaN'). The expression math:log(xs:double('NaN')) returnsxs:double('NaN'). The expression math:log(xs:double('INF')) returnsxs:double('INF'). The expression math:log(xs:double('-INF')) returnsxs:double('NaN'). 4.8.5math:log10 Summary Returns the base-ten logarithm of the argument. Signature math:log10($arg as xs:double?) as xs:double? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise the result is the base-10 logarithm of$arg, as defined in the [IEEE754-2008] specification of the log10 functionapplied to 64-bit binary floating point values. Notes The treatment of divideByZero andinvalidOperation exceptions is defined in 4.2 Arithmetic operators on numericvalues. The effect is that if the argument is less than orequal to zero, the result is NaN. Examples The expression math:log10(()) returns(). The expression math:log10(0) returnsxs:double('-INF'). The expression math:log10(1.0e3) returns3.0e0. The expression math:log10(1.0e-3) returns-3.0e0. The expression math:log10(2) returns0.3010299956639812e0. The expression math:log10(-1) returnsxs:double('NaN'). The expression math:log10(xs:double('NaN')) returnsxs:double('NaN'). The expression math:log10(xs:double('INF')) returnsxs:double('INF'). The expression math:log10(xs:double('-INF'))returns xs:double('NaN'). 4.8.6math:pow Summary Returns the result of raising the first argument to the power ofthe second. Signature math:pow($x as xs:double?,$y as numeric) as xs:double? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $x is the empty sequence, the function returnsthe empty sequence. If $y is an instance of xs:integer,the result is $x raised to the power of$y as defined in the [IEEE754-2008] specification of the pown functionapplied to a 64-bit binary floating point value and an integer. Otherwise $y is converted to anxs:double by numeric promotion, and the result is thevalue of $x raised to the power of $y asdefined in the [IEEE 754-2008]specification of the pow function applied to two64-bit binary floating point values. Notes The treatment of the divideByZero andinvalidOperation exceptions is defined in 4.2 Arithmetic operators on numericvalues. Some of the consequences are illustrated in theexamples below. Examples The expression math:pow((), 93.7) returns(). The expression math:pow(2, 3) returns8.0e0. The expression math:pow(-2, 3) returns-8.0e0. The expression math:pow(2, -3) returns0.125e0. The expression math:pow(-2, -3) returns-0.125e0. The expression math:pow(2, 0) returns1.0e0. The expression math:pow(0, 0) returns1.0e0. The expression math:pow(xs:double('INF'), 0)returns 1.0e0. The expression math:pow(xs:double('NaN'), 0)returns 1.0e0. The expression math:pow(-math:pi(), 0) returns1.0e0. The expression math:pow(0e0, 3) returns0.0e0. The expression math:pow(0e0, 4) returns0.0e0. The expression math:pow(-0e0, 3) returns-0.0e0. The expression math:pow(0, 4) returns0.0e0. The expression math:pow(0e0, -3) returnsxs:double('INF'). The expression math:pow(0e0, -4) returnsxs:double('INF'). The expression math:pow(-0e0, -3) returnsxs:double('-INF'). The expression math:pow(0, -4) returnsxs:double('INF'). The expression math:pow(16, 0.5e0) returns4.0e0. The expression math:pow(16, 0.25e0) returns2.0e0. The expression math:pow(0e0, -3.0e0) returnsxs:double('INF'). The expression math:pow(-0e0, -3.0e0) returnsxs:double('-INF'). (Odd-valued whole numbers aretreated specially). The expression math:pow(0e0, -3.1e0) returnsxs:double('INF'). The expression math:pow(-0e0, -3.1e0) returnsxs:double('INF'). The expression math:pow(0e0, 3.0e0) returns0.0e0. The expression math:pow(-0e0, 3.0e0) returns-0.0e0. (Odd-valued whole numbers are treatedspecially). The expression math:pow(0e0, 3.1e0) returns0.0e0. The expression math:pow(-0e0, 3.1e0) returns0.0e0. The expression math:pow(-1, xs:double('INF'))returns 1.0e0. The expression math:pow(-1, xs:double('-INF'))returns 1.0e0. The expression math:pow(1, xs:double('INF'))returns 1.0e0. The expression math:pow(1, xs:double('-INF'))returns 1.0e0. The expression math:pow(1, xs:double('NaN'))returns 1.0e0. The expression math:pow(-2.5e0, 2.0e0) returns6.25e0. The expression math:pow(-2.5e0, 2.00000001e0)returns xs:double('NaN'). 4.8.7math:sqrt Summary Returns the non-negative square root of the argument. Signature math:sqrt($arg as xs:double?) as xs:double? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise the result is the mathematical non-negative squareroot of $arg as defined in the [IEEE 754-2008] specification of thesquareRoot function applied to 64-bit binary floatingpoint values. Notes The treatment of the invalidOperation exception isdefined in 4.2 Arithmetic operators onnumeric values. The effect is that if the argument is lessthan zero, the result is NaN. If $arg is positive or negative zero, positiveinfinity, or NaN, then the result is$arg. (Negative zero is the only case where the resultcan have negative sign) Examples The expression math:sqrt(()) returns(). The expression math:sqrt(0.0e0) returns0.0e0. The expression math:sqrt(-0.0e0) returns-0.0e0. The expression math:sqrt(1.0e6) returns1.0e3. The expression math:sqrt(2.0e0) returns1.4142135623730951e0. The expression math:sqrt(-2.0e0) returnsxs:double('NaN'). The expression math:sqrt(xs:double('NaN')) returnsxs:double('NaN'). The expression math:sqrt(xs:double('INF')) returnsxs:double('INF'). The expression math:sqrt(xs:double('-INF')) returnsxs:double('NaN'). 4.8.8math:sin Summary Returns the sine of the argument, expressed in radians. Signature math:sin($Î¸ as xs:double?) as xs:double? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $Î¸ is the emptysequence, the function returns the empty sequence. Otherwise the result is the sine of $Î¸, treated as anangle in radians, as defined in the [IEEE754-2008] specification of the sin functionapplied to 64-bit binary floating point values. Notes The treatment of the invalidOperation andunderflow exceptions is defined in 4.2 Arithmetic operators on numericvalues. If $Î¸ is positive ornegative zero, the result is $Î¸. If $Î¸ is positive ornegative infinity, or NaN, then the result isNaN. Otherwise the result is always in the range -1.0e0 to +1.0e0 Examples The expression math:sin(()) returns(). The expression math:sin(0) returns0.0e0. The expression math:sin(-0.0e0) returns-0.0e0. The expression math:sin(math:pi() div 2) returns1.0e0. The expression math:sin(-math:pi() div 2) returns-1.0e0. The expression math:sin(math:pi()) returns0.0e0 (approximately). The expression math:sin(xs:double('NaN')) returnsxs:double('NaN'). The expression math:sin(xs:double('INF')) returnsxs:double('NaN'). The expression math:sin(xs:double('-INF')) returnsxs:double('NaN'). 4.8.9math:cos Summary Returns the cosine of the argument, expressed in radians. Signature math:cos($Î¸ as xs:double?) as xs:double? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $Î¸ is the emptysequence, the function returns the empty sequence. If $Î¸ is positive ornegative infinity, or NaN, then the result isNaN. Otherwise the result is the cosine of $Î¸, treated as anangle in radians, as defined in the [IEEE754-2008] specification of the cos functionapplied to 64-bit binary floating point values. Notes The treatment of the invalidOperation exception isdefined in 4.2 Arithmetic operators onnumeric values. If $Î¸ is positive ornegative zero, the result is $Î¸. If $Î¸ is positive ornegative infinity, or NaN, then the result isNaN. Otherwise the result is always in the range -1.0e0 to +1.0e0 Examples The expression math:cos(()) returns(). The expression math:cos(0) returns1.0e0. The expression math:cos(-0.0e0) returns1.0e0. The expression math:cos(math:pi() div 2) returns0.0e0 (approximately). The expression math:cos(-math:pi() div 2) returns0.0e0 (approximately). The expression math:cos(math:pi()) returns-1.0e0. The expression math:cos(xs:double('NaN')) returnsxs:double('NaN'). The expression math:cos(xs:double('INF')) returnsxs:double('NaN'). The expression math:cos(xs:double('-INF')) returnsxs:double('NaN'). 4.8.10math:tan Summary Returns the tangent of the argument, expressed in radians. Signature math:tan($Î¸ as xs:double?) as xs:double? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $Î¸ is the emptysequence, the function returns the empty sequence. Otherwise the result is the tangent of$Î¸,treated as an angle in radians, as defined in the [IEEE 754-2008] specification of thetan function applied to 64-bit binary floating pointvalues. Notes The treatment of the invalidOperation andunderflow exceptions is defined in 4.2 Arithmetic operators on numericvalues. If $Î¸ is positive ornegative infinity, or NaN, then the result isNaN. Examples The expression math:tan(()) returns(). The expression math:tan(0) returns0.0e0. The expression math:tan(-0.0e0) returns-0.0e0. The expression math:tan(math:pi() div 4) returns1.0e0 (approximately). The expression math:tan(-math:pi() div 4) returns-1.0e0 (approximately). The expression math:tan(math:pi() div 2) returns1.633123935319537E16 (approximately). The expression math:tan(-math:pi() div 2) returns-1.633123935319537E16 (approximately). The expression math:tan(math:pi()) returns0.0e0 (approximately). The expression math:tan(xs:double('NaN')) returnsxs:double('NaN'). The expression math:tan(xs:double('INF')) returnsxs:double('NaN'). The expression math:tan(xs:double('-INF')) returnsxs:double('NaN'). 4.8.11math:asin Summary Returns the arc sine of the argument, the result being in therange -Ï€/2 to +Ï€/2 radians. Signature math:asin($arg as xs:double?) as xs:double? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise the result is the arc sine of$Î¸, treated as anangle in radians, as defined in the [IEEE754-2008] specification of the asin functionapplied to 64-bit binary floating point values. Notes The treatment of the invalidOperation andunderflow exceptions is defined in 4.2 Arithmetic operators on numericvalues. If $arg is positive or negative zero, the result is$arg. If $arg is NaN, or if its absolutevalue is greater than one, then the result is NaN. In other cases the result is an xs:double valuerepresenting an angle Î¸ in radians in therange -Ï€/2 <=$Î¸<= +Ï€/2. Examples The expression math:asin(()) returns(). The expression math:asin(0) returns0.0e0. The expression math:asin(-0.0e0) returns-0.0e0. The expression math:asin(1.0e0) returns1.5707963267948966e0 (approximately). The expression math:asin(-1.0e0) returns-1.5707963267948966e0 (approximately). The expression math:asin(2.0e0) returnsxs:double('NaN'). The expression math:asin(xs:double('NaN')) returnsxs:double('NaN'). The expression math:asin(xs:double('INF')) returnsxs:double('NaN'). The expression math:asin(xs:double('-INF')) returnsxs:double('NaN'). 4.8.12math:acos Summary Returns the arc cosine of the argument, the result being in therange zero to +Ï€ radians. Signature math:acos($arg as xs:double?) as xs:double? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise the result is the arc cosine of$Î¸, treated as anangle in radians, as defined in the [IEEE754-2008] specification of the acos functionapplied to 64-bit binary floating point values. Notes The treatment of the invalidOperation exception isdefined in 4.2 Arithmetic operators onnumeric values. If $arg is NaN, or if its absolutevalue is greater than one, then the result is NaN. In other cases the result is an xs:double valuerepresenting an angle Î¸ in radians in therange 0 <= $Î¸ <=+Ï€. Examples The expression math:acos(()) returns(). The expression math:acos(0) returns1.5707963267948966e0 (approximately). The expression math:acos(-0.0e0) returns1.5707963267948966e0 (approximately). The expression math:acos(1.0e0) returns0.0e0. The expression math:acos(-1.0e0) returns3.141592653589793e0 (approximately). The expression math:acos(2.0e0) returnsxs:double('NaN'). The expression math:acos(xs:double('NaN')) returnsxs:double('NaN'). The expression math:acos(xs:double('INF')) returnsxs:double('NaN'). The expression math:acos(xs:double('-INF')) returnsxs:double('NaN'). 4.8.13math:atan Summary Returns the arc tangent of the argument, the result being in therange -Ï€/2 to +Ï€/2 radians. Signature math:atan($arg as xs:double?) as xs:double? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise the result is the arc tangent of$Î¸, treated as anangle in radians, as defined in the [IEEE754-2008] specification of the atan functionapplied to 64-bit binary floating point values. Notes The treatment of the underflow exception is definedin 4.2 Arithmetic operators on numericvalues. If $arg is positive or negative zero, the result is$arg. If $arg is NaN then the result isNaN. In other cases the result is an xs:double valuerepresenting an angle Î¸ in radians in therange -Ï€/2 <=$Î¸<= +Ï€/2. Examples The expression math:atan(()) returns(). The expression math:atan(0) returns0.0e0. The expression math:atan(-0.0e0) returns-0.0e0. The expression math:atan(1.0e0) returns0.7853981633974483e0 (approximately). The expression math:atan(-1.0e0) returns-0.7853981633974483e0 (approximately). The expression math:atan(xs:double('NaN')) returnsxs:double('NaN'). The expression math:atan(xs:double('INF')) returns1.5707963267948966e0 (approximately). The expression math:atan(xs:double('-INF')) returns-1.5707963267948966e0 (approximately). 4.8.14math:atan2 Summary Returns the angle in radians subtended at the origin by thepoint on a plane with coordinates (x, y) and the positive x-axis,the result being in the range -Ï€ to +Ï€. Signature math:atan2($y as xs:double, $x as xs:double) as xs:double Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The result is the value of atan2(y, x) as definedin the [IEEE 754-2008] specification ofthe atan2 function applied to 64-bit binary floatingpoint values. Notes The treatment of the underflow exception is definedin 4.2 Arithmetic operators on numericvalues. If either argument is NaN then theresult is NaN. If $y is positive and $x is positiveand finite, then (subject to rules for overflow, underflow andapproximation) the value of atan2($y, $x) isatan($y div $x). If $y is positive and $x is negativeand finite, then (subject to the same caveats) the value ofatan2($y, $x) is Ï€ - atan($y div$x). Some results for special values of the arguments are shown inthe examples below. Examples The expression math:atan2(+0.0e0, 0.0e0) returns0.0e0. The expression math:atan2(-0.0e0, 0.0e0) returns-0.0e0. The expression math:atan2(+0.0e0, -0.0e0) returnsmath:pi(). The expression math:atan2(-0.0e0, -0.0e0) returns-math:pi(). The expression math:atan2(-1, 0.0e0) returns-math:pi() div 2. The expression math:atan2(+1, 0.0e0) returns+math:pi() div 2. The expression math:atan2(-0.0e0, -1) returns-math:pi(). The expression math:atan2(+0.0e0, -1) returns+math:pi(). The expression math:atan2(-0.0e0, +1) returns-0.0e0. The expression math:atan2(+0.0e0, +1) returns+0.0e0. 5Functions on strings This section specifies functions and operators on the [XML Schema Part 2: Datatypes Second Edition]xs:string datatype and the datatypes derived fromit. 5.1 Stringtypes The operators described in this section are defined on thefollowing types. Each type whose name is indented is derived fromthe type whose name appears nearest above with one less level ofindentation. xs:string xs:normalizedString xs:token xs:language xs:NMTOKEN xs:Name xs:NCName xs:ID xs:IDREF xs:ENTITY They also apply to user-defined types derived by restrictionfrom the above types. 5.2 Functions to assembleand disassemble strings Function Meaning fn:codepoints-to-string Creates an xs:string from a sequence of Â·codepointsÂ·. fn:string-to-codepoints Returns the sequence of Â·codepointsÂ· thatconstitute an xs:string value. 5.2.1 fn:codepoints-to-string Summary Creates an xs:string from a sequence of Â·codepointsÂ·. Signature fn:codepoints-to-string($arg as xs:integer*) as xs:string Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns the string made up from the Â·charactersÂ· whoseUnicode Â·codepointsÂ· are supplied in $arg. This willbe the zero-length string if $arg is the emptysequence. Error Conditions A dynamic error is raised [err:FOCH0001] if any of the codepoints in$arg is not a permitted XML character. Examples The expression fn:codepoints-to-string((66, 65, 67,72)) returns "BACH". The expression fn:codepoints-to-string((2309, 2358, 2378,2325)) returns "à¤…à¤¶à¥Šà¤•". The expression fn:codepoints-to-string(()) returns"". The expression fn:codepoints-to-string(0) raiseserror FOCH0001. 5.2.2 fn:string-to-codepoints Summary Returns the sequence of Â·codepointsÂ· thatconstitute an xs:string value. Signature fn:string-to-codepoints($arg as xs:string?) as xs:integer* Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns a sequence of integers, each integer beingthe Unicode Â·codepointsÂ· of the corresponding Â·characterÂ· in$arg. If $arg is a zero-length string or the emptysequence, the function returns the empty sequence. Examples The expression fn:string-to-codepoints("ThÃ©rÃ¨se")returns (84, 104, 233, 114, 232, 115, 101). 5.3 Comparisonof strings Function Meaning fn:compare Returns -1, 0, or 1, depending on whether$comparand1 collates before, equal to, or after$comparand2 according to the rules of a selectedcollation. fn:codepoint-equal Returns true if two strings are equal, consideredcodepoint-by-codepoint. 5.3.1 Collations A collation is a specification of the manner in which Â·stringsÂ·s arecompared and, by extension, ordered. When values whose type isxs:string or a type derived fromxs:string are compared (or, equivalently, sorted), thecomparisons are inherently performed according to some collation(even if that collation is defined entirely on codepoint values).The [Character Model for the World Wide Web 1.0:Fundamentals] observes that some applications may requiredifferent comparison and ordering behaviors than otherapplications. Similarly, some users having particular linguisticexpectations may require different behaviors than other users.Consequently, the collation must be taken into account whencomparing strings in any context. Several functions in this and thefollowing section make use of a collation. Collations can indicate that two different codepoints are, infact, equal for comparison purposes (e.g., "v" and "w" areconsidered equivalent in some Swedish collations). Strings can becompared codepoint-by-codepoint or in a linguistically appropriatemanner, as defined by the collation. Some collations, especially those based on the [Unicode Collation Algorithm] can be"tailored" for various purposes. This document does not discusssuch tailoring, nor does it provide a mechanism to performtailoring. Instead, it assumes that the collation argument to thevarious functions below is a tailored and named collation. The Â·Unicodecodepoint collationÂ· is a collationavailable in every implementation, which sorts based on codepointvalues. For further details see 5.3.2 The Unicode CodepointCollation In the ideal case, a collation should treat two strings as equalif the two strings are identical after Unicode normalization. Thus,the [Character Model for the WorldWide Web 1.0: Normalization] recommends that all strings besubjected to early Unicode normalization and some collations willraise runtime errors if they encounter strings that are notproperly normalized. However, it is not possible to guarantee thatall strings in all XML documents are, in fact, normalized, or thatthey are normalized in the same manner. In order to maximizeinteroperability of operations on XML documents in general, theremay be collations that operate on unnormalized strings and othercollations that implicitly normalize strings before comparing them.Applications may choose the kind of collation best suited for theirneeds. Note that collations based on the Unicode collationalgorithm implicitly normalize strings before comparison andproduce equivalent results regardless of a string'snormalization. This specification assumes that collations are named and thatthe collation name may be provided as an argument to stringfunctions. Functions that allow specification of a collation do sowith an argument whose type is xs:string but whoselexical form must conform to an xs:anyURI. If thecollation is specified using a relative URI reference, it isresolved relative to the value of the Static Base URI property fromthe static context. This specification also defines themanner in which a default collation is determined if the collationargument is not specified in calls of functions that use acollation but allow it to be omitted. This specification does not define whether or not the collationURI is dereferenced. The collation URI may be an abstractidentifier, or it may refer to an actual resource describing thecollation. If it refers to a resource, this specification does notdefine the nature of that resource. One possible candidate is thatthe resource is a locale description expressed using the LocaleData Markup Language: see [Locale Data MarkupLanguage]. Functions such as fn:compare and fn:max that comparexs:string values use a single collation URI toidentify all aspects of the collation rules. This means that anyparameters such as the strength of the collation must be specifiedas part of the collation URI. For example, suppose there is acollation " http://www.example.com/collations/French "that refers to a French collation that compares on the basis ofbase characters. Collations that use the same basic rules, but withhigher strengths, for example, base characters and accents, or basecharacters, accents and case, would need to be given differentnames, say " http://www.example.com/collations/French1" and " http://www.example.com/collations/French2 ".Note that some specifications use the term collation to refer to analgorithm that can be parameterized, but in this specification,each possible parameterization is considered to be a distinctcollation. The XQuery/XPath static context includes a provision for adefault collation that can be used for string comparisons andordering operations. See the description of the static context inSection2.1.1 Static Context XP30. If thedefault collation is not specified by the user or the system, thedefault collation is the Â·Unicode codepoint collationÂ·. Note: XML allows elements to specify the xml:langattribute to indicate the language associated with the content ofsuch an element. This specification does not usexml:lang to identify the default collation becauseusing xml:lang does not produce desired effects whenthe two strings to be compared have different xml:langvalues or when a string is multilingual. 5.3.2 The Unicode CodepointCollation [Definition] The collation URIhttp://www.w3.org/2005/xpath-functions/collation/codepointidentifies a collation which must be recognized by everyimplementation: it is referred to as the Unicode codepointcollation (not to be confused with the Unicode collationalgorithm). The Unicode codepoint collation does not perform anynormalization on the supplied strings. The collation is defined as follows. Each of the two strings isconverted to a sequence of integers using the fn:string-to-codepointsfunction. These two sequences $A and $Bare then compared as follows: If both sequences are empty, the strings are equal If one sequence is empty and the other is not, then the stringcorresponding to the empty sequence is less than the otherstring. If the first integer in $A is less than the firstinteger in $B, then the string corresponding to$A is less than the string corresponding to$B. If the first integer in $A is greater than thefirst integer in $B, then the string corresponding to$A is greater than the string corresponding to$B. Otherwise (the first pair of integers are equal), the result isobtained by applying the same rules recursively to fn:subsequence($A, 2) andfn:subsequence($B,2) Note: While the Unicode codepoint collation does not produce resultssuitable for quality publishing of printed indexes or directories,it is adequate for many purposes where a restricted alphabet isused, such as sorting of vehicle registrations. 5.3.3 Choosing a collation Many functions have two signatures, where one signature includesa $collation argument and the other omits thisargument. The collation to use for these functions is determined by thefollowing rules: If the function specifies an explicit collation, CollationA(e.g., if the optional collation argument is specified in a call ofthe fn:compare function),then: If CollationA is supported by the implementation, thenCollationA is used. Otherwise, a dynamic error is raised [err:FOCH0002]. If no collation is explicitly specified for the function and thedefault collation in the XQuery/XPath static context is CollationB,then: If CollationB is supported by the implementation, thenCollationB is used. Otherwise, a dynamic error is raised [err:FOCH0002]. Note: Because the set of collations that are supported is Â·implementation-definedÂ·, an implementation has the option to supportall collation URIs, in which case it will never raise thiserror. 5.3.4fn:compare Summary Returns -1, 0, or 1, depending on whether$comparand1 collates before, equal to, or after$comparand2 according to the rules of a selectedcollation. Signatures fn:compare($comparand1 as xs:string?,$comparand2 as xs:string?) as xs:integer? fn:compare( $comparand1 as xs:string?, $comparand2 as xs:string?, $collation as xs:string) as xs:integer? Properties The two-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations. The three-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations, and static base uri. Rules Returns -1, 0, or 1, depending on whether the value of the$comparand1 is respectively less than, equal to, orgreater than the value of $comparand2, according tothe rules of the collation that is used. The collation used by this function is determined according tothe rules in 5.3.3 Choosing acollation. If either $comparand1 or $comparand2is the empty sequence, the function returns the empty sequence. This function, called with the first signature, defines thesemantics of the "eq", "ne", "gt", "lt", "le" and "ge" operators onxs:string values. Examples The expression fn:compare('abc', 'abc') returns0. The expression fn:compare('Strasse', 'StraÃŸe')returns 0. (Assuming the default collationincludes provisions that equate "ss" and the (German) character "ÃŸ"("sharp-s"). Otherwise, the returned value depends on the semanticsof the default collation.). The expression fn:compare('Strasse', 'StraÃŸe','http://example.com/deutsch') returns 0.(Assuming the collation identified by the URIhttp://example.com/deutsch includes provisions thatequate "ss" and the (German) character "ÃŸ" ("sharp-s"). Otherwise,the returned value depends on the semantics of thatcollation.). The expression fn:compare('Strassen', 'StraÃŸe')returns 1. (Assuming the default collationincludes provisions that treat differences between "ss" and the(German) character "ÃŸ" ("sharp-s") with less strength than thedifferences between the base characters, such as the final "n".). 5.3.5 fn:codepoint-equal Summary Returns true if two strings are equal, consideredcodepoint-by-codepoint. Signature fn:codepoint-equal( $comparand1 as xs:string?, $comparand2 as xs:string?) as xs:boolean? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If either argument is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns true orfalse depending on whether the value of$comparand1 is equal to the value of$comparand2, according to the Unicode codepointcollation(http://www.w3.org/2005/xpath-functions/collation/codepoint). Notes This function allows xs:anyURI values to becompared without having to specify the Unicode codepointcollation. Examples The expression fn:codepoint-equal("abcd", "abcd")returns true(). The expression fn:codepoint-equal("abcd", "abcd ")returns false(). The expression fn:codepoint-equal("", "") returnstrue(). The expression fn:codepoint-equal("", ()) returns(). The expression fn:codepoint-equal((), ()) returns(). 5.4 Functions on string values The following functions are defined on values of typexs:string and types derived from it. Function Meaning fn:concat Returns the concatenation of the string values of thearguments. fn:string-join Returns a string created by concatenating the items in asequence, with a defined separator between adjacent items. fn:substring Returns the portion of the value of $sourceStringbeginning at the position indicated by the value of$start and continuing for the number of Â·charactersÂ·indicated by the value of $length. fn:string-length Returns the number of Â·charactersÂ· in astring. fn:normalize-space Returns the value of $arg with leading andtrailing whitespace removed, and sequences of internal whitespacereduced to a single space character. fn:normalize-unicode Returns the value of $arg after applying Unicodenormalization. fn:upper-case Converts a string to upper case. fn:lower-case Converts a string to lower case. fn:translate Returns the value of $arg modified by replacing orremoving individual characters. Notes: When the above operators and functions are applied to datatypesderived from xs:string, they are guaranteed to returnvalues that are instances of xs:string, but the valuemight or might not be an instance of the particular subtype ofxs:string to which they were applied. The strings returned by fn:concat and fn:string-join are notguaranteed to be normalized. But see note in fn:concat. 5.4.1 fn:concat Summary Returns the concatenation of the string values of thearguments. Operator Mapping The two-argument form of this function defines the semantics ofthe "||" operator. Signature fn:concat( $arg1 as xs:anyAtomicType?, $arg2 as xs:anyAtomicType?, ... ) as xs:string Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules This function accepts two or more xs:anyAtomicTypearguments and casts each one to xs:string. Thefunction returns the xs:string that is theconcatenation of the values of its arguments after conversion. Ifany argument is the empty sequence, that argument is treated as thezero-length string. The fn:concat function is specified to allow two ormore arguments, which are concatenated together. This is the onlyfunction specified in this document that allows a variable numberof arguments. This capability is retained for compatibility with[XML Path Language (XPath) Version 1.0]. Notes As mentioned in 5.1 Stringtypes Unicode normalization is not automatically applied tothe result of fn:concat. If a normalized result isrequired, fn:normalize-unicode canbe applied to the xs:string returned byfn:concat. The following XQuery: let $v1 := "I plan to go to Mu"let $v2 := "?nchen in September"return concat($v1, $v2) where the "?" represents either the actual Unicode characterCOMBINING DIARESIS (Unicode codepoint U+0308) or "&#x0308;",will return: "I plan to go to Mu?nchen in September" where the "?" represents either the actual Unicode characterCOMBINING DIARESIS (Unicode codepoint U+0308) or "&#x0308;". Itis worth noting that the returned value is not normalized in NFC;however, it is normalized in NFD. . However, the following XQuery: let $v1 := "I plan to go to Mu"let $v2 := "?nchen in September"return normalize-unicode(concat($v1, $v2)) where the "?" represents either the actual Unicode characterCOMBINING DIARESIS (Unicode codepoint U+0308) or "&#x0308;",will return: "I plan to go to MÃ¼nchen in September" This returned result is normalized in NFC. Examples The expression fn:concat('un', 'grateful') returns"ungrateful". The expression fn:concat('Thy ', (), 'old ', "groans", "",' ring', ' yet', ' in', ' my', ' ancient',' ears.') returns"Thy old groans ring yet in my ancient ears.". The expression fn:concat('Ciao!',()) returns"Ciao!". The expression fn:concat('Ingratitude, ', 'thou ','marble-hearted', ' fiend!') returns "Ingratitude,thou marble-hearted fiend!". The expression fn:concat(01, 02, 03, 04, true())returns "1234true". The expression 10 || '/' || 6 returns"10/6". 5.4.2fn:string-join Summary Returns a string created by concatenating the items in asequence, with a defined separator between adjacent items. Signatures fn:string-join($arg1 as xs:string*) as xs:string fn:string-join($arg1 as xs:string*,$arg2 as xs:string) as xs:string Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The effect of calling the single-argument version of thisfunction is the same as calling the two-argument version with$arg2 set to a zero-length string. The function returns an xs:string created byconcatenating the items in the sequence $arg1, inorder, using the value of $arg2 as a separator betweenadjacent items. If the value of $arg2 is thezero-length string, then the members of $arg1 areconcatenated without a separator. Notes If the value of $arg1 is the empty sequence, thefunction returns the zero-length string. Examples The expression fn:string-join(('Now', 'is', 'the', 'time','...'), ' ') returns "Now is the time ...". The expression fn:string-join(('Blow, ', 'blow, ', 'thou', 'winter ', 'wind!'), '') returns "Blow, blow, thouwinter wind!". The expression fn:string-join((), 'separator')returns "". Assume a document: <doc>  <chap>    <section/>  </chap></doc> with the <section> element as the contextnode, the [XML Path Language (XPath) 2.0]expression: fn:string-join(ancestor-or-self::*/name(), '/') returns "doc/chap/section" 5.4.3fn:substring Summary Returns the portion of the value of $sourceStringbeginning at the position indicated by the value of$start and continuing for the number of Â·charactersÂ·indicated by the value of $length. Signatures fn:substring($sourceString as xs:string?,$start as xs:double) as xs:string fn:substring( $sourceString as xs:string?, $start as xs:double, $length as xs:double) as xs:string Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the value of $sourceString is the emptysequence, the function returns the zero-length string. Otherwise, the function returns a string comprising thoseÂ·charactersÂ· of$sourceString whose index position (counting from one)is greater than or equal to the value of $start(rounded to an integer), and (if $length is specified)less than the sum of $start and $length(both rounded to integers). The characters returned do not extend beyond$sourceString. If $start is zero ornegative, only those characters in positions greater than zero arereturned. More specifically, the three argument version of the functionreturns the characters in $sourceString whose position$p satisfies: fn:round($start) <= $p <fn:round($start) + fn:round($length) The two argument version of the function assumes that$length is infinite and thus returns the Â·charactersÂ· in$sourceString whose position $psatisfies: fn:round($start) <=$p In the above computations, the rules for op:numeric-less-than andop:numeric-greater-thanapply. Notes The first character of a string is located at position 1, notposition 0. Examples The expression fn:substring("motor car", 6) returns" car". (Characters starting at position 6 to theend of $sourceString are selected.). The expression fn:substring("metadata", 4, 3)returns "ada". (Characters at positions greaterthan or equal to 4 and less than 7 are selected.). The expression fn:substring("12345", 1.5, 2.6)returns "234". (Characters at positions greaterthan or equal to 2 and less than 5 are selected.). The expression fn:substring("12345", 0, 3) returns"12". (Characters at positions greater than orequal to 0 and less than 3 are selected. Since the first positionis 1, these are the characters at positions 1 and 2.). The expression fn:substring("12345", 5, -3) returns"". (Characters at positions greater than or equalto 5 and less than 2 are selected.). The expression fn:substring("12345", -3, 5) returns"1". (Characters at positions greater than orequal to -3 and less than 2 are selected. Since the first positionis 1, this is the character at position 1.). The expression fn:substring("12345", 0 div 0E0, 3)returns "". (Since 0 div 0E0 returnsNaN, and NaN compared to any other numberreturns false, no characters are selected.). The expression fn:substring("12345", 1, 0 div 0E0)returns "". (As above.). The expression fn:substring((), 1, 3) returns"". The expression fn:substring("12345", -42, 1 div0E0) returns "12345". (Characters atpositions greater than or equal to -42 and less thanINF are selected.). The expression fn:substring("12345", -1 div 0E0, 1 div0E0) returns "". (Since the value of-INF + INF is NaN, no characters areselected.). 5.4.4fn:string-length Summary Returns the number of Â·charactersÂ· in a string. Signatures fn:string-length() as xs:integer fn:string-length($arg as xs:string?) as xs:integer Properties The zero-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The one-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns an xs:integer equal to thelength in Â·charactersÂ· of the value of $arg. Calling the zero-argument version of the function is equivalentto calling fn:string-length(fn:string(.)). If the value of $arg is the empty sequence, thefunction returns the xs:integer value zero (0). Error Conditions If $arg is not specified and the context item isabsentDM30,a dynamic error is raised: [err:XPDY0002]XP30. Notes Unlike some programming languages, a Â·codepointÂ· greaterthan 65535 counts as one character, not two. Examples The expression fn:string-length("Harp not on that string,madam; that is past.") returns 45. The expression fn:string-length(()) returns0. 5.4.5 fn:normalize-space Summary Returns the value of $arg with leading and trailingwhitespace removed, and sequences of internal whitespace reduced toa single space character. Signatures fn:normalize-space() as xs:string fn:normalize-space($arg as xs:string?) as xs:string Properties The zero-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The one-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the value of $arg is the empty sequence, thefunction returns the zero-length string. The function returns a string constructed by stripping leadingand trailing whitespace from the value of $arg, andreplacing sequences of one or more adjacent whitespace characterswith a single space, #x20. The whitespace characters are defined in the metasymbol S(Production 3) of [Extensible Markup Language (XML)1.0 (Fifth Edition)]. If no argument is supplied, then $arg defaults tothe string value (calculated using fn:string) of the context item(.). Error Conditions If no argument is supplied and the context item is absentDM30then a dynamic error is raised: [err:XPDY0002]XP30. Notes The definition of whitespace is unchanged in [Extensible Markup Language (XML) 1.1Recommendation]. Examples The expressionfn:normalize-space(" The wealthy curled darlings of our nation. ")returns "The wealthy curled darlings of ournation.". The expression fn:normalize-space(()) returns"". 5.4.6 fn:normalize-unicode Summary Returns the value of $arg after applying Unicodenormalization. Signatures fn:normalize-unicode($arg as xs:string?) as xs:string fn:normalize-unicode( $arg as xs:string?, $normalizationForm as xs:string) as xs:string Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the value of $arg is the empty sequence, thefunction returns the zero-length string. If the single-argument version of the function is used, theresult is the same as calling the two-argument version with$normalizationForm set to the string "NFC". Otherwise, the function returns the value of $argnormalized according to the rules of the normalization formidentified by the value of $normalizationForm. The effective value of $normalizationForm is thevalue of the expression fn:upper-case(fn:normalize-space($normalizationForm)). If the effective value of $normalizationForm is"NFC", then the function returns the value of $argconverted to Unicode Normalization Form C (NFC). If the effective value of $normalizationForm is"NFD", then the function returns the value of $argconverted to Unicode Normalization Form D (NFD). If the effective value of $normalizationForm is"NFKC", then the function returns the value of $arg inUnicode Normalization Form KC (NFKC). If the effective value of $normalizationForm is"NFKD", then the function returns the value of $argconverted to Unicode Normalization Form KD (NFKD). If the effective value of $normalizationForm is"FULLY-NORMALIZED", then the function returns the value of$arg converted to fully normalized form. If the effective value of $normalizationForm is thezero-length string, no normalization is performed and$arg is returned. Normalization forms NFC, NFD, NFKC, and NFKD, and the algorithmsto be used for converting a string to each of these forms, aredefined in [Unicode NormalizationForms]. The motivation for normalization form FULLY-NORMALIZED isexplained in [Character Model forthe World Wide Web 1.0: Normalization]. However, as thatspecification did not progress beyond working draft status, thenormative specification is as follows: A string is fully-normalized if (a) it is innormalization form NFC as defined in [Unicode Normalization Forms], and (b)it does not start with a composing character. A composing character is a character that is one or both of thefollowing: the second character in the canonical decomposition mapping ofsome character that is not listed in the Composition ExclusionTable defined in [UnicodeNormalization Forms]; of non-zero canonical combining class (as defined in [The Unicode Standard]). A string is converted to FULLY-NORMALIZED form as follows: if the first character in the string is a composing character,prepend a single space (x20); convert the resulting string to normalization form NFC. Conforming implementations must supportnormalization form "NFC" and may supportnormalization forms "NFD", "NFKC", "NFKD", and "FULLY-NORMALIZED".They may also support other normalization formswith Â·implementation-definedÂ· semantics. It is Â·implementation-definedÂ· which version of Unicode (and therefore, ofthe normalization algorithms and their underlying data) issupported by the implementation. See [Unicode Normalization Forms] fordetails of the stability policy regarding changes to thenormalization rules in future versions of Unicode. If the inputstring contains codepoints that are unassigned in the relevantversion of Unicode, or for which no normalization rules aredefined, the fn:normalize-unicode function leaves suchcodepoints unchanged. If the implementation supports the requestednormalization form then it must be able to handleevery input string without raising an error. Error Conditions A dynamic error is raised [err:FOCH0003] if the effective value ofthe $normalizationForm argument is not one of thevalues supported by the implementation. 5.4.7fn:upper-case Summary Converts a string to upper case. Signature fn:upper-case($arg as xs:string?) as xs:string Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the value of $arg is the empty sequence, thezero-length string is returned. Otherwise, the function returns the value of $argafter translating every Â·characterÂ· to its upper-case correspondent as defined inthe appropriate case mappings section in the Unicode standard[The Unicode Standard]. For versions ofUnicode beginning with the 2.1.8 update, only locale-insensitivecase mappings should be applied. Beginning with version 3.2.0 (andlikely future versions) of Unicode, precise mappings are describedin default case operations, which are full case mappings in theabsence of tailoring for particular languages and environments.Every lower-case character that does not have an upper-casecorrespondent, as well as every upper-case character, is includedin the returned value in its original form. Notes Case mappings may change the length of a string. In general, thefn:upper-case and fn:lower-case functions are notinverses of each other: fn:lower-case(fn:upper-case($arg))is not guaranteed to return $arg, nor isfn:upper-case(fn:lower-case($arg)). The Latin smallletter dotless i (as used in Turkish) is perhaps the most prominentlower-case letter which will not round-trip. The Latin capitalletter i with dot above is the most prominent upper-case letterwhich will not round trip; there are others, such as Latin capitalletter Sharp S (#1E9E) which is introduced in Unicode 5.1. These functions may not always be linguistically appropriate(e.g. Turkish i without dot) or appropriate for the application(e.g. titlecase). In cases such as Turkish, a simple translationshould be used first. Because the function is not sensitive to locale, results willnot always match user expectations. In Quebec, for example, thestandard uppercase equivalent of "Ã¨" is "Ãˆ", while in metropolitanFrance it is more commonly "E"; only one of these is supported bythe functions as defined. Many characters of class Ll lack uppercase equivalents in theUnicode case mapping tables; many characters of class Lu lacklowercase equivalents. Examples The expression fn:upper-case("abCd0") returns"ABCD0". 5.4.8fn:lower-case Summary Converts a string to lower case. Signature fn:lower-case($arg as xs:string?) as xs:string Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the value of $arg is the empty sequence, thezero-length string is returned. Otherwise, the function returns the value of $argafter translating every Â·characterÂ· to its lower-case correspondent as defined inthe appropriate case mappings section in the Unicode standard[The Unicode Standard]. For versions ofUnicode beginning with the 2.1.8 update, only locale-insensitivecase mappings should be applied. Beginning with version 3.2.0 (andlikely future versions) of Unicode, precise mappings are describedin default case operations, which are full case mappings in theabsence of tailoring for particular languages and environments.Every upper-case character that does not have a lower-casecorrespondent, as well as every lower-case character, is includedin the returned value in its original form. Notes Case mappings may change the length of a string. In general, thefn:upper-case andfn:lower-case functions are not inverses of eachother: fn:lower-case(fn:upper-case($arg)) is notguaranteed to return $arg, nor is fn:upper-case(fn:lower-case($arg)).The Latin small letter dotless i (as used in Turkish) is perhapsthe most prominent lower-case letter which will not round-trip. TheLatin capital letter i with dot above is the most prominentupper-case letter which will not round trip; there are others, suchas Latin capital letter Sharp S (#1E9E) which is introduced inUnicode 5.1. These functions may not always be linguistically appropriate(e.g. Turkish i without dot) or appropriate for the application(e.g. titlecase). In cases such as Turkish, a simple translationshould be used first. Because the function is not sensitive to locale, results willnot always match user expectations. In Quebec, for example, thestandard uppercase equivalent of "Ã¨" is "Ãˆ", while in metropolitanFrance it is more commonly "E"; only one of these is supported bythe functions as defined. Many characters of class Ll lack uppercase equivalents in theUnicode case mapping tables; many characters of class Lu lacklowercase equivalents. Examples The expression fn:lower-case("ABc!D") returns"abc!d". 5.4.9fn:translate Summary Returns the value of $arg modified by replacing orremoving individual characters. Signature fn:translate( $arg as xs:string?, $mapString as xs:string, $transString as xs:string) as xs:string Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the value of $arg is the empty sequence, thefunction returns the zero-length string. Otherwise, the function returns a result string constructed byprocessing each Â·characterÂ· in the value of $arg, in order,according to the following rules: If the character does not appear in the value of$mapString then it is added to the result stringunchanged. If the character first appears in the value of$mapString at some position M, where thevalue of $transString is M or more charactersin length, then the character at position M in$transString is added to the result string. If the character first appears in the value of$mapString at some position M, where thevalue of $transString is less than Mcharacters in length, then the character is omitted from the resultstring. Notes If $mapString is the zero-length string then thefunction returns $arg unchanged. If a character occurs more than once in $mapString,then the first occurrence determines the action taken. If $transString is longer than$mapString, the excess characters are ignored. Examples The expression fn:translate("bar","abc","ABC")returns "BAr". The expression fn:translate("--aaa--","abc-","ABC")returns "AAA". The expression fn:translate("abcdabc", "abc", "AB")returns "ABdAB". 5.5Functions based on substring matching The functions described in the section examine a string$arg1 to see whether it contains another string$arg2 as a substring. The result depends on whether$arg2 is a substring of $arg1, and if so,on the range of Â·charactersÂ· in $arg1 which $arg2matches. When the Â·Unicodecodepoint collationÂ· is used, thissimply involves determining whether $arg1 contains acontiguous sequence of characters whose Â·codepointsÂ· are thesame, one for one, with the codepoints of the characters in$arg2. When a collation is specified, the rules are more complex. All collations support the capability of deciding whether twoÂ·stringsÂ· areconsidered equal, and if not, which of the strings should beregarded as preceding the other. For functions such as fn:compare, this is all that isrequired. For other functions, such as fn:contains, the collation needsto support an additional property: it must be able to decompose thestring into a sequence of collation units, each unit consisting ofone or more characters, such that two strings can be compared bypairwise comparison of these units. ("collation unit" is equivalentto "collation element" as defined in [Unicode Collation Algorithm].) Thestring $arg1 is then considered to contain$arg2 as a substring if the sequence of collationunits corresponding to $arg2 is a subsequence of thesequence of the collation units corresponding to$arg1. The characters in $arg1 that matchare the characters corresponding to these collation units. This rule may occasionally lead to surprises. For example,consider a collation that treats "Jaeger" and "JÃ¤ger" as equal. Itmight do this by treating "Ã¤" as representing two collation units,in which case the expression fn:contains("JÃ¤ger", "eg") willreturn true. Alternatively, a collation might treat"ae" as a single collation unit, in which case the expressionfn:contains("Jaeger","eg") will return false. The results ofthese functions thus depend strongly on the properties of thecollation that is used. In addition, collations may specify that some collation unitsshould be ignored during matching. If hyphen is an ignoredcollation unit, then fn:contains("code-point","codepoint") will be true, and fn:contains("codepoint", "-")will also be true. In the definitions below, we refer to the terms match andminimal match as defined in definitions DS2 and DS4 of[Unicode Collation Algorithm]. Inapplying these definitions: C is the collation; that is, the value of the$collation argument if specified, otherwise thedefault collation. P is the (candidate) substring $arg2 Q is the (candidate) containing string$arg1 The boundary condition B is satisfied at the startand end of a string, and between any two characters that belong todifferent collation units ("collation elements" in the language of[Unicode Collation Algorithm]).It is not satisfied between two characters that belong to the samecollation unit. It is possible to define collations that do not have the abilityto decompose a string into units suitable for substring matching.An argument to a function defined in this section may be a URI thatidentifies a collation that is able to compare two strings, butthat does not have the capability to split the string intocollation units. Such a collation may cause the function to fail,or to give unexpected results or it may be rejected as anunsuitable argument. The ability to decompose strings intocollation units is an Â·implementation-definedÂ· property of the collation. Function Meaning fn:contains Returns true if the string $arg1 contains$arg2 as a substring, taking collations intoaccount. fn:starts-with Returns true if the string $arg1 contains$arg2 as a leading substring, taking collations intoaccount. fn:ends-with Returns true if the string $arg1 contains$arg2 as a trailing substring, taking collations intoaccount. fn:substring-before Returns the part of $arg1 that precedes the firstoccurrence of $arg2, taking collations intoaccount. fn:substring-after Returns the part of $arg1 that follows the firstoccurrence of $arg2, taking collations intoaccount. 5.5.1fn:contains Summary Returns true if the string $arg1 contains$arg2 as a substring, taking collations intoaccount. Signatures fn:contains($arg1 as xs:string?,$arg2 as xs:string?) as xs:boolean fn:contains( $arg1 as xs:string?, $arg2 as xs:string?, $collation as xs:string) as xs:boolean Properties The two-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations. The three-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations, and static base uri. Rules If the value of $arg1 or $arg2 is theempty sequence, or contains only ignorable collation units, it isinterpreted as the zero-length string. If the value of $arg2 is the zero-length string,then the function returns true. If the value of $arg1 is the zero-length string,the function returns false. The collation used by this function is determined according tothe rules in 5.3.3 Choosing acollation. The function returns an xs:boolean indicatingwhether or not the value of $arg1 contains (at thebeginning, at the end, or anywhere within) at least one sequence ofcollation units that provides a minimal match to thecollation units in the value of $arg2, according tothe collation that is used. Note: Minimal match is defined in [Unicode Collation Algorithm]. Error Conditions A dynamic error may be raised[err:FOCH0004] ifthe specified collation does not support collation units. Examples The collation used in these examples,http://example.com/CollationA is a collation in whichboth "-" and "*" are ignorable collation units. "Ignorable collation unit" is equivalent to "ignorable collationelement" in [Unicode CollationAlgorithm]. The expression fn:contains ( "tattoo", "t") returnstrue(). The expression fn:contains ( "tattoo", "ttt")returns false(). The expression fn:contains ( "", ()) returnstrue(). (The first rule is applied, followed bythe second rule.). The expression fn:contains ( "abcdefghi", "-d-e-f-","http://example.com/CollationA") returnstrue(). The expression fn:contains ( "a*b*c*d*e*f*g*h*i*","d-ef-", "http://example.com/CollationA") returnstrue(). The expression fn:contains ( "abcd***e---f*--*ghi", "def","http://example.com/CollationA") returnstrue(). The expression fn:contains ( (), "--***-*---","http://example.com/CollationA") returnstrue(). (The second argument contains onlyignorable collation units and is equivalent to the zero-lengthstring.). 5.5.2fn:starts-with Summary Returns true if the string $arg1 contains$arg2 as a leading substring, taking collations intoaccount. Signatures fn:starts-with($arg1 as xs:string?,$arg2 as xs:string?) as xs:boolean fn:starts-with( $arg1 as xs:string?, $arg2 as xs:string?, $collation as xs:string) as xs:boolean Properties The two-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations. The three-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations, and static base uri. Rules If the value of $arg1 or $arg2 is theempty sequence, or contains only ignorable collation units, it isinterpreted as the zero-length string. If the value of $arg2 is the zero-length string,then the function returns true. If the value of$arg1 is the zero-length string and the value of$arg2 is not the zero-length string, then the functionreturns false. The collation used by this function is determined according tothe rules in 5.3.3 Choosing acollation. The function returns an xs:boolean indicatingwhether or not the value of $arg1 starts with asequence of collation units that provides a match to thecollation units of $arg2 according to the collationthat is used. Note: Match is defined in [Unicode Collation Algorithm]. Error Conditions A dynamic error may be raised[err:FOCH0004] ifthe specified collation does not support collation units. Examples The collation used in these examples,http://example.com/CollationA is a collation in whichboth "-" and "*" are ignorable collation units. "Ignorable collation unit" is equivalent to "ignorable collationelement" in [Unicode CollationAlgorithm]. The expression fn:starts-with("tattoo", "tat")returns true(). The expression fn:starts-with ( "tattoo", "att")returns false(). The expression fn:starts-with ((), ()) returnstrue(). The expression fn:starts-with ( "abcdefghi", "-a-b-c-","http://example.com/CollationA") returnstrue(). The expression fn:starts-with ( "a*b*c*d*e*f*g*h*i*","a-bc-", "http://example.com/CollationA") returnstrue(). The expression fn:starts-with ( "abcd***e---f*--*ghi","abcdef", "http://example.com/CollationA") returnstrue(). The expression fn:starts-with ( (), "--***-*---","http://example.com/CollationA") returnstrue(). (The second argument contains onlyignorable collation units and is equivalent to the zero-lengthstring.). The expression fn:starts-with ( "-abcdefghi", "-abc","http://example.com/CollationA") returnstrue(). 5.5.3fn:ends-with Summary Returns true if the string $arg1 contains$arg2 as a trailing substring, taking collations intoaccount. Signatures fn:ends-with($arg1 as xs:string?,$arg2 as xs:string?) as xs:boolean fn:ends-with( $arg1 as xs:string?, $arg2 as xs:string?, $collation as xs:string) as xs:boolean Properties The two-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations. The three-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations, and static base uri. Rules If the value of $arg1 or $arg2 is theempty sequence, or contains only ignorable collation units, it isinterpreted as the zero-length string. If the value of $arg2 is the zero-length string,then the function returns true. If the value of$arg1 is the zero-length string and the value of$arg2 is not the zero-length string, then the functionreturns false. The collation used by this function is determined according tothe rules in 5.3.3 Choosing acollation. The function returns an xs:boolean indicatingwhether or not the value of $arg1 starts with asequence of collation units that provides a match to thecollation units of $arg2 according to the collationthat is used. Note: Match is defined in [Unicode Collation Algorithm]. Error Conditions A dynamic error may be raised[err:FOCH0004] ifthe specified collation does not support collation units. Examples The collation used in these examples,http://example.com/CollationA is a collation in whichboth "-" and "*" are ignorable collation units. "Ignorable collation unit" is equivalent to "ignorable collationelement" in [Unicode CollationAlgorithm]. The expression fn:ends-with ( "tattoo", "tattoo")returns true(). The expression fn:ends-with ( "tattoo", "atto")returns false(). The expression fn:ends-with ((), ()) returnstrue(). The expression fn:ends-with ( "abcdefghi", "-g-h-i-","http://example.com/CollationA") returnstrue(). The expression fn:ends-with ( "abcd***e---f*--*ghi","defghi", "http://example.com/CollationA") returnstrue(). The expression fn:ends-with ( "abcd***e---f*--*ghi","defghi", "http://example.com/CollationA") returnstrue(). The expression fn:ends-with ( (), "--***-*---","http://example.com/CollationA") returnstrue(). (The second argument contains onlyignorable collation units and is equivalent to the zero-lengthstring.). The expression fn:ends-with ( "abcdefghi", "ghi-","http://example.com/CollationA") returnstrue(). 5.5.4 fn:substring-before Summary Returns the part of $arg1 that precedes the firstoccurrence of $arg2, taking collations intoaccount. Signatures fn:substring-before($arg1 as xs:string?,$arg2 as xs:string?) as xs:string fn:substring-before( $arg1 as xs:string?, $arg2 as xs:string?, $collation as xs:string) as xs:string Properties The two-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations. The three-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations, and static base uri. Rules If the value of $arg1 or $arg2 is theempty sequence, or contains only ignorable collation units, it isinterpreted as the zero-length string. If the value of $arg2 is the zero-length string,then the function returns the zero-length string. If the value of $arg1 does not contain a stringthat is equal to the value of $arg2, then the functionreturns the zero-length string. The collation used by this function is determined according tothe rules in 5.3.3 Choosing acollation. The function returns the substring of the value of$arg1 that precedes in the value of $arg1the first occurrence of a sequence of collation units that providesa minimal match to the collation units of $arg2according to the collation that is used. Note: Minimal match is defined in [Unicode Collation Algorithm]. Error Conditions A dynamic error may be raised[err:FOCH0004] ifthe specified collation does not support collation units. Examples The collation used in these examples,http://example.com/CollationA is a collation in whichboth "-" and "*" are ignorable collation units. "Ignorable collation unit" is equivalent to "ignorable collationelement" in [Unicode CollationAlgorithm]. The expression fn:substring-before ( "tattoo","attoo") returns "t". The expression fn:substring-before ( "tattoo","tatto") returns "". The expression fn:substring-before ((), ()) returns"". The expression fn:substring-before ( "abcdefghi","--d-e-", "http://example.com/CollationA") returns"abc". The expression fn:substring-before ( "abc--d-e-fghi","--d-e-", "http://example.com/CollationA") returns"abc--". The expression fn:substring-before ( "a*b*c*d*e*f*g*h*i*","***cde", "http://example.com/CollationA") returns"a*b*". The expression fn:substring-before ( "Eureka!","--***-*---", "http://example.com/CollationA") returns"". (The second argument contains only ignorablecollation units and is equivalent to the zero-lengthstring.). 5.5.5 fn:substring-after Summary Returns the part of $arg1 that follows the firstoccurrence of $arg2, taking collations intoaccount. Signatures fn:substring-after($arg1 as xs:string?,$arg2 as xs:string?) as xs:string fn:substring-after( $arg1 as xs:string?, $arg2 as xs:string?, $collation as xs:string) as xs:string Properties The two-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations. The three-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations, and static base uri. Rules If the value of $arg1 or $arg2 is theempty sequence, or contains only ignorable collation units, it isinterpreted as the zero-length string. If the value of $arg2 is the zero-length string,then the function returns the value of $arg1. If the value of $arg1 does not contain a stringthat is equal to the value of $arg2, then the functionreturns the zero-length string. The collation used by this function is determined according tothe rules in 5.3.3 Choosing acollation. The function returns the substring of the value of$arg1 that follows in the value of $arg1the first occurrence of a sequence of collation units that providesa minimal match to the collation units of $arg2according to the collation that is used. Note: Minimal match is defined in [Unicode Collation Algorithm]. Error Conditions A dynamic error may be raised[err:FOCH0004] ifthe specified collation does not support collation units. Examples The collation used in these examples,http://example.com/CollationA is a collation in whichboth "-" and "*" are ignorable collation units. "Ignorable collation unit" is equivalent to "ignorable collationelement" in [Unicode CollationAlgorithm]. The expression fn:substring-after("tattoo", "tat")returns "too". The expression fn:substring-after("tattoo","tattoo") returns "". The expression fn:substring-after((), ()) returns"". The expression fn:substring-after("abcdefghi", "--d-e-","http://example.com/CollationA") returns"fghi". The expression fn:substring-after("abc--d-e-fghi","--d-e-", "http://example.com/CollationA") returns"-fghi". The expression fn:substring-after ( "a*b*c*d*e*f*g*h*i*","***cde***", "http://example.com/CollationA") returns"*f*g*h*i*". The expression fn:substring-after ( "Eureka!","--***-*---", "http://example.com/CollationA") returns"Eureka!". (The second argument contains onlyignorable collation units and is equivalent to the zero-lengthstring.). 5.6 Stringfunctions that use regular expressions The three functions described in this section make use of aregular expression syntax for pattern matching. This is describedbelow. Function Meaning fn:matches Returns true if the supplied string matches a given regularexpression. fn:replace Returns a string produced from the input string by replacingany substrings that match a given regular expression with asupplied replacement string. fn:tokenize Returns a sequence of strings constructed by splitting theinput wherever a separator is found; the separator is any substringthat matches a given regular expression. fn:analyze-string Analyzes a string using a regular expression, returning an XMLstructure that identifies which parts of the input string matchedor failed to match the regular expression, and in the case ofmatched substrings, which substrings matched each capturing groupin the regular expression. 5.6.1 Regularexpression syntax The regular expression syntax used by these functions is definedin terms of the regular expression syntax specified in XML Schema(see [XML Schema Part 2: Datatypes SecondEdition]), which in turn is based on the establishedconventions of languages such as Perl. However, because XML Schemauses regular expressions only for validity checking, it omits somefacilities that are widely-used with languages such as Perl. Thissection, therefore, describes extensions to the XML Schema regularexpressions syntax that reinstate these capabilities. Note: It is recommended that implementers consult [Unicode Regular Expressions] for informationon using regular expression processing on Unicode characters. The regular expression syntax and semantics are identical tothose defined in [XML Schema Part 2:Datatypes Second Edition] with the following additions: Two meta-characters, ^ and $ areadded. By default, the meta-character ^ matches thestart of the entire string, while $ matches the end ofthe entire string. In multi-line mode, ^ matches thestart of any line (that is, the start of the entire string, and theposition immediately after a newline character), while$ matches the end of any line (that is, the end of theentire string, and the position immediately before a newlinecharacter). Newline here means the character #x0Aonly. This means that the production in [XMLSchema Part 2: Datatypes Second Edition]: [10] Char ::= [^.\?*+()|#x5B#x5D] is modified to read: [10] Char ::= [^.\?*+{}()|^$#x5B#x5D] The XSD 1.1 grammar for regular expressions uses the sameproduction rule, but renumbered and renamed [73]NormalChar; it is affected in the same way. The characters #x5B and #x5Dcorrespond to "[" and "]"respectively. Note: The definition of Char (production [10]) in [XML Schema Part 2: Datatypes Second Edition]has a known error in which it omits the left brace ("{") and rightbrace ("}"). That error is corrected here. The following production: [11] charClass ::= charClassEsc | charClassExpr |WildCardEsc is modified to read: [11] charClass ::= charClassEsc | charClassExpr |WildCardEsc | "^" | "$" Using XSD 1.1 as the baseline the equivalent is to change theproduction: [74] charClass ::= SingleCharEsc | charClassEsc |charClassExpr | WildCardEsc to read: [74] charClass ::= SingleCharEsc | charClassEsc |charClassExpr | WildCardEsc | "^" | "$" Reluctant quantifiers are supported. They are indicatedby a " ? " following a quantifier. Specifically: X?? matches X, once or not at all X*? matches X, zero or more times X+? matches X, one or more times X{n}? matches X, exactly n times X{n,}? matches X, at least n times X{n,m}? matches X, at least n times, but not morethan m times The effect of these quantifiers is that the regular expressionmatches the shortest possible substring consistent withthe match as a whole succeeding. Without the " ? ",the regular expression matches the longest possiblesubstring. To achieve this, the production in [XMLSchema Part 2: Datatypes Second Edition]: [4] quantifier ::= [?*+] | ( '{' quantity '}' ) is changed to: [4] quantifier ::= ( [?*+] | ( '{' quantity '}' ) )'?'? (In the XSD 1.1 version of the regular expression grammar, thisrule is unchanged, but is renumbered [67]) Note: Reluctant quantifiers have no effect on the results of theboolean fn:matchesfunction, since this function is only interested in discoveringwhether a match exists, and not where it exists. Sub-expressions (groups) within the regular expression arerecognized. The regular expression syntax defined by [XML Schema Part 2: Datatypes Second Edition]allows a regular expression to contain parenthesizedsub-expressions, but attaches no special significance to them.Some operations associated with regular expressions (forexample, back-references, and the fn:replace function) allow accessto the parts of the input string that matched a sub-expression(called captured substrings). The sub-expressions arenumbered according to the position of the opening parenthesis inleft-to-right order within the top-level regular expression: thefirst opening parenthesis identifies captured substring 1, thesecond identifies captured substring 2, and so on. 0 identifies thesubstring captured by the entire regular expression. When parentheses are used in a part of the regular expressionthat is matched more than once (because it is within a constructthat allows repetition), then only the last substring that itmatched will be captured. Note that this rule is not sufficient inall cases to ensure an unambiguous result, especially in caseswhere (a) the regular expression contains nested repeatingconstructs, and/or (b) the repeating construct matches azero-length string. In such cases it is implementation-dependentwhich substring is captured. For example given the regularexpression (a*)+ and the input string"aaaa", an implementation might legitimately captureeither "aaaa" or a zero length string as the contentof the captured subgroup. Non-capturing groups are also recognized. These are indicated bythe syntax (?:xxxx). The production rule foratom in [XML Schema Part 2:Datatypes Second Edition] is changed to replace thealternative: ( '(' regExp ')' ) with: ( '(' '?:'? regExp ')' ) (For the new versions of the XSD 1.0 and XSD 1.1 productionrules for atom, see below.) The presence of the optional ?: has no effect onthe set of strings that match the regular expression, but causesthe left parenthesis not to be counted by operations that numberthe groups within a regular expression, for example the fn:replace function. Back-references are allowed outside a character classexpression. A back-reference is an additional kind of atom.The construct \N where N is a singledigit is always recognized as a back-reference; if this is followedby further digits, these digits are taken to be part of theback-reference if and only if the resulting numberNN is such that the back-reference is preceded byNN or more unescaped opening parentheses. The regularexpression is invalid if a back-reference refers to a subexpressionthat does not exist or whose closing right parenthesis occurs afterthe back-reference. A back-reference matches the string that was matched by theNth capturing subexpression within the regularexpression, that is, the parenthesized subexpression whose openingleft parenthesis is the Nth unescaped left parenthesiswithin the regular expression. For example, the regular expression('|").*\1 matches a sequence of characters delimitedeither by an apostrophe at the start and end, or by a quotationmark at the start and end. If no string is matched by the Nth capturingsubexpression, the back-reference is interpreted as matching azero-length string. Combining this change with the introduction of non-capturinggroups (see above), back-references change the followingproduction: [9] atom ::= Char | charClass | ( '(' regExp ')') to [9] atom ::= Char | charClass | ( '(' '?:'? regExp')' ) | backReference [9a] backReference ::= "\"[1-9][0-9]* With respect to the XSD 1.1 version of the regular expressiongrammar, the effect is to change: [72] atom ::= NormalChar | charClass | ( '(' regExp')' ) to [72] atom ::= NormalChar | charClass | ( '(' '?:'?regExp ')' ) | backReference [72a] backReference ::= "\"[1-9][0-9]* Note: Within a character class expression, \followed by a digit is invalid. Some other regular expressionlanguages interpret this as an octal characterreference. Single character escapes are extended to allow the$ character to be escaped. The following production ischanged: [24]SingleCharEsc ::= '\'[nrt\|.?*+(){}#x2D#x5B#x5D#x5E] to [24]SingleCharEsc ::= '\'[nrt\|.?*+(){}$#x2D#x5B#x5D#x5E] (In the XSD 1.1 version of the regular expression grammar, theproduction rule for SingleCharEsc is unchanged, but isrenumbered [84]) A regular expression that uses a Unicode block name that is notdefined in the version(s) of Unicode supported by the processor(for example \p{IsBadBlockName}) is deemed to beinvalid [err:FORX0002]. Note: XSD 1.0 does not say how this situation should be handled; XSD1.1 says that it should be handled by treating all characters asmatching. Note: In [Schema 1.1 Part 2] the rulesfor the interpretation of hyphens within square brackets in aregular expression have been clarified; and the semantics ofregular expressions are no longer tied to a specific version ofUnicode. 5.6.1.1 Flags All these functions provide an optional parameter,$flags, to set options for the interpretation of theregular expression. The parameter accepts a xs:string,in which individual letters are used to set options. The presenceof a letter within the string indicates that the option is on; itsabsence indicates that the option is off. Letters may appear in anyorder and may be repeated. If there are characters present that arenot defined here as flags, then a dynamic error israised [err:FORX0001]. The following options are defined: s: If present, the match operates in "dot-all"mode. (Perl calls this the single-line mode.) If the sflag is not specified, the meta-character . matchesany character except a newline (#x0A) orcarriage return (#x0D) character. In dot-allmode, the meta-character . matches any characterwhatsoever. Suppose the input contains "hello" and "world" on twolines. This will not be matched by the regular expression"hello.*world" unless dot-all mode is enabled. m: If present, the match operates in multi-linemode. By default, the meta-character ^ matches thestart of the entire string, while $ matches the end of the entirestring. In multi-line mode, ^ matches the start of anyline (that is, the start of the entire string, and the positionimmediately after a newline character other than a newlinethat appears as the last character in the string), while$ matches the end of any line (that is, theposition immediately before a newline character, and the end of theentire string if there is no newline character at the end of thestring). Newline here means the character #x0Aonly. i: If present, the match operates incase-insensitive mode. The detailed rules are as follows. In theserules, a character C2 is considered to be a case-variantof another character C1 if the following XPath expression returnstrue when the two characters are considered as stringsof length one, and the Â·Unicode codepoint collationÂ· is used: fn:lower-case(C1) eqfn:lower-case(C2) or fn:upper-case(C1) eqfn:upper-case(C2) Note that the case-variants of a character under this definitionare always single characters. When a normal character (Char) is used as an atom,it represents the set containing that character and all itscase-variants. For example, the regular expression "z" will matchboth "z" and "Z". A character range (production charRange inthe XSD 1.0 grammar, replaced by productions charRangeand singleChar in XSD 1.1) represents the setcontaining all the characters that it would match in the absence ofthe "i" flag, together with their case-variants. Forexample, the regular expression "[A-Z]" will match all the lettersA-Z and all the letters a-z. It will also match certain othercharacters such as #x212A (KELVIN SIGN), sincefn:lower-case("#x212A")is "k". This rule applies also to a character range used in a characterclass subtraction (charClassSub): thus [A-Z-[IO]] willmatch characters such as "A", "B", "a", and "b", but will not match"I", "O", "i", or "o". The rule also applies to a character range used as part of anegative character group: thus [^Q] will match every characterexcept "Q" and "q" (these being the only case-variants of "Q" inUnicode). A back-reference is compared using case-blind comparison: thatis, each character must either be the same as the correspondingcharacter of the previously matched string, or must be acase-variant of that character. For example, the strings "Mum","mom", "Dad", and "DUD" all match the regular expression"([md])[aeiou]\1" when the "i" flag is used. All other constructs are unaffected by the "i"flag. For example, "\p{Lu}" continues to match upper-case lettersonly. x: If present, whitespace characters (#x9, #xA, #xDand #x20) in the regular expression are removed prior to matchingwith one exception: whitespace characters within character classexpressions (charClassExpr) are not removed. This flagcan be used, for example, to break up long regular expressions intoreadable lines. Examples: fn:matches("helloworld", "helloworld", "x") returns true() fn:matches("helloworld", "hello[]world", "x") returns false() fn:matches("hello world", "hello\sworld", "x") returns true() fn:matches("hello world", "helloworld", "x") returns false() q: if present, all characters in the regularexpression are treated as representing themselves, not asmetacharacters. In effect, every character that would normally havea special meaning in a regular expression is implicitly escaped bypreceding it with a backslash. Furthermore, when this flag is present, the characters$ and \ have no special significance whenused in the replacement string supplied to the fn:replace function. This flag can be used in conjunction with the iflag. If it is used together with the m,s, or x flag, that flag has noeffect. Examples: fn:tokenize("12.3.5.6", ".","q") returns ("12", "3", "5", "6") fn:replace("a\b\c", "\", "\\","q") returns "a\\b\\c" fn:replace("a/b/c", "/", "$","q") returns "a$b$c" fn:matches("abcd", ".*","q") returns false() fn:matches("Mr. B. Obama", "B.OBAMA", "iq") returns true() 5.6.2fn:matches Summary Returns true if the supplied string matches a given regularexpression. Signatures fn:matches($input as xs:string?,$pattern as xs:string) as xs:boolean fn:matches( $input as xs:string?, $pattern as xs:string, $flags as xs:string) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The effect of calling the first version of this function(omitting the argument $flags) is the same as theeffect of calling the second version with the $flagsargument set to a zero-length string. Flags are defined in 5.6.1.1 Flags. If $input is the empty sequence, it is interpretedas the zero-length string. The function returns true if $input orsome substring of $input matches the regularexpression supplied as $pattern. Otherwise, thefunction returns false. The matching rules areinfluenced by the value of $flags if present. Error Conditions A dynamic error is raised [err:FORX0002] if the value of$pattern is invalid according to the rules describedin 5.6.1 Regular expressionsyntax. A dynamic error is raised [err:FORX0001] if the value of$flags is invalid according to the rules described in5.6.1.1 Flags. Notes Unless the metacharacters ^ and $ areused as anchors, the string is considered to match the pattern ifany substring matches the pattern. But if anchors are used, theanchors must match the start/end of the string (in string mode), orthe start/end of a line (in multi-line mode). This is different from the behavior of patterns in [XML Schema Part 2: Datatypes Second Edition],where regular expressions are implicitly anchored. Regular expression matching is defined on the basis of Unicodecode points; it takes no account of collations. Examples The expression fn:matches("abracadabra", "bra")returns true(). The expression fn:matches("abracadabra", "^a.*a$")returns true(). The expression fn:matches("abracadabra", "^bra")returns false(). Given the source document: let $poem := <poem author="Wilhelm Busch"> Kaum hat dies der Hahn gesehen, FÃ¤ngt er auch schon an zu krÃ¤hen: Kikeriki! Kikikerikih!! Tak, tak, tak! - da kommen sie. </poem> the following function calls produce the following results, withthe poem element as the context node: The expression fn:matches($poem, "Kaum.*krÃ¤hen")returns false(). The expression fn:matches($poem, "Kaum.*krÃ¤hen","s") returns true(). The expression fn:matches($poem, "^Kaum.*gesehen,$","m") returns true(). The expression fn:matches($poem,"^Kaum.*gesehen,$") returns false(). The expression fn:matches($poem, "kiki", "i")returns true(). 5.6.3fn:replace Summary Returns a string produced from the input string by replacing anysubstrings that match a given regular expression with a suppliedreplacement string. Signatures fn:replace( $input as xs:string?, $pattern as xs:string, $replacement as xs:string) as xs:string fn:replace( $input as xs:string?, $pattern as xs:string, $replacement as xs:string, $flags as xs:string) as xs:string Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The effect of calling the first version of this function(omitting the argument $flags) is the same as theeffect of calling the second version with the $flagsargument set to a zero-length string. Flags are defined in 5.6.1.1 Flags. The $flags argument is interpreted in the samemanner as for the fn:matches function. If $input is the empty sequence, it is interpretedas the zero-length string. The function returns the xs:string that is obtainedby replacing each non-overlapping substring of $inputthat matches the given $pattern with an occurrence ofthe $replacement string. If two overlapping substrings of $input both matchthe $pattern, then only the first one (that is, theone whose first Â·characterÂ· comes first in the $input string)is replaced. If the q flag is present, the replacement string isused as is. Otherwise, within the $replacementstring, a variable $N may be used to refer to thesubstring captured by the Nth parenthesized sub-expression in theregular expression. For each match of the pattern, these variablesare assigned the value of the content matched by the relevantsub-expression, and the modified replacement string is thensubstituted for the Â·charactersÂ· in $input that matched thepattern. $0 refers to the substring captured by theregular expression as a whole. More specifically, the rules are as follows, whereS is the number of parenthesized sub-expressions inthe regular expression, and N is the decimal numberformed by taking all the digits that consecutively follow the$ character: If N=0, then the variable is replacedby the substring matched by the regular expression as a whole. If 1<=N<=S, thenthe variable is replaced by the substring captured by the Nthparenthesized sub-expression. If the Nth parenthesizedsub-expression was not matched, then the variable is replaced bythe zero-length string. If S<N<=9, then thevariable is replaced by the zero-length string. Otherwise (if N>S andN>9), the last digit of Nis taken to be a literal character to be included "as is" in thereplacement string, and the rules are reapplied using the numberN formed by stripping off this last digit. For example, if the replacement string is " $23 "and there are 5 substrings, the result contains the value of thesubstring that matches the second sub-expression, followed by thedigit " 3 ". Unless the q flag is used, a literal $character within the replacement string must be written as\$, and a literal \ character must bewritten as \\. If two alternatives within the pattern both match at the sameposition in the $input, then the match that is chosenis the one matched by the first alternative. For example:  fn:replace("abcd", "(ab)|(a)", "[1=$1][2=$2]") returns "[1=ab][2=]cd" Error Conditions A dynamic error is raised [err:FORX0002] if the value of$pattern is invalid according to the rules describedin section 5.6.1 Regular expressionsyntax. A dynamic error is raised [err:FORX0001] if the value of$flags is invalid according to the rules described insection 5.6.1 Regular expressionsyntax. A dynamic error is raised [err:FORX0003] if the pattern matches azero-length string, that is, if the expression fn:matches("", $pattern, $flags)returns true. It is not an error, however, if acaptured substring is zero-length. A dynamic error is raised [err:FORX0004] if the value of$replacement contains a "$" characterthat is not immediately followed by a digit 0-9 andnot immediately preceded by a "\". A dynamic error is raised [err:FORX0004] if the value of$replacement contains a "\" characterthat is not part of a "\\" pair, unless it isimmediately followed by a "$" character. Notes If the input string contains no substring that matches theregular expression, the result of the function is a single stringidentical to the input string. Examples The expression replace("abracadabra", "bra", "*")returns "a*cada*". The expression replace("abracadabra", "a.*a", "*")returns "*". The expression replace("abracadabra", "a.*?a", "*")returns "*c*bra". The expression replace("abracadabra", "a", "")returns "brcdbr". The expression replace("abracadabra", "a(.)","a$1$1") returns "abbraccaddabbra". The expression replace("abracadabra", ".*?", "$1")raises an error, because the pattern matches the zero-lengthstring The expression replace("AAAA", "A+", "b") returns"b". The expression replace("AAAA", "A+?", "b") returns"bbbb". The expression replace("darted", "^(.*?)d(.*)$","$1c$2") returns "carted". (The firstd is replaced.). 5.6.4fn:tokenize Summary Returns a sequence of strings constructed by splitting the inputwherever a separator is found; the separator is any substring thatmatches a given regular expression. Signatures fn:tokenize($input as xs:string?,$pattern as xs:string) as xs:string* fn:tokenize( $input as xs:string?, $pattern as xs:string, $flags as xs:string) as xs:string* Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The effect of calling the first version of this function(omitting the argument $flags) is the same as theeffect of calling the second version with the $flagsargument set to a zero-length string. Flags are defined in 5.6.1.1 Flags. The $flags argument is interpreted in the same wayas for the fn:matchesfunction. If $input is the empty sequence, or if$input is the zero-length string, the function returnsthe empty sequence. The function returns a sequence of strings formed by breakingthe $input string into a sequence of strings, treatingany substring that matches $pattern as a separator.The separators themselves are not returned. If a separator occurs at the start of the $inputstring, the result sequence will start with a zero-length string.Zero-length strings will also occur in the result sequence if aseparator occurs at the end of the $input string, orif two adjacent substrings match the supplied$pattern. If two alternatives within the supplied $patternboth match at the same position in the $input string,then the match that is chosen is the first. For example:  fn:tokenize("abracadabra", "(ab)|(a)") returns ("", "r", "c", "d", "r", "") Error Conditions A dynamic error is raised [err:FORX0002] if the value of$pattern is invalid according to the rules describedin section 5.6.1 Regular expressionsyntax. A dynamic error is raised [err:FORX0001] if the value of$flags is invalid according to the rules described insection 5.6.1 Regular expressionsyntax. A dynamic error is raised [err:FORX0003] if the supplied$pattern matches a zero-length string, that is, iffn:matches("", $pattern,$flags) returns true. Notes If the input string is not zero length, and no separators arefound in the input string, the result of the function is a singlestring identical to the input string. Examples The expression fn:tokenize("The cat sat on the mat","\s+") returns ("The", "cat", "sat", "on", "the","mat"). The expression fn:tokenize("1, 15, 24, 50", ",\s*")returns ("1", "15", "24", "50"). The expression fn:tokenize("1,15,,24,50,", ",")returns ("1", "15", "", "24", "50", ""). fn:tokenize("abba", ".?") raises thedynamic error [err:FORX0003]. The expression fn:tokenize("Some unparsed <br> HTML<BR> text", "\s*<br>\s*", "i") returns("Some unparsed", "HTML", "text"). 5.6.5 fn:analyze-string Summary Analyzes a string using a regular expression, returning an XMLstructure that identifies which parts of the input string matchedor failed to match the regular expression, and in the case ofmatched substrings, which substrings matched each capturing groupin the regular expression. Signatures fn:analyze-string( $input as xs:string?, $pattern as xs:string) as element(fn:analyze-string-result) fn:analyze-string( $input as xs:string?, $pattern as xs:string, $flags as xs:string) as element(fn:analyze-string-result) Properties This function is Â·nondeterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The effect of calling the first version of this function(omitting the argument $flags) is the same as theeffect of calling the second version with the $flagsargument set to a zero-length string. Flags are defined in 5.6.1.1 Flags. The $flags argument is interpreted in the same wayas for the fn:matchesfunction. If $input is the empty sequence the functionbehaves as if $input were the zero-length string. Inthis situation the result will be an element node with nochildren. The function returns an element node whose local name isanalyze-string-result. This element and all itsdescendant elements have the namespace URIhttp://www.w3.org/2005/xpath-functions. The namespaceprefix is Â·implementation dependentÂ·. The children of this element are a sequenceof fn:match and fn:non-match elements.This sequence is formed by breaking the $input stringinto a sequence of strings, returning any substring that matches$pattern as the content of a matchelement, and any intervening substring as the content of anon-match element. More specifically, the function starts at the beginning of theinput string and attempts to find the first substring that matchesthe regular expression. If there are several matches, the firstmatch is defined to be the one whose starting position comes firstin the string. If several alternatives within the regularexpression both match at the same position in the input string,then the match that is chosen is the first alternative thatmatches. For example, if the input string is The quick brownfox jumps and the regular expression isjump|jumps, then the match that is chosen isjump. Having found the first match, the instruction proceeds to findthe second and subsequent matches by repeating the search, startingat the first Â·characterÂ· that was not included in the previousmatch. The input string is thus partitioned into a sequence ofsubstrings, some of which match the regular expression, otherswhich do not match it. Each substring will contain at least onecharacter. This sequence is represented in the result by thesequence of fn:match and fn:non-matchchildren of the returned element node; the string value of thefn:match or fn:non-match element will bethe corresponding substring of $input, and the stringvalue of the returned element node will therefore be the same as$input. The content of an fn:non-match element is always asingle text node. The content of a fn:match element, however, is ingeneral a sequence of text nodes and fn:group elementchildren. An fn:group element with a nrattribute having the integer value N identifies thesubstring captured by the Nth parenthesizedsub-expression in the regular expression. For each capturingsubexpression there will be at most one correspondingfn:group element in each fn:match elementin the result. If the function is called twice with the same arguments, it isÂ·implementation dependentÂ· whether the two calls return the same elementnode or distinct (but deep equal) element nodes. In this respect itis Â·nondeterministicÂ·. The base URI of the element nodes in the result is Â·implementation dependentÂ· A schema is defined for the structure of the returned element,containing the definitions below. The returned element and itsdescendants will have type annotations obtained by validating thereturned element against this schema, unless the function is usedin an environment where type annotations are not supported (forexample, a Basic XSLT Processor), in which case the elements willall be annotated as xs:untyped and the attributes asxs:untypedAtomic. Note: A free-standing copy of this schema can be found at analyze-string.xsd <?xml version="1.0" encoding="UTF-8"?><xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"    targetNamespace="http://www.w3.org/2005/xpath-functions"    xmlns:fn="http://www.w3.org/2005/xpath-functions"    elementFormDefault="qualified">     <xs:element name="analyze-string-result" type="fn:analyze-string-result-type"/>    <xs:element name="match" type="fn:match-type"/>    <xs:element name="non-match" type="xs:string"/>    <xs:element name="group" type="fn:group-type"/>        <xs:complexType name="analyze-string-result-type" mixed="true">        <xs:choice minOccurs="0" maxOccurs="unbounded">            <xs:element ref="fn:match"/>            <xs:element ref="fn:non-match"/>        </xs:choice>    </xs:complexType>            <xs:complexType name="match-type" mixed="true">        <xs:sequence>            <xs:element ref="fn:group" minOccurs="0" maxOccurs="unbounded"/>        </xs:sequence>    </xs:complexType>        <xs:complexType name="group-type" mixed="true">        <xs:sequence>            <xs:element ref="fn:group" minOccurs="0" maxOccurs="unbounded"/>        </xs:sequence>        <xs:attribute name="nr" type="xs:positiveInteger"/>    </xs:complexType>     </xs:schema> Error Conditions A dynamic error is raised [err:FORX0002] if the value of$pattern is invalid according to the rules describedin section 5.6.1 Regular expressionsyntax. A dynamic error is raised [err:FORX0001] if the value of$flags is invalid according to the rules described insection 5.6.1 Regular expressionsyntax. A dynamic error is raised [err:FORX0003] if the supplied$pattern matches a zero-length string, that is, iffn:matches("", $pattern,$flags) returns true. Notes The declarations and definitions in the above schema are notautomatically available in the static context of thefn:analyze-string call (or of any other expression).The contents of the static context are host-language defined, andin some host languages are implementation-defined. Examples In the following examples, the result document is shown inserialized form, with whitespace between the element nodes. Thiswhitespace is not actually present in the result. The expression fn:analyze-string("The cat sat on themat.", "\w+") returns (with whitespace added forlegibility): <analyze-string-result xmlns="http://www.w3.org/2005/xpath-functions">  <match>The</match>  <non-match> </non-match>  <match>cat</match>  <non-match> </non-match>  <match>sat</match>  <non-match> </non-match>  <match>on</match>  <non-match> </non-match>  <match>the</match>  <non-match> </non-match>  <match>mat</match>  <non-match>.</non-match></analyze-string-result> The expression fn:analyze-string("2008-12-03","^(\d+)\-(\d+)\-(\d+)$") returns (with whitespace added forlegibility): <analyze-string-result xmlns="http://www.w3.org/2005/xpath-functions">  <match><group nr="1">2008</group>-<group nr="2">12</group>-<group nr="3">03</group></match></analyze-string-result> The expression fn:analyze-string("A1,C15,,D24, X50,","([A-Z])([0-9]+)") returns (with whitespace added forlegibility): <analyze-string-result xmlns="http://www.w3.org/2005/xpath-functions">                    <match><group nr="1">A</group><group nr="2">1</group></match>  <non-match>,</non-match>  <match><group nr="1">C</group><group nr="2">15</group></match>  <non-match>,,</non-match>  <match><group nr="1">D</group><group nr="2">24</group></match>  <non-match>, </non-match>  <match><group nr="1">X</group><group nr="2">50</group></match>  <non-match>,</non-match></analyze-string-result> 6Functions that manipulate URIs This section specifies functions that manipulate URI values,either as instances of xs:anyURI or as strings. Function Meaning fn:resolve-uri Resolves a relative IRI reference against an absolute IRI. fn:encode-for-uri Encodes reserved characters in a string that is intended to beused in the path segment of a URI. fn:iri-to-uri Converts a string containing an IRI into a URI according to therules of [RFC 3987]. fn:escape-html-uri Escapes a URI in the same way that HTML user agents handleattribute values expected to contain URIs. 6.1fn:resolve-uri Summary Resolves a relative IRI reference against an absolute IRI. Signatures fn:resolve-uri($relative as xs:string?) as xs:anyURI? fn:resolve-uri($relative as xs:string?,$base as xs:string) as xs:anyURI? Properties The one-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on static base uri. The two-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the second argument is absent, the effect is the same ascalling the two-argument function with the value of fn:static-base-uri() asthe second argument. The function is defined to operate on IRI references as definedin [RFC 3987], and the implementationmust permit all arguments that are valid accordingto that specification. In addition, the implementationmay accept some or all strings that conform to therules for (absolute or relative) Legacy Extended IRI references asdefined in [Legacy extended IRIs for XML resourceidentification]. For the purposes of this section, the termsIRI and IRI reference include these extensions, insofar as theimplementation chooses to support them. If $relative is the empty sequence, the functionreturns the empty sequence. If $relative is an absolute IRI (as defined above),then it is returned unchanged. Otherwise, the function resolves the relative IRI reference$relative against the base IRI $baseusing the algorithm defined in [RFC 3986],adapted by treating any Â·characterÂ· that would not be valid in an RFC3986 URI orrelative reference in the same way that RFC3986 treats unreservedcharacters. No percent-encoding takes place. Error Conditions The first form of this function resolves $relativeagainst the value of the base-uri property from the static context.A dynamic error is raised [err:FONS0005] if the base-uri property isnot initialized in the static context. A dynamic error is raised [err:FORG0002] if $relative isnot a valid IRI according to the rules of RFC3987, extended with animplementation-defined subset of the extensions permitted in LEIRI,or if it is not a suitable relative reference to use as input tothe RFC3986 resolution algorithm extended to handle additionalunreserved characters. A dynamic error is raised [err:FORG0002] if $base is nota valid IRI according to the rules of RFC3987, extended with animplementation-defined subset of the extensions permitted in LEIRI,or if it is not a suitable IRI to use as input to the chosenresolution algorithm (for example, if it is a relative IRIreference, if it is a non-hierarchic URI, or if it contains afragment identifier). A dynamic error is raised [err:FORG0009] if the chosen resolutionalgorithm fails for any other reason. Notes Resolving a URI does not dereference it. This is merely asyntactic operation on two Â·stringsÂ·. The algorithms in the cited RFCs include some variations thatare optional or recommended rather than mandatory; they alsodescribe some common practices that are not recommended, but whichare permitted for backwards compatibility. Where the cited RFCspermit variations in behavior, so does this specification. Throughout this family of specifications, the phrase "resolvinga relative URI (or IRI) reference" should be understood as usingthe rules of this function, unless otherwise stated. 6.2fn:encode-for-uri Summary Encodes reserved characters in a string that is intended to beused in the path segment of a URI. Signature fn:encode-for-uri($uri-part as xs:string?) as xs:string Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $uri-part is the empty sequence, the functionreturns the zero-length string. This function applies the URI escaping rules defined in section2 of [RFC 3986] to thexs:string supplied as $uri-part. Theeffect of the function is to escape reserved characters. Each suchcharacter in the string is replaced with its percent-encoded formas described in [RFC 3986]. Since [RFC 3986] recommends that, forconsistency, URI producers and normalizers should use uppercasehexadecimal digits for all percent-encodings, this function mustalways generate hexadecimal values using the upper-case lettersA-F. Notes All characters are escaped except those identified as"unreserved" by [RFC 3986], that is theupper- and lower-case letters A-Z, the digits 0-9, HYPHEN-MINUS("-"), LOW LINE ("_"), FULL STOP ".", and TILDE "~". This function escapes URI delimiters and therefore cannot beused indiscriminately to encode "invalid" characters in a pathsegment. This function is invertible but not idempotent. This is becausea string containing a percent character will be modified byapplying the function: for example 100% becomes100%25, while 100%25 becomes100%2525. Examples The expressionfn:encode-for-uri("http://www.example.com/00/Weather/CA/Los%20Angeles#ocean")returns"http%3A%2F%2Fwww.example.com%2F00%2FWeather%2FCA%2FLos%2520Angeles%23ocean".(This is probably not what the user intended because all of thedelimiters have been encoded.). The expression concat("http://www.example.com/",encode-for-uri("~bÃ©bÃ©")) returns"http://www.example.com/~b%C3%A9b%C3%A9". The expression concat("http://www.example.com/",encode-for-uri("100% organic")) returns"http://www.example.com/100%25%20organic". 6.3fn:iri-to-uri Summary Converts a string containing an IRI into a URI according to therules of [RFC 3987]. Signature fn:iri-to-uri($iri as xs:string?) as xs:string Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $iri is the empty sequence, the function returnsthe zero-length string. Otherwise, the function converts the value of $iriinto a URI according to the rules given in Section 3.1 of [RFC 3987] by percent-encoding characters that areallowed in an IRI but not in a URI. If $iri contains acharacter that is invalid in an IRI, such as the space character(see note below), the invalid character is replaced by itspercent-encoded form as described in [RFC3986] before the conversion is performed. Since [RFC 3986] recommends that, forconsistency, URI producers and normalizers should use uppercasehexadecimal digits for all percent-encodings, this function mustalways generate hexadecimal values using the upper-case lettersA-F. Notes The function is idempotent but not invertible. Both the inputsMy Documents and My%20Documents will beconverted to the output My%20Documents. This function does not check whether $iri is avalid IRI. It treats it as an Â·stringÂ· and operates on the Â·charactersÂ· in thestring. The following printable ASCII characters are invalid in an IRI:"<", ">", " " " (double quote), space, "{", "}", "|", "\","^", and "`". Since these characters should not appear in an IRI,if they do appear in $iri they will bepercent-encoded. In addition, characters outside the rangex20-x7E will be percent-encoded because they areinvalid in a URI. Since this function does not escape the PERCENT SIGN "%" andthis character is not allowed in data within a URI, users wishingto convert character strings (such as file names) that include "%"to a URI should manually escape "%" by replacing it with "%25". Examples The expression fn:iri-to-uri("http://www.example.com/00/Weather/CA/Los%20Angeles#ocean")returns"http://www.example.com/00/Weather/CA/Los%20Angeles#ocean". The expression fn:iri-to-uri("http://www.example.com/~bÃ©bÃ©") returns"http://www.example.com/~b%C3%A9b%C3%A9". 6.4 fn:escape-html-uri Summary Escapes a URI in the same way that HTML user agents handleattribute values expected to contain URIs. Signature fn:escape-html-uri($uri as xs:string?) as xs:string Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $uri is the empty sequence, the function returnsthe zero-length string. Otherwise, the function escapes all Â·charactersÂ· exceptprintable characters of the US-ASCII coded character set,specifically the Â·codepointsÂ· between 32 and 126 (decimal) inclusive. Eachcharacter in $uri to be escaped is replaced by anescape sequence, which is formed by encoding the character as asequence of octets in UTF-8, and then representing each of theseoctets in the form %HH, where HH is the hexadecimal representationof the octet. This function must always generate hexadecimal valuesusing the upper-case letters A-F. Notes The behavior of this function corresponds to the recommendedhandling of non-ASCII characters in URI attribute values asdescribed in [HTML 4.0] Appendix B.2.1. Examples The expression fn:escape-html-uri("http://www.example.com/00/Weather/CA/Los Angeles#ocean")returns "http://www.example.com/00/Weather/CA/LosAngeles#ocean". The expression fn:escape-html-uri ("javascript:if(navigator.browserLanguage == 'fr')window.open('http://www.example.com/~bÃ©bÃ©');") returns"javascript:if (navigator.browserLanguage == 'fr')window.open('http://www.example.com/~b%C3%A9b%C3%A9');". 7Functions and operators on Boolean values This section defines functions and operators on thexs:boolean datatype. 7.1 Boolean constant functions Since no literals are defined in XPath to reference the constantboolean values true and false, two functions are provided for thepurpose. Function Meaning fn:true Returns the xs:boolean valuetrue. fn:false Returns the xs:boolean valuefalse. 7.1.1 fn:true Summary Returns the xs:boolean value true. Signature fn:true() as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The result is equivalent to xs:boolean("1"). Examples The expression fn:true() returnsxs:boolean(1). 7.1.2 fn:false Summary Returns the xs:boolean valuefalse. Signature fn:false() as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The result is equivalent to xs:boolean("0"). Examples The expression fn:false() returnsxs:boolean(0). 7.2 Operators onBoolean values The following functions define the semantics of operators onboolean values in [XQuery 3.0: An XML QueryLanguage] and [XML Path Language (XPath)3.0]: Function Meaning op:boolean-equal Returns true if the two arguments are the sameboolean value. op:boolean-less-than Returns true if the first argument is false and the second istrue. op:boolean-greater-than Returns true if the first argument is true and the second isfalse. The ordering operators op:boolean-less-than andop:boolean-greater-thanare provided for application purposes and for compatibility with[XML Path Language (XPath) Version 1.0]. The[XML Schema Part 2: Datatypes SecondEdition] datatype xs:boolean is not ordered. 7.2.1op:boolean-equal Summary Returns true if the two arguments are the sameboolean value. Operator Mapping Defines the semantics of the "eq" operator when applied to twoxs:boolean values. Signature op:boolean-equal($value1 as xs:boolean,$value2 as xs:boolean) as xs:boolean Rules The function returns true if both arguments aretrue or if both arguments are false. Itreturns false if one of the arguments istrue and the other argument is false. 7.2.2 op:boolean-less-than Summary Returns true if the first argument is false and the second istrue. Operator Mapping Defines the semantics of the "lt" operator when applied to twoxs:boolean values. Also used in the definition of the"ge" operator. Signature op:boolean-less-than($arg1 as xs:boolean,$arg2 as xs:boolean) as xs:boolean Rules The function returns true if $arg1 isfalse and $arg2 is true.Otherwise, it returns false. 7.2.3 op:boolean-greater-than Summary Returns true if the first argument is true and the second isfalse. Operator Mapping Defines the semantics of the "gt" operator when applied to twoxs:boolean values. Also used in the definition of the"le" operator. Signature op:boolean-greater-than($arg1 as xs:boolean,$arg2 as xs:boolean) as xs:boolean Rules The function call op:boolean-greater-than($A, $B)is defined to return the same result as op:boolean-less-than($B,$A) 7.3 Functions on Boolean values The following functions are defined on boolean values: Function Meaning fn:boolean Computes the effective boolean value of the sequence$arg. fn:not Returns true if the effective boolean value of$arg is false, or false ifit is true. 7.3.1fn:boolean Summary Computes the effective boolean value of the sequence$arg. Signature fn:boolean($arg as item()*) as xs:boolean Rules The function computes the effective boolean value of a sequence,defined according to the following rules. See also Section 2.4.3 EffectiveBoolean Value XP30. If $arg is the empty sequence,fn:boolean returns false. If $arg is a sequence whose first item is a node,fn:boolean returns true. If $arg is a singleton value of typexs:boolean or a derived from xs:boolean,fn:boolean returns $arg. If $arg is a singleton value of typexs:string or a type derived fromxs:string, xs:anyURI or a type derivedfrom xs:anyURI or xs:untypedAtomic,fn:boolean returns false if the operandvalue has zero length; otherwise it returns true. If $arg is a singleton value of any numeric type ora type derived from a numeric type, fn:boolean returnsfalse if the operand value is NaN or isnumerically equal to zero; otherwise it returnstrue. In all other cases, fn:boolean raises a type error[err:FORG0006]. Notes The result of this function is not necessarily the same as$arg cast as xs:boolean. For example,fn:boolean("false") returns the valuetrue whereas "false" cast as xs:boolean(which can also be written xs:boolean("false"))returns false. Examples let $abc := ("a", "b", "") fn:boolean($abc) raises a type error [err:FORG0006]. The expression fn:boolean($abc[1]) returnstrue(). The expression fn:boolean($abc[0]) returnsfalse(). The expression fn:boolean($abc[3]) returnsfalse(). 7.3.2 fn:not Summary Returns true if the effective boolean value of$arg is false, or false ifit is true. Signature fn:not($arg as item()*) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The value of $arg is first reduced to an effectiveboolean value by applying the fn:boolean() function. Thefunction returns true if the effective boolean valueis false, or false if the effectiveboolean value is true. Examples The expression fn:not(fn:true()) returnsfalse(). The expression fn:not("false") returnsfalse(). 8 Functions andoperators on durations Operators are defined on the following type: xs:duration and on the two defined subtypes (see 8.1 Two totally ordered subtypes ofduration): xs:yearMonthDuration xs:dayTimeDuration No ordering relation is defined on xs:durationvalues. Two xs:duration values may however be comparedfor equality. Operations on durations (including equality comparison, castingto string, and extraction of components) all treat the duration asnormalized. This means that the seconds and minutes components willalways be less than 60, the hours component less than 24, and themonths component less than 12. Thus, for example, a duration of 120seconds always gives the same result as a duration of twominutes. Conditions such as underflow and overflow may occur witharithmetic on durations: see 9.7.1Limits and precision Note: This means that in practice, the information content of anxs:duration value can be reduced to anxs:integer number of months, and anxs:decimal number of seconds. For the two definedsubtypes this is further simplified so that one of these twocomponents is fixed at zero. Operations such as comparison ofdurations and arithmetic on durations can be expressed in terms ofnumeric operations applied to these two components. 8.1 Twototally ordered subtypes of duration Two totally ordered subtypes of xs:duration aredefined in Section 2.7 SchemaInformation DM30 specification usingthe mechanisms described in [XML Schema Part2: Datatypes Second Edition] for defining user-defined types.Additional details about these types is given below. Note: These types were not defined in XSD 1.0, but they are defined inthe current draft of XSD 1.1. The description given here isbelieved to be equivalent to that in XSD 1.1, and will becomenon-normative when XSD 1.1 reaches Recommendation status. 8.1.1 xs:yearMonthDuration [Definition] xs:yearMonthDuration is derived fromxs:duration by restricting its lexical representationto contain only the year and month components. The value space ofxs:yearMonthDuration is the set ofxs:integer month values. The year and month componentsof xs:yearMonthDuration correspond to the Gregorianyear and month components defined in section 5.5.3.2 of [ISO 8601], respectively. 8.1.1.1 Lexical representation The lexical representation for xs:yearMonthDurationis the [ISO 8601] reduced format PnYnM,where nY represents the number of years and nM the number ofmonths. The values of the years and months components are notrestricted but allow an arbitrary unsignedxs:integer. An optional preceding minus sign ('-') is allowed to indicate anegative duration. If the sign is omitted a positive duration isindicated. To indicate a xs:yearMonthDuration of 1year, 2 months, one would write: P1Y2M. One could also indicate axs:yearMonthDuration of minus 13 months as: -P13M. Reduced precision and truncated representations of this formatare allowed provided they conform to the following: If the number of years or months in any expression equals zero(0), the number and its corresponding designator Â·mayÂ· be omitted.However, at least one number and its designator Â·mustÂ· be present.For example, P1347Y and P1347M are allowed; P-1347M is not allowed,although -P1347M is allowed. P1Y2MT is not allowed. Also, P24YM isnot allowed, nor is PY43M since Y must have at least one precedingdigit and M must have one preceding digit. 8.1.1.2 Calculating thevalue from the lexical representation The value of a xs:yearMonthDuration lexical form isobtained by multiplying the value of the years component by 12 andadding the value of the months component. The value is positive ornegative depending on the preceding sign. 8.1.1.3 Canonicalrepresentation The canonical representation ofxs:yearMonthDuration restricts the value of the monthscomponent to xs:integer values between 0 and 11, bothinclusive. To convert from a non-canonical representation to thecanonical representation, the lexical representation is firstconverted to a value in xs:integer months as definedabove. This value is then divided by 12 to obtain the value of theyears component of the canonical representation. The remainingnumber of months is the value of the months component of thecanonical representation. For negative durations, the canonicalform is calculated using the absolute value of the duration and anegative sign is prepended to it. If a component has the value zero(0), then the number and the designator for that componentÂ·mustÂ· be omitted.However, if the value is zero (0) months, the canonical form is"P0M". 8.1.1.4 Order relation onxs:yearMonthDuration Let the function that calculates the value of anxs:yearMonthDuration in the manner described above becalled V(d). Then for two xs:yearMonthDuration valuesx and y, x > y if and only if V(x) > V(y). The order relationon yearMonthDuration is a total order. 8.1.2xs:dayTimeDuration [Definition] xs:dayTimeDuration is derived fromxs:duration by restricting its lexical representationto contain only the days, hours, minutes and seconds components.The value space of xs:dayTimeDuration is the set offractional second values. The components ofxs:dayTimeDuration correspond to the day, hour, minuteand second components defined in Section 5.5.3.2 of [ISO 8601], respectively. 8.1.2.1 Lexical representation The lexical representation for xs:dayTimeDurationis the [ISO 8601] truncated formatPnDTnHnMnS, where nD represents the number of days, T is thedate/time separator, nH the number of hours, nM the number ofminutes and nS the number of seconds. The values of the days, hours and minutes components are notrestricted, but allow an arbitrary unsignedxs:integer. Similarly, the value of the secondscomponent allows an arbitrary unsigned xs:decimal. Anoptional minus sign ('-') is allowed to precede the 'P', indicatinga negative duration. If the sign is omitted, the duration ispositive. See also [ISO 8601] Date and TimeFormats. For example, to indicate a duration of 3 days, 10 hours and 30minutes, one would write: P3DT10H30M. One could also indicate aduration of minus 120 days as: -P120D. Reduced precision andtruncated representations of this format are allowed, provided theyconform to the following: If the number of days, hours, minutes, or seconds in anyexpression equals zero (0), the number and its correspondingdesignator Â·mayÂ· be omitted.However, at least one number and its designator Â·mustÂ· bepresent. The seconds part Â·mayÂ· have a decimal fraction. The designator 'T' Â·mustÂ· be absent if and only if all of the time itemsare absent. The designator 'P' Â·mustÂ· always be present. For example, P13D, PT47H, P3DT2H, -PT35.89S and P4DT251M are allallowed. P-134D is not allowed (invalid location of minus sign),although -P134D is allowed. 8.1.2.2 Calculating thevalue of a xs:dayTimeDuration from the lexical representation The value of a xs:dayTimeDuration lexical form infractional seconds is obtained by converting the days, hours,minutes and seconds value to fractional seconds using theconversion rules: 24 hours = 1 day, 60 minutes = 1 hour and 60seconds = 1 minute. 8.1.2.3 Canonicalrepresentation The canonical representation of xs:dayTimeDurationrestricts the value of the hours component toxs:integer values between 0 and 23, both inclusive;the value of the minutes component to xs:integervalues between 0 and 59; both inclusive; and the value of theseconds component to xs:decimal valued from 0.0 to59.999... (see [XML Schema Part 2: DatatypesSecond Edition], Appendix D). To convert from a non-canonical representation to the canonicalrepresentation, the value of the lexical form in fractional secondsis first calculated in the manner described above. The value of thedays component in the canonical form is then calculated by dividingthe value by 86,400 (24*60*60). The remainder is in fractionalseconds. The value of the hours component in the canonical form iscalculated by dividing this remainder by 3,600 (60*60). Theremainder is again in fractional seconds. The value of the minutescomponent in the canonical form is calculated by dividing thisremainder by 60. The remainder in fractional seconds is the valueof the seconds component in the canonical form. For negativedurations, the canonical form is calculated using the absolutevalue of the duration and a negative sign is prepended to it. If acomponent has the value zero (0) then the number and the designatorfor that component must be omitted. However, if all the componentsof the lexical form are zero (0), the canonical form is "PT0S". 8.1.2.4 Order relation onxs:dayTimeDuration Let the function that calculates the value of axs:dayTimeDuration in the manner described above becalled V(d). Then for two xs:dayTimeDurationvalues x and y, x > y if and only if V(x)> V(y). The order relation onxs:dayTimeDuration is a total order. 8.2 Comparisonoperators on durations Function Meaning op:yearMonthDuration-less-than Returns true if $arg1 is a shorter duration than$arg2. op:yearMonthDuration-greater-than Returns true if $arg1 is a longer duration than$arg2. op:dayTimeDuration-less-than Returns true if $arg1 is a shorter duration than$arg2. op:dayTimeDuration-greater-than Returns true if $arg1 is a longer duration than$arg2. op:duration-equal Returns true if $arg1 and $arg2 aredurations of the same length. The following comparison operators are defined on the [XML Schema Part 2: Datatypes Second Edition]duration datatypes. Each operator takes two operands of the sametype and returns an xs:boolean result. As discussed in[XML Schema Part 2: Datatypes SecondEdition], the order relation on xs:duration is apartial order rather than a total order. For this reason, onlyequality is defined on xs:duration. A full complementof comparison and arithmetic functions are defined on the twosubtypes of duration described in 8.1 Two totally ordered subtypes ofduration which do have a total order. 8.2.1op:yearMonthDuration-less-than Summary Returns true if $arg1 is a shorter duration than$arg2. Operator Mapping Defines the semantics of the "lt" operator when applied to twoxs:yearMonthDuration values. Also used in thedefinition of the "ge" operator. Signature op:yearMonthDuration-less-than( $arg1 as xs:yearMonthDuration, $arg2 as xs:yearMonthDuration) as xs:boolean Rules If the number of months in the value of $arg1 isnumerically less than the number of months in the value of$arg2, the function returns true. Otherwise, the function returns false. Notes Either or both durations may be negative 8.2.2op:yearMonthDuration-greater-than Summary Returns true if $arg1 is a longer duration than$arg2. Operator Mapping Defines the semantics of the "gt" operator when applied to twoxs:yearMonthDuration values. Also used in thedefinition of the "le" operator. Signature op:yearMonthDuration-greater-than( $arg1 as xs:yearMonthDuration, $arg2 as xs:yearMonthDuration) as xs:boolean Rules The function call op:yearMonthDuration-greater-than($A,$B) is defined to return the same result as op:yearMonthDuration-less-than($B,$A) 8.2.3op:dayTimeDuration-less-than Summary Returns true if $arg1 is a shorter duration than$arg2. Operator Mapping Defines the semantics of the "lt" operator when applied to twoxs:dayTimeDuration values. Also used in the definitionof the "ge" operator. Signature op:dayTimeDuration-less-than( $arg1 as xs:dayTimeDuration, $arg2 as xs:dayTimeDuration) as xs:boolean Rules If the number of seconds in the value of $arg1 isnumerically less than the number of seconds in the value of$arg2, the function returns true. Otherwise, the function returns false. Notes Either or both durations may be negative 8.2.4op:dayTimeDuration-greater-than Summary Returns true if $arg1 is a longer duration than$arg2. Operator Mapping Defines the semantics of the "gt" operator when applied to twoxs:dayTimeDuration values. Also used in the definitionof the "le" operator. Signature op:dayTimeDuration-greater-than( $arg1 as xs:dayTimeDuration, $arg2 as xs:dayTimeDuration) as xs:boolean Rules The function call op:dayTimeDuration-greater-than($A,$B) is defined to return the same result as op:dayTimeDuration-less-than($B,$A) 8.2.5 op:duration-equal Summary Returns true if $arg1 and $arg2 aredurations of the same length. Operator Mapping Defines the semantics of the "eq" operators when applied to twoxs:duration values. Also used in the definition of the"ne" operator. Signature op:duration-equal($arg1 as xs:duration,$arg2 as xs:duration) as xs:boolean Rules If the xs:yearMonthDuration components of$arg1 and $arg2 are equal and thexs:dayTimeDuration components of $arg1and $arg2 are equal, the function returnstrue. Otherwise, the function returns false. The semantics of this function are: xs:yearMonthDuration($arg1) div xs:yearMonthDuration('P1M')  eqxs:yearMonthDuration($arg2) div xs:yearMonthDuration('P1M')    andxs:dayTimeDuration($arg1) div xs:dayTimeDuration('PT1S')  eqxs:dayTimeDuration($arg2) div xs:dayTimeDuration('PT1S') that is, the function returns true if the monthsand seconds values of the two durations are equal. Notes Note that this function, like any other, may be applied toarguments that are derived from the types given in the functionsignature, including the two subtypesxs:dayTimeDuration andxs:yearMonthDuration. With the exception of thezero-length duration, no instance ofxs:dayTimeDuration can ever be equal to an instance ofxs:yearMonthDuration. Examples The expression op:duration-equal(xs:duration("P1Y"),xs:duration("P12M")) returns true(). The expression op:duration-equal(xs:duration("PT24H"),xs:duration("P1D")) returns true(). The expression op:duration-equal(xs:duration("P1Y"),xs:duration("P365D")) returns false(). The expressionop:duration-equal(xs:yearMonthDuration("P0Y"),xs:dayTimeDuration("P0D")) returns true(). The expressionop:duration-equal(xs:yearMonthDuration("P1Y"),xs:dayTimeDuration("P365D")) returnsfalse(). The expressionop:duration-equal(xs:yearMonthDuration("P2Y"),xs:yearMonthDuration("P24M")) returnstrue(). The expressionop:duration-equal(xs:dayTimeDuration("P10D"),xs:dayTimeDuration("PT240H")) returnstrue(). The expressionop:duration-equal(xs:duration("P2Y0M0DT0H0M0S"),xs:yearMonthDuration("P24M")) returnstrue(). The expression op:duration-equal(xs:duration("P0Y0M10D"),xs:dayTimeDuration("PT240H")) returnstrue(). 8.3 Component extractionfunctions on durations The duration datatype may be considered to be a compositedatatypes in that it contains distinct properties or components.The extraction functions specified below extract a single componentfrom a duration value. For xs:duration and itssubtypes, including the two subtypesxs:yearMonthDuration andxs:dayTimeDuration, the components are normalized:this means that the seconds and minutes components will always beless than 60, the hours component less than 24, and the monthscomponent less than 12. Function Meaning fn:years-from-duration Returns the number of years in a duration. fn:months-from-duration Returns the number of months in a duration. fn:days-from-duration Returns the number of days in a duration. fn:hours-from-duration Returns the number of hours in a duration. fn:minutes-from-duration Returns the number of minutes in a duration. fn:seconds-from-duration Returns the number of seconds in a duration. 8.3.1 fn:years-from-duration Summary Returns the number of years in a duration. Signature fn:years-from-duration($arg as xs:duration?) as xs:integer? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns an xs:integerrepresenting the years component in the value of $arg.The result is obtained by casting $arg to anxs:yearMonthDuration (see 18.1.3 Casting to durationtypes) and then computing the years component as describedin 8.1.1.3 Canonicalrepresentation. If $arg is a negative duration then the result willbe negative.. If $arg is an xs:dayTimeDuration thefunction returns 0. Examples The expressionfn:years-from-duration(xs:yearMonthDuration("P20Y15M"))returns 21. The expressionfn:years-from-duration(xs:yearMonthDuration("-P15M"))returns -1. The expressionfn:years-from-duration(xs:dayTimeDuration("-P2DT15H"))returns 0. 8.3.2 fn:months-from-duration Summary Returns the number of months in a duration. Signature fn:months-from-duration($arg as xs:duration?) as xs:integer? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns an xs:integerrepresenting the months component in the value of$arg. The result is obtained by casting$arg to an xs:yearMonthDuration (see18.1.3 Casting to durationtypes) and then computing the months component as describedin 8.1.1.3 Canonicalrepresentation. If $arg is a negative duration then the result willbe negative.. If $arg is an xs:dayTimeDuration thefunction returns 0. Examples The expressionfn:months-from-duration(xs:yearMonthDuration("P20Y15M"))returns 3. The expressionfn:months-from-duration(xs:yearMonthDuration("-P20Y18M"))returns -6. The expressionfn:months-from-duration(xs:dayTimeDuration("-P2DT15H0M0S"))returns 0. 8.3.3 fn:days-from-duration Summary Returns the number of days in a duration. Signature fn:days-from-duration($arg as xs:duration?) as xs:integer? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns an xs:integerrepresenting the days component in the value of $arg.The result is obtained by casting $arg to anxs:dayTimeDuration (see 18.1.3 Casting to durationtypes) and then computing the days component as describedin 8.1.2.3 Canonicalrepresentation. If $arg is a negative duration then the result willbe negative.. If $arg is an xs:yearMonthDuration thefunction returns 0. Examples The expressionfn:days-from-duration(xs:dayTimeDuration("P3DT10H"))returns 3. The expressionfn:days-from-duration(xs:dayTimeDuration("P3DT55H"))returns 5. The expressionfn:days-from-duration(xs:yearMonthDuration("P3Y5M"))returns 0. 8.3.4 fn:hours-from-duration Summary Returns the number of hours in a duration. Signature fn:hours-from-duration($arg as xs:duration?) as xs:integer? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns an xs:integerrepresenting the hours component in the value of $arg.The result is obtained by casting $arg to anxs:dayTimeDuration (see 18.1.3 Casting to durationtypes) and then computing the hours component as describedin 8.1.2.3 Canonicalrepresentation. If $arg is a negative duration then the result willbe negative.. If $arg is an xs:yearMonthDuration thefunction returns 0. Examples The expressionfn:hours-from-duration(xs:dayTimeDuration("P3DT10H"))returns 10. The expressionfn:hours-from-duration(xs:dayTimeDuration("P3DT12H32M12S"))returns 12. The expressionfn:hours-from-duration(xs:dayTimeDuration("PT123H"))returns 3. The expressionfn:hours-from-duration(xs:dayTimeDuration("-P3DT10H"))returns -10. 8.3.5fn:minutes-from-duration Summary Returns the number of minutes in a duration. Signature fn:minutes-from-duration($arg as xs:duration?) as xs:integer? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns an xs:integerrepresenting the minutes component in the value of$arg. The result is obtained by casting$arg to an xs:dayTimeDuration (see18.1.3 Casting to durationtypes) and then computing the minutes component asdescribed in 8.1.2.3Canonical representation. If $arg is a negative duration then the result willbe negative.. If $arg is an xs:yearMonthDuration thefunction returns 0. Examples The expressionfn:minutes-from-duration(xs:dayTimeDuration("P3DT10H"))returns 0. The expressionfn:minutes-from-duration(xs:dayTimeDuration("-P5DT12H30M"))returns -30. 8.3.6fn:seconds-from-duration Summary Returns the number of seconds in a duration. Signature fn:seconds-from-duration($arg as xs:duration?) as xs:decimal? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns an xs:decimalrepresenting the seconds component in the value of$arg. The result is obtained by casting$arg to an xs:dayTimeDuration (see18.1.3 Casting to durationtypes) and then computing the seconds component asdescribed in 8.1.2.3Canonical representation. If $arg is a negative duration then the result willbe negative.. If $arg is an xs:yearMonthDuration thefunction returns 0. Examples The expressionfn:seconds-from-duration(xs:dayTimeDuration("P3DT10H12.5S"))returns 12.5. The expressionfn:seconds-from-duration(xs:dayTimeDuration("-PT256S"))returns -16.0. 8.4Arithmetic operators on durations Function Meaning op:add-yearMonthDurations Returns the result of adding twoxs:yearMonthDuration values. op:subtract-yearMonthDurations Returns the result of subtracting onexs:yearMonthDuration value from another. op:multiply-yearMonthDuration Returns the result of multiplying the value of$arg1 by $arg2. The result is rounded tothe nearest month. op:divide-yearMonthDuration Returns the result of dividing the value of $arg1by $arg2. The result is rounded to the nearestmonth. op:divide-yearMonthDuration-by-yearMonthDuration Returns the ratio of two xs:yearMonthDurationvalues. op:add-dayTimeDurations Returns the sum of two xs:dayTimeDurationvalues. op:subtract-dayTimeDurations Returns the result of subtracting onexs:dayTimeDuration from another. op:multiply-dayTimeDuration Returns the result of multiplying axs:dayTimeDuration by a number. op:divide-dayTimeDuration Returns the result of multiplying axs:dayTimeDuration by a number. op:divide-dayTimeDuration-by-dayTimeDuration Returns the ratio of two xs:dayTimeDurationvalues, as a decimal number. For operators that combine a duration and a date/time value, see9.7 Arithmetic operators ondurations, dates and times. 8.4.1op:add-yearMonthDurations Summary Returns the result of adding twoxs:yearMonthDuration values. Operator Mapping Defines the semantics of the "+" operator when applied to twoxs:yearMonthDuration values. Signature op:add-yearMonthDurations( $arg1 as xs:yearMonthDuration, $arg2 as xs:yearMonthDuration) as xs:yearMonthDuration Rules The function returns the result of adding the value of$arg1 to the value of $arg2. The resultwill be an xs:yearMonthDuration whose length in monthsis equal to the length in months of $arg1 plus thelength in months of $arg2. For handling of overflow, see 9.7.1 Limits and precision. Notes Either duration (and therefore the result) may be negative. Examples The expressionop:add-yearMonthDurations(xs:yearMonthDuration("P2Y11M"),xs:yearMonthDuration("P3Y3M")) returnsxs:yearMonthDuration("P6Y2M"). 8.4.2op:subtract-yearMonthDurations Summary Returns the result of subtracting onexs:yearMonthDuration value from another. Operator Mapping Defines the semantics of the "-" operator when applied to twoxs:yearMonthDuration values. Signature op:subtract-yearMonthDurations( $arg1 as xs:yearMonthDuration, $arg2 as xs:yearMonthDuration) as xs:yearMonthDuration Rules The function returns the result of subtracting the value of$arg2 from the value of $arg1. The resultwill be an xs:yearMonthDuration whose length in monthsis equal to the length in months of $arg1 minus thelength in months of $arg2. For handling of overflow, see 9.7.1 Limits and precision. Notes Either duration (and therefore the result) may be negative. Examples The expressionop:subtract-yearMonthDurations(xs:yearMonthDuration("P2Y11M"),xs:yearMonthDuration("P3Y3M")) returnsxs:yearMonthDuration("-P4M"). 8.4.3op:multiply-yearMonthDuration Summary Returns the result of multiplying the value of$arg1 by $arg2. The result is rounded tothe nearest month. Operator Mapping Defines the semantics of the "*" operator when applied to anxs:yearMonthDuration and a numeric value. Signature op:multiply-yearMonthDuration( $arg1 as xs:yearMonthDuration, $arg2 as xs:double) as xs:yearMonthDuration Rules The result is the xs:yearMonthDuration whose lengthin months is equal to the result of applying the fn:round function to the valueobtained by multiplying the length in months of $arg1by the value of $arg2. If $arg2 is positive or negative zero, the resultis a zero-length duration. If $arg2 is positive ornegative infinity, the result overflows and is handled as discussedin 9.7.1 Limits andprecision. For handling of overflow and underflow, see 9.7.1 Limits and precision. Error Conditions A dynamic error is raised [err:FOCA0005] if $arg2 isNaN. Notes Either duration (and therefore the result) may be negative. Examples The expressionop:multiply-yearMonthDuration(xs:yearMonthDuration("P2Y11M"),2.3) returns xs:yearMonthDuration("P6Y9M"). 8.4.4op:divide-yearMonthDuration Summary Returns the result of dividing the value of $arg1by $arg2. The result is rounded to the nearestmonth. Operator Mapping Defines the semantics of the "div" operator when applied to anxs:yearMonthDuration and a numeric value. Signature op:divide-yearMonthDuration( $arg1 as xs:yearMonthDuration, $arg2 as xs:double) as xs:yearMonthDuration Rules The result is the xs:yearMonthDuration whose lengthin months is equal to the result of applying the fn:round function to the valueobtained by dividing the length in months of $arg1 bythe value of $arg2. If $arg2 is positive or negative infinity, theresult is a zero-length duration. If $arg2 is positiveor negative zero, the result overflows and is handled as discussedin 9.7.1 Limits andprecision. For handling of overflow and underflow, see 9.7.1 Limits and precision. Error Conditions A dynamic error is raised [err:FOCA0005] if $arg2 isNaN. Notes Either operand (and therefore the result) may be negative. Examples The expressionop:divide-yearMonthDuration(xs:yearMonthDuration("P2Y11M"),1.5) returnsxs:yearMonthDuration("P1Y11M"). 8.4.5op:divide-yearMonthDuration-by-yearMonthDuration Summary Returns the ratio of two xs:yearMonthDurationvalues. Operator Mapping Defines the semantics of the "div" operator when applied to twoxs:yearMonthDuration values. Signature op:divide-yearMonthDuration-by-yearMonthDuration( $arg1 as xs:yearMonthDuration, $arg2 as xs:yearMonthDuration) as xs:decimal Rules The function returns the result of dividing the length in monthsof $arg1 by the length in months of$arg2, according to the rules of the op:numeric-divide functionfor integer operands. For handling of overflow and underflow, see 9.7.1 Limits and precision. Notes Either duration (and therefore the result) may be negative. Examples The expressionop:divide-yearMonthDuration-by-yearMonthDuration(xs:yearMonthDuration("P3Y4M"),xs:yearMonthDuration("-P1Y4M")) returns-2.5. The following example demonstrates how to calculate the lengthof an xs:yearMonthDuration value in months: The expressionop:divide-yearMonthDuration-by-yearMonthDuration(xs:yearMonthDuration("P3Y4M"),xs:yearMonthDuration("P1M")) returns 40. 8.4.6 op:add-dayTimeDurations Summary Returns the sum of two xs:dayTimeDurationvalues. Operator Mapping Defines the semantics of the "+" operator when applied to twoxs:dayTimeDuration values. Signature op:add-dayTimeDurations( $arg1 as xs:dayTimeDuration, $arg2 as xs:dayTimeDuration) as xs:dayTimeDuration Rules The function returns the result of adding the value of$arg1 to the value of $arg2. The resultis the xs:dayTimeDuration whose length in seconds isequal to the sum of the length in seconds of the two inputdurations. For handling of overflow, see 9.7.1 Limits and precision. Notes Either duration (and therefore the result) may be negative. Examples The expressionop:add-dayTimeDurations(xs:dayTimeDuration("P2DT12H5M"),xs:dayTimeDuration("P5DT12H")) returnsxs:dayTimeDuration('P8DT5M'). 8.4.7op:subtract-dayTimeDurations Summary Returns the result of subtracting onexs:dayTimeDuration from another. Operator Mapping Defines the semantics of the "-" operator when applied to twoxs:dayTimeDuration values. Signature op:subtract-dayTimeDurations( $arg1 as xs:dayTimeDuration, $arg2 as xs:dayTimeDuration) as xs:dayTimeDuration Rules The function returns the result of subtracting the value of$arg2 from the value of $arg1. The resultis the xs:dayTimeDuration whose length in seconds isequal to the length in seconds of $arg1 minus thelength in seconds of $arg2. For handling of overflow, see 9.7.1 Limits and precision. Notes Either duration (and therefore the result) may be negative. Examples The expressionop:subtract-dayTimeDurations(xs:dayTimeDuration("P2DT12H"),xs:dayTimeDuration("P1DT10H30M")) returnsxs:dayTimeDuration('P1DT1H30M'). 8.4.8op:multiply-dayTimeDuration Summary Returns the result of multiplying axs:dayTimeDuration by a number. Operator Mapping Defines the semantics of the "*" operator when applied to anxs:dayTimeDuration and a numeric value. Signature op:multiply-dayTimeDuration( $arg1 as xs:dayTimeDuration, $arg2 as xs:double) as xs:dayTimeDuration Rules The function returns the result of multiplying the value of$arg1 by $arg2. The result is thexs:dayTimeDuration whose length in seconds is equal tothe length in seconds of $arg1 multiplied by thenumeric value $arg2. If $arg2 is positive or negative zero, the resultis a zero-length duration. If $arg2 is positive ornegative infinity, the result overflows and is handled as discussedin 9.1.1 Limits andprecision. For handling of overflow and underflow, see 9.7.1 Limits and precision. Error Conditions A dynamic error is raised [err:FOCA0005] if $arg2 isNaN. Notes Either operand (and therefore the result) may be negative. Examples The expressionop:multiply-dayTimeDuration(xs:dayTimeDuration("PT2H10M"),2.1) returns xs:dayTimeDuration('PT4H33M'). 8.4.9op:divide-dayTimeDuration Summary Returns the result of multiplying axs:dayTimeDuration by a number. Operator Mapping Defines the semantics of the "div" operator when applied to twoxs:dayTimeDuration values. Signature op:divide-dayTimeDuration( $arg1 as xs:dayTimeDuration, $arg2 as xs:double) as xs:dayTimeDuration Rules The function returns the result of dividing the value of$arg1 by $arg2. The result is thexs:dayTimeDuration whose length in seconds is equal tothe length in seconds of $arg1 divided by the numericvalue $arg2. If $arg2 is positive or negative infinity, theresult is a zero-length duration. If $arg2 is positiveor negative zero, the result overflows and is handled as discussedin 9.1.1 Limits andprecision. For handling of overflow and underflow, see 9.7.1 Limits and precision. Error Conditions A dynamic error is raised [err:FOCA0005] if $arg2 isNaN. Notes Either operand (and therefore the result) may be negative. Examples The expressionop:divide-dayTimeDuration(xs:dayTimeDuration("P1DT2H30M10.5S"),1.5) returns xs:duration("PT17H40M7S"). 8.4.10op:divide-dayTimeDuration-by-dayTimeDuration Summary Returns the ratio of two xs:dayTimeDuration values,as a decimal number. Operator Mapping Defines the semantics of the "div" operator when applied to twoxs:dayTimeDuration values. Signature op:divide-dayTimeDuration-by-dayTimeDuration( $arg1 as xs:dayTimeDuration, $arg2 as xs:dayTimeDuration) as xs:decimal Rules The function returns the result of dividing the value of$arg1 by $arg2. The result is thexs:dayTimeDuration whose length in seconds is equal tothe length in seconds of $arg1 divided by the lengthin seconds of $arg2. The calculation is performed byapplying op:numeric-divide to thetwo xs:decimal operands. For handling of overflow and underflow, see 9.7.1 Limits and precision. Notes Either operand (and therefore the result) may be negative. Examples The expression fn:round-half-to-even(op:divide-dayTimeDuration-by-dayTimeDuration(xs:dayTimeDuration("P2DT53M11S"), xs:dayTimeDuration("P1DT10H")),4) returns 1.4378. This examples shows how to determine the number of seconds in aduration. The expressionop:divide-dayTimeDuration-by-dayTimeDuration(xs:dayTimeDuration("P2DT53M11S"),xs:dayTimeDuration("PT1S")) returns175991.0. 9 Functions andoperators on dates and times This section defines operations on the [XML Schema Part 2: Datatypes Second Edition]date and time types. See [Working WithTimezones] for a disquisition on working with date and timevalues with and without timezones. 9.1 Date andtime types The operators described in this section are defined on thefollowing date and time types: xs:dateTime xs:date xs:time xs:gYearMonth xs:gYear xs:gMonthDay xs:gMonth xs:gDay The only operations defined on xs:gYearMonth,xs:gYear, xs:gMonthDay,xs:gMonth and xs:gDay values are equalitycomparison and component extraction. For other types, furtheroperations are provided, including order comparisons, arithmetic,formatted display, and timezone adjustment. 9.1.1 Limits andprecision For a number of the above datatypes [XMLSchema Part 2: Datatypes Second Edition] extends the basic[ISO 8601] lexical representations, such asYYYY-MM-DDThh:mm:ss.s for dateTime, by allowing a preceding minussign, more than four digits to represent the year field â€” nomaximum is specified â€” and an unlimited number of digits forfractional seconds. Leap seconds are not supported. All minimally conforming processors Â·mustÂ· supportpositive year values with a minimum of 4 digits (i.e., YYYY) and aminimum fractional second precision of 1 millisecond or threedigits (i.e., s.sss). However, conforming processorsÂ·mayÂ· set largerÂ·implementation-definedÂ· limits on the maximum number of digits theysupport in these two situations. Processors Â·mayÂ· also choose to support the year 0000 and yearswith negative values. The results of operations on dates that crossthe year 0000 are Â·implementation-definedÂ·. A processor that limits the number of digits in date and timedatatype representations may encounter overflow and underflowconditions when it tries to execute the functions in 9.7 Arithmetic operators on durations,dates and times. In these situations, the processorÂ·mustÂ· return00:00:00 in case of time underflow. It Â·mustÂ· raise a dynamic error [err:FODT0001] in case ofoverflow. 9.2Date/time datatype values As defined in Section3.3.2 Dates and Times DM30,xs:dateTime, xs:date,xs:time, xs:gYearMonth,xs:gYear, xs:gMonthDay,xs:gMonth, xs:gDay values, referred tocollectively as date/time values, are represented as sevencomponents or properties: year, month,day, hour, minute,second and timezone. The first fivecomponents are xs:integer values. The value of thesecond component is an xs:decimal and thevalue of the timezone component is anxs:dayTimeDuration. For all the primitive date/timedatatypes, the timezone property is optional and mayor may not be present. Depending on the datatype, some of theremaining six properties must be present and some must be absentDM30.Absent, or missing, properties are represented by the emptysequence. This value is referred to as the local value inthat the value retains its original timezone. Before comparing orsubtracting xs:dateTime values, this local valueÂ·mustÂ· be translatedor normalized to UTC. For xs:time, 00:00:00 and24:00:00 are alternate lexical forms for the samevalue, whose canonical representation is 00:00:00. Forxs:dateTime, a time component 24:00:00translates to 00:00:00 of the following day. 9.2.1 Examples An xs:dateTime with lexical representation1999-05-31T05:00:00 is represented in the datamodel by{1999, 5, 31, 5, 0, 0.0, ()}. An xs:dateTime with lexical representation1999-05-31T13:20:00-05:00 is represented by{1999, 5, 31, 13, 20, 0.0, -PT5H}. An xs:dateTime with lexical representation1999-12-31T24:00:00 is represented by {2000, 1,1, 0, 0, 0.0, ()}. An xs:date with lexical representation2005-02-28+8:00 is represented by {2005, 2, 28,(), (), (), PT8H}. An xs:time with lexical representation24:00:00 is represented by {(), (), (), 0, 0, 0,()}. 9.3 Constructing a dateTime A function is provided for constructing axs:dateTime value from a xs:date valueand a xs:time value. 9.3.1fn:dateTime Summary Returns an xs:dateTime value created by combiningan xs:date and an xs:time. Signature fn:dateTime($arg1 as xs:date?,$arg2 as xs:time?) as xs:dateTime? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If either $arg1 or $arg2 is the emptysequence the function returns the empty sequence. Otherwise, the function returns an xs:dateTimewhose date component is equal to $arg1 and whose timecomponent is equal to $arg2. The timezone of the result is computed as follows: If neither argument has a timezone, the result has notimezone. If exactly one of the arguments has a timezone, or if botharguments have the same timezone, the result has this timezone. Error Conditions A dynamic error is raised [err:FORG0008] if the two arguments bothhave timezones and the timezones are different. Examples The expression fn:dateTime(xs:date("1999-12-31"),xs:time("12:00:00")) returnsxs:dateTime("1999-12-31T12:00:00"). The expression fn:dateTime(xs:date("1999-12-31"),xs:time("24:00:00")) returnsxs:dateTime("1999-12-31T00:00:00"). (This isbecause "24:00:00" is an alternate lexical form for"00:00:00"). 9.4 Comparisonoperators on duration, date and time values Function Meaning op:dateTime-equal Returns true if the two supplied xs:dateTimevalues refer to the same instant in time. op:dateTime-less-than Returns true if the first argument represents anearlier instant in time than the second argument. op:dateTime-greater-than Returns true if the first argument represents alater instant in time than the second argument. op:date-equal Returns true if and only if the starting instantsof the two supplied xs:date values are the same. op:date-less-than Returns true if and only if the starting instantof $arg1 is less than the starting instant of$arg2. Returns false otherwise. op:date-greater-than Returns true if and only if the starting instantof $arg1 is greater than the starting instant of$arg2. Returns false otherwise. op:time-equal Returns true if the two xs:timevalues represent the same instant in time, when treated as beingtimes on the same date, before adjusting the timezone. op:time-less-than Returns true if the first xs:timevalue represents an earlier instant in time than the second, whenboth are treated as being times on the same date, before adjustingthe timezone. op:time-greater-than Returns true if the first xs:timevalue represents a later instant in time than the second, when bothare treated as being times on the same date, before adjusting thetimezone. op:gYearMonth-equal Returns true if the two xs:gYearMonth values havethe same starting instant. op:gYear-equal Returns true if the two xs:gYear values have thesame starting instant. op:gMonthDay-equal Returns true if the two xs:gMonthDay values havethe same starting instant, when considered as days in the sameyear. op:gMonth-equal Returns true if the two xs:gMonth values have thesame starting instant, when considered as months in the sameyear. op:gDay-equal Returns true if the two xs:gDay values have thesame starting instant, when considered as days in the same month ofthe same year. The following comparison operators are defined on the [XML Schema Part 2: Datatypes Second Edition]date/time datatypes. Each operator takes two operands of the sametype and returns an xs:boolean result. [XML Schema Part 2: Datatypes SecondEdition] also states that the order relation on date and timedatatypes is not a total order but a partial order because thesedatatypes may or may not have a timezone. This is handled asfollows. If either operand to a comparison function on date or timevalues does not have an (explicit) timezone then, for the purposeof the operation, an implicit timezone, provided by the dynamiccontext Section C.2 Dynamic Context ComponentsXP30, is assumed to be present as part ofthe value. This creates a total order for all date and timevalues. An xs:dateTime can be considered to consist ofseven components: year, month,day, hour, minute,second and timezone. Forxs:dateTime six components (year,month, day, hour,minute and second) are required andtimezone is optional. For other date/time values, ofthe first six components, some are required and others must beabsentDM30.Timezone is always optional. For example, forxs:date, the year, month andday components are required and hour,minute and second components must beabsent; for xs:time the hour,minute and second components are requiredand year, month and day aremissing; for xs:gDay, day is required andyear, month, hour,minute and second are missing. Note: In [Schema 1.1 Part 2], a newexplicitTimezone facet is available with valuesoptional, required, orprohibited to enable the timezone to be defined asmandatory or disallowed. Values of the date/time datatypes xs:time,xs:gMonthDay, xs:gMonth, andxs:gDay, can be considered to represent a sequence ofrecurring time instants or time periods. An xs:timeoccurs every day. An xs:gMonth occurs every year.Comparison operators on these datatypes compare the startinginstants of equivalent occurrences in the recurring series. Thesexs:dateTime values are calculated as describedbelow. Comparison operators on xs:date,xs:gYearMonth and xs:gYear compare theirstarting instants. These xs:dateTime values arecalculated as described below. The starting instant of an occurrence of a date/time value is anxs:dateTime calculated by filling in the missingcomponents of the local value from a referencexs:dateTime. An example of a suitable referencexs:dateTime is 1972-01-01T00:00:00. Then,for example, the starting instant corresponding to thexs:date value 2009-03-12 is2009-03-12T00:00:00; the starting instantcorresponding to the xs:time value13:30:02 is 1972-01-01T13:30:02; and thestarting instant corresponding to the gMonthDay value--02-29 is 1972-02-29T00:00:00 (whichexplains why a leap year was chosen for the reference). Note: In the previous version of this specification, the referencedate/time chosen was 1972-12-31T00:00:00. While thisgives the same results, it produces a "starting instant" for agMonth or gMonthDay that bears norelation to the ordinary meaning of the term, and it also requiredspecial handling of short months. The original choice was made toallow for leap seconds; but since leap seconds are not recognizedin date/time arithmetic, this is not actually necessary. If the xs:time value written as24:00:00 is to be compared, filling in the missingcomponents gives 1972-01-01T00:00:00, because24:00:00 is an alternative representation of00:00:00 (the lexical value "24:00:00" isconverted to the time components {0,0,0} before the missingcomponents are filled in). This has the consequence that whenordering xs:time values, 24:00:00 isconsidered to be earlier than 23:59:59. However, whenordering xs:dateTime values, a time component of24:00:00 is considered equivalent to00:00:00 on the following day. Note that the reference xs:dateTime does not have atimezone. The timezone component is never filled infrom the reference xs:dateTime. In some cases, if thedate/time value does not have a timezone, the implicit timezonefrom the dynamic context is used as the timezone. Note: This specification uses the reference xs:dateTime1972-01-01T00:00:00 in the description of the comparisonoperators. Implementations may use other referencexs:dateTime values as long as they yield the sameresults. The reference xs:dateTime used must meet thefollowing constraints: when it is used to supply components intoxs:gMonthDay values, the year must allow for February29 and so must be a leap year; when it is used to supply missingcomponents into xs:gDay values, the month must allowfor 31 days. Different reference xs:dateTime valuesmay be used for different operators. 9.4.1 op:dateTime-equal Summary Returns true if the two supplied xs:dateTime valuesrefer to the same instant in time. Operator Mapping Defines the semantics of the "eq" operator when applied to twoxs:dateTime values. Also used in the definition of the"ne", "le" and "ge" operators. Signature op:dateTime-equal($arg1 as xs:dateTime,$arg2 as xs:dateTime) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules If either $arg1 or $arg2 has notimezone component, the effective value of the argument is obtainedby substituting the implicit timezone from the dynamic evaluationcontext. The function then returns true if and only if theeffective value of $arg1 is equal to the effectivevalue of $arg2 according to the algorithm defined insection 3.2.7.4 of [XML Schema Part 2:Datatypes Second Edition] "Order relation on dateTime" forxs:dateTime values with timezones. Otherwise thefunction returns false. Examples Assume that the dynamic context provides an implicit timezonevalue of -05:00 The expressionop:dateTime-equal(xs:dateTime("2002-04-02T12:00:00-01:00"),xs:dateTime("2002-04-02T17:00:00+04:00")) returnstrue(). The expressionop:dateTime-equal(xs:dateTime("2002-04-02T12:00:00"),xs:dateTime("2002-04-02T23:00:00+06:00")) returnstrue(). The expressionop:dateTime-equal(xs:dateTime("2002-04-02T12:00:00"),xs:dateTime("2002-04-02T17:00:00")) returnsfalse(). The expressionop:dateTime-equal(xs:dateTime("2002-04-02T12:00:00"),xs:dateTime("2002-04-02T12:00:00")) returnstrue(). The expressionop:dateTime-equal(xs:dateTime("2002-04-02T23:00:00-04:00"),xs:dateTime("2002-04-03T02:00:00-01:00")) returnstrue(). The expressionop:dateTime-equal(xs:dateTime("1999-12-31T24:00:00"),xs:dateTime("2000-01-01T00:00:00")) returnstrue(). The expressionop:dateTime-equal(xs:dateTime("2005-04-04T24:00:00"),xs:dateTime("2005-04-04T00:00:00")) returnsfalse(). 9.4.2 op:dateTime-less-than Summary Returns true if the first argument represents anearlier instant in time than the second argument. Operator Mapping Defines the semantics of the "lt" operator when applied to twoxs:dateTime values. Also used in the definition of the"ge" operator. Signature op:dateTime-less-than($arg1 as xs:dateTime,$arg2 as xs:dateTime) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules If either $arg1 or $arg2 has notimezone component, the effective value of the argument is obtainedby substituting the implicit timezone from the dynamic evaluationcontext. The function then returns true if and only if theeffective value of $arg1 is less than the effectivevalue of $arg2 according to the algorithm defined insection 3.2.7.4 of [XML Schema Part 2:Datatypes Second Edition] "Order relation on dateTime" forxs:dateTime values with timezones. Otherwise thefunction returns false. 9.4.3op:dateTime-greater-than Summary Returns true if the first argument represents alater instant in time than the second argument. Operator Mapping Defines the semantics of the "gt" operator when applied to twoxs:dateTime values. Also used in the definition of the"le" operator. Signature op:dateTime-greater-than( $arg1 as xs:dateTime, $arg2 as xs:dateTime) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules The function call op:dateTime-greater-than($A, $B)is defined to return the same result as op:dateTime-less-than($B,$A) 9.4.4op:date-equal Summary Returns true if and only if the starting instantsof the two supplied xs:date values are the same. Operator Mapping Defines the semantics of the "eq" operator when applied to twoxs:date values. Also used in the definition of the"ne", "le" and "ge" operators. Signature op:date-equal($arg1 as xs:date,$arg2 as xs:date) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules The starting instant of an xs:date is thexs:dateTime at time 00:00:00 on thatdate. The function returns the result of the expression: op:dateTime-equal(xs:dateTime($arg1), xs:dateTime($arg2)) Examples The expression op:date-equal(xs:date("2004-12-25Z"),xs:date("2004-12-25+07:00")) returns false().(The starting instants arexs:dateTime("2004-12-25T00:00:00Z") andxs:dateTime("2004-12-25T00:00:00+07:00"). These arenormalized to xs:dateTime("2004-12-25T00:00:00Z") andxs:dateTime("2004-12-24T17:00:00Z"). ). The expression op:date-equal(xs:date("2004-12-25-12:00"),xs:date("2004-12-26+12:00")) returnstrue(). 9.4.5 op:date-less-than Summary Returns true if and only if the starting instant of$arg1 is less than the starting instant of$arg2. Returns false otherwise. Operator Mapping Defines the semantics of the "lt" operator when applied to twoxs:date values. Also used in the definition of the"ge" operator. Signature op:date-less-than($arg1 as xs:date,$arg2 as xs:date) as xs:boolean Rules The starting instant of an xs:date is thexs:dateTime at time 00:00:00 on thatdate. The function returns the result of the expression: op:dateTime-less-than(xs:dateTime($arg1), xs:dateTime($arg2)) Examples The expression op:date-less-than(xs:date("2004-12-25Z"),xs:date("2004-12-25-05:00")) returnstrue(). The expressionop:date-less-than(xs:date("2004-12-25-12:00"),xs:date("2004-12-26+12:00")) returnsfalse(). 9.4.6 op:date-greater-than Summary Returns true if and only if the starting instant of$arg1 is greater than the starting instant of$arg2. Returns false otherwise. Operator Mapping Defines the semantics of the "gt" operator when applied to twoxs:date values. Also used in the definition of the"le" operator. Signature op:date-greater-than($arg1 as xs:date,$arg2 as xs:date) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules The function call op:date-greater-than($A, $B) isdefined to return the same result as op:date-less-than($B,$A) Examples The expressionop:date-greater-than(xs:date("2004-12-25Z"),xs:date("2004-12-25+07:00")) returnstrue(). The expressionop:date-greater-than(xs:date("2004-12-25-12:00"),xs:date("2004-12-26+12:00")) returnsfalse(). 9.4.7op:time-equal Summary Returns true if the two xs:time valuesrepresent the same instant in time, when treated as being times onthe same date, before adjusting the timezone. Operator Mapping Defines the semantics of the "eq" operator when applied to twoxs:time values. Also used in the definition of the"ne", "le" and "ge" operators. Signature op:time-equal($arg1 as xs:time,$arg2 as xs:time) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules Each of the supplied xs:time values is expanded toan xs:dateTime value by associating the time with anarbitrary date. The function returns the result of comparing thesetwo xs:dateTime values using op:dateTime-equal. The result of the function is thus the same as the value of theexpression: op:dateTime-equal(        fn:dateTime(xs:date('1972-12-31'), $arg1),         fn:dateTime(xs:date('1972-12-31'), $arg2)) Examples Assume that the date components from the referencexs:dateTime correspond to 1972-12-31. The expression op:time-equal(xs:time("08:00:00+09:00"),xs:time("17:00:00-06:00")) returns false().(The xs:dateTimes calculated using the referencedate components are 1972-12-31T08:00:00+09:00 and1972-12-31T17:00:00-06:00. These normalize to1972-12-30T23:00:00Z and1972-12-31T23:00:00Z. ). The expression op:time-equal(xs:time("21:30:00+10:30"),xs:time("06:00:00-05:00")) returns true(). The expression op:time-equal(xs:time("24:00:00+01:00"),xs:time("00:00:00+01:00")) returns true().(This not the result one might expect. Forxs:dateTime values, a time of 24:00:00 isequivalent to 00:00:00 on the following day. Forxs:time, the normalization from 24:00:00to 00:00:00 happens before the xs:time isconverted into an xs:dateTime for the purpose of theequality comparison. For xs:time, any operation on24:00:00 produces the same result as the sameoperation on 00:00:00 because these are two differentlexical representations of the same value. ). 9.4.8 op:time-less-than Summary Returns true if the first xs:timevalue represents an earlier instant in time than the second, whenboth are treated as being times on the same date, before adjustingthe timezone. Operator Mapping Defines the semantics of the "lt" operator when applied to twoxs:time values. Also used in the definition of the"ge" operator. Signature op:time-less-than($arg1 as xs:time,$arg2 as xs:time) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules Each of the supplied xs:time values is expanded toan xs:dateTime value by associating the time with anarbitrary date. The function returns the result of comparing thesetwo xs:dateTime values using op:dateTime-less-than. The result of the function is thus the same as the value of theexpression: op:dateTime-less-than(        fn:dateTime(xs:date('1972-12-31'), $arg1),         fn:dateTime(xs:date('1972-12-31'), $arg2)) Examples Assume that the dynamic context provides an implicit timezonevalue of -05:00. The expression op:time-less-than(xs:time("12:00:00"),xs:time("23:00:00+06:00")) returns false(). The expression op:time-less-than(xs:time("11:00:00"),xs:time("17:00:00Z")) returns true(). The expression op:time-less-than(xs:time("23:59:59"),xs:time("24:00:00")) returns false(). 9.4.9 op:time-greater-than Summary Returns true if the first xs:timevalue represents a later instant in time than the second, when bothare treated as being times on the same date, before adjusting thetimezone. Operator Mapping Defines the semantics of the "gt" operator when applied to twoxs:time values. Also used in the definition of the"le" operator. Signature op:time-greater-than($arg1 as xs:time,$arg2 as xs:time) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules The function call op:time-greater-than($A, $B) isdefined to return the same result as op:time-less-than($B,$A) Examples The expressionop:time-greater-than(xs:time("08:00:00+09:00"),xs:time("17:00:00-06:00")) returns false(). 9.4.10 op:gYearMonth-equal Summary Returns true if the two xs:gYearMonth values havethe same starting instant. Operator Mapping Defines the semantics of the "eq" operator when applied to twoxs:gYearMonth values. Also used in the definition ofthe "ne" operator. Signature op:gYearMonth-equal( $arg1 as xs:gYearMonth, $arg2 as xs:gYearMonth) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules The starting instants of $arg1 and$arg2 are calculated by supplying the missingcomponents of $arg1 and $arg2 from thexs:dateTime template xxxx-xx-01T00:00:00.The function returns the result of comparing these two startinginstants using op:dateTime-equal. Examples Assume that the dynamic context provides an implicit timezonevalue of -05:00. op:gYearMonth-equal(xs:gYearMonth("1986-02"),xs:gYearMonth("1986-03")) returns false(). Thestarting instants are 1986-02-01T00:00:00-05:00 and1986-03-01T00:00:00, respectively. op:gYearMonth-equal(xs:gYearMonth("1978-03"),xs:gYearMonth("1986-03Z")) returns false(). Thestarting instants are 1978-03-01T00:00:00-05:00 and1986-03-01T00:00:00Z, respectively. 9.4.11op:gYear-equal Summary Returns true if the two xs:gYear values have thesame starting instant. Operator Mapping Defines the semantics of the "eq" operator when applied to twoxs:gYear values. Also used in the definition of the"ne" operator. Signature op:gYear-equal($arg1 as xs:gYear,$arg2 as xs:gYear) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules The starting instants of $arg1 and$arg2 are calculated by supplying the missingcomponents of $arg1 and $arg2 from thexs:dateTime template xxxx-01-01T00:00:00.The function returns the result of comparing these two startinginstants using op:dateTime-equal. Examples Assume that the dynamic context provides an implicit timezonevalue of -05:00. Assume, also, that thexs:dateTime template isxxxx-01-01T00:00:00. op:gYear-equal(xs:gYear("2005-12:00"),xs:gYear("2005+12:00")) returns false(). Thestarting instants are 2005-01-01T00:00:00-12:00 and2005-01-01T00:00:00+12:00, respectively, and normalizeto 2005-01-01T12:00:00Z and2004-12-31T12:00:00Z. The expression op:gYear-equal(xs:gYear("1976-05:00"),xs:gYear("1976")) returns true(). 9.4.12 op:gMonthDay-equal Summary Returns true if the two xs:gMonthDay values havethe same starting instant, when considered as days in the sameyear. Operator Mapping Defines the semantics of the "eq" operator when applied to twoxs:gMonthDay values. Also used in the definition ofthe "ne" operator. Signature op:gMonthDay-equal($arg1 as xs:gMonthDay,$arg2 as xs:gMonthDay) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules The starting instants of $arg1 and$arg2 are calculated by supplying the missingcomponents of $arg1 and $arg2 from thexs:dateTime template 1972-xx-xxT00:00:00or an equivalent. The function returns the result of comparingthese two starting instants using op:dateTime-equal. Examples Assume that the dynamic context provides an implicit timezonevalue of -05:00. Assume for the purposes ofillustration that the xs:dateTime template used is1972-xx-xxT00:00:00 (this does not affect theresult). The expressionop:gMonthDay-equal(xs:gMonthDay("--12-25-14:00"),xs:gMonthDay("--12-26+10:00")) returns true().( The starting instants are1972-12-25T00:00:00-14:00 and1972-12-26T00:00:00+10:00, respectively, and normalizeto 1972-12-25T14:00:00Z and1972-12-25T14:00:00Z. ). The expression op:gMonthDay-equal(xs:gMonthDay("--12-25"),xs:gMonthDay("--12-26Z")) returns false(). 9.4.13op:gMonth-equal Summary Returns true if the two xs:gMonth values have thesame starting instant, when considered as months in the sameyear. Operator Mapping Defines the semantics of the "eq" operator when applied to twoxs:gMonth values. Also used in the definition of the"ne" operator. Signature op:gMonth-equal($arg1 as xs:gMonth,$arg2 as xs:gMonth) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules The starting instants of $arg1 and$arg2 are calculated by supplying the missingcomponents of $arg1 and $arg2 from thexs:dateTime template 1972-xx-01T00:00:00or an equivalent. The function returns the result of comparingthese two starting instants using op:dateTime-equal. Examples Assume that the dynamic context provides an implicit timezonevalue of -05:00. Assume, also, that thexs:dateTime template chosen is1972-xx-01T00:00:00. The expression op:gMonth-equal(xs:gMonth("--12-14:00"),xs:gMonth("--12+10:00")) returns false(). (The starting instants are 1972-12-01T00:00:00-14:00and 1972-12-01T00:00:00+10:00, respectively, andnormalize to 1972-11-30T14:00:00Z and1972-12-01T14:00:00Z. ). The expression op:gMonth-equal(xs:gMonth("--12"),xs:gMonth("--12Z")) returns false(). 9.4.14op:gDay-equal Summary Returns true if the two xs:gDay values have thesame starting instant, when considered as days in the same month ofthe same year. Operator Mapping Defines the semantics of the "eq" operator when applied to twoxs:gDay values. Also used in the definition of the"ne" operator. Signature op:gDay-equal($arg1 as xs:gDay,$arg2 as xs:gDay) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules The starting instants of $arg1 and$arg2 are calculated by supplying the missingcomponents of $arg1 and $arg2 from thexs:dateTime template 1972-12-xxT00:00:00or an equivalent. The function returns the result of comparingthese two starting instants using op:dateTime-equal. Examples Assume that the dynamic context provides an implicit timezonevalue of -05:00. Assume, also, that thexs:dateTime template is1972-12-xxT00:00:00. The expression op:gDay-equal(xs:gDay("---25-14:00"),xs:gDay("---25+10:00")) returns false(). (The starting instants are 1972-12-25T00:00:00-14:00and 1972-12-25T00:00:00+10:00, respectively, andnormalize to 1972-12-25T14:00:00Z and1972-12-24T14:00:00Z. ). The expression op:gDay-equal(xs:gDay("---12"),xs:gDay("---12Z")) returns false(). 9.5 Component extractionfunctions on dates and times The date and time datatypes may be considered to be compositedatatypes in that they contain distinct properties or components.The extraction functions specified below extract a single componentfrom a date or time value. In all cases the local value (that is,the original value as written, without any timezone adjustment) isused. Note: A time written as 24:00:00 is treated as00:00:00 on the following day. Function Meaning fn:year-from-dateTime Returns the year component of an xs:dateTime. fn:month-from-dateTime Returns the month component of anxs:dateTime. fn:day-from-dateTime Returns the day component of an xs:dateTime. fn:hours-from-dateTime Returns the hours component of anxs:dateTime. fn:minutes-from-dateTime Returns the minute component of anxs:dateTime. fn:seconds-from-dateTime Returns the seconds component of anxs:dateTime. fn:timezone-from-dateTime Returns the timezone component of anxs:dateTime. fn:year-from-date Returns the year component of an xs:date. fn:month-from-date Returns the month component of an xs:date. fn:day-from-date Returns the day component of an xs:date. fn:timezone-from-date Returns the timezone component of an xs:date. fn:hours-from-time Returns the hours component of an xs:time. fn:minutes-from-time Returns the minutes component of an xs:time. fn:seconds-from-time Returns the seconds component of an xs:time. fn:timezone-from-time Returns the timezone component of an xs:time. 9.5.1 fn:year-from-dateTime Summary Returns the year component of an xs:dateTime. Signature fn:year-from-dateTime($arg as xs:dateTime?) as xs:integer? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns an xs:integerrepresenting the year component in the local value of$arg. The result may be negative. Examples The expressionfn:year-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))returns 1999. The expressionfn:year-from-dateTime(xs:dateTime("1999-05-31T21:30:00-05:00"))returns 1999. The expressionfn:year-from-dateTime(xs:dateTime("1999-12-31T19:20:00"))returns 1999. The expressionfn:year-from-dateTime(xs:dateTime("1999-12-31T24:00:00"))returns 2000. 9.5.2 fn:month-from-dateTime Summary Returns the month component of an xs:dateTime. Signature fn:month-from-dateTime($arg as xs:dateTime?) as xs:integer? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns an xs:integerbetween 1 and 12, both inclusive, representing the month componentin the local value of $arg. Examples The expressionfn:month-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))returns 5. The expressionfn:month-from-dateTime(xs:dateTime("1999-12-31T19:20:00-05:00"))returns 12. The expressionfn:month-from-dateTime(fn:adjust-dateTime-to-timezone(xs:dateTime("1999-12-31T19:20:00-05:00"),xs:dayTimeDuration("PT0S"))) returns 1. 9.5.3 fn:day-from-dateTime Summary Returns the day component of an xs:dateTime. Signature fn:day-from-dateTime($arg as xs:dateTime?) as xs:integer? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns an xs:integerbetween 1 and 31, both inclusive, representing the day component inthe local value of $arg. Examples The expressionfn:day-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))returns 31. The expressionfn:day-from-dateTime(xs:dateTime("1999-12-31T20:00:00-05:00"))returns 31. The expressionfn:day-from-dateTime(fn:adjust-dateTime-to-timezone(xs:dateTime("1999-12-31T19:20:00-05:00"),xs:dayTimeDuration("PT0S"))) returns 1. 9.5.4 fn:hours-from-dateTime Summary Returns the hours component of an xs:dateTime. Signature fn:hours-from-dateTime($arg as xs:dateTime?) as xs:integer? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns an xs:integerbetween 0 and 23, both inclusive, representing the hours componentin the local value of $arg. Examples The expressionfn:hours-from-dateTime(xs:dateTime("1999-05-31T08:20:00-05:00"))returns 8. The expressionfn:hours-from-dateTime(xs:dateTime("1999-12-31T21:20:00-05:00"))returns 21. The expressionfn:hours-from-dateTime(fn:adjust-dateTime-to-timezone(xs:dateTime("1999-12-31T21:20:00-05:00"),xs:dayTimeDuration("PT0S"))) returns 2. The expressionfn:hours-from-dateTime(xs:dateTime("1999-12-31T12:00:00"))returns 12. The expressionfn:hours-from-dateTime(xs:dateTime("1999-12-31T24:00:00"))returns 0. 9.5.5fn:minutes-from-dateTime Summary Returns the minute component of an xs:dateTime. Signature fn:minutes-from-dateTime($arg as xs:dateTime?) as xs:integer? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns an xs:integer valuebetween 0 and 59, both inclusive, representing the minute componentin the local value of $arg. Examples The expressionfn:minutes-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))returns 20. The expressionfn:minutes-from-dateTime(xs:dateTime("1999-05-31T13:30:00+05:30"))returns 30. 9.5.6fn:seconds-from-dateTime Summary Returns the seconds component of anxs:dateTime. Signature fn:seconds-from-dateTime($arg as xs:dateTime?) as xs:decimal? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns an xs:decimal valuegreater than or equal to zero and less than 60, representing theseconds and fractional seconds in the local value of$arg. Examples The expressionfn:seconds-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))returns 0. 9.5.7fn:timezone-from-dateTime Summary Returns the timezone component of anxs:dateTime. Signature fn:timezone-from-dateTime($arg as xs:dateTime?) as xs:dayTimeDuration? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns the timezone component of$arg, if any. If $arg has a timezonecomponent, then the result is an xs:dayTimeDurationthat indicates deviation from UTC; its value may range from +14:00to -14:00 hours, both inclusive. If $arg has notimezone component, the result is the empty sequence. Examples The expressionfn:timezone-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))returns xs:dayTimeDuration("-PT5H"). The expressionfn:timezone-from-dateTime(xs:dateTime("2000-06-12T13:20:00Z"))returns xs:dayTimeDuration("PT0S"). The expressionfn:timezone-from-dateTime(xs:dateTime("2004-08-27T00:00:00"))returns (). 9.5.8 fn:year-from-date Summary Returns the year component of an xs:date. Signature fn:year-from-date($arg as xs:date?) as xs:integer? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns an xs:integerrepresenting the year in the local value of $arg. Thevalue may be negative. Examples The expressionfn:year-from-date(xs:date("1999-05-31")) returns1999. The expressionfn:year-from-date(xs:date("2000-01-01+05:00")) returns2000. 9.5.9 fn:month-from-date Summary Returns the month component of an xs:date. Signature fn:month-from-date($arg as xs:date?) as xs:integer? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns an xs:integerbetween 1 and 12, both inclusive, representing the month componentin the local value of $arg. Examples The expressionfn:month-from-date(xs:date("1999-05-31-05:00"))returns 5. The expressionfn:month-from-date(xs:date("2000-01-01+05:00"))returns 1. 9.5.10fn:day-from-date Summary Returns the day component of an xs:date. Signature fn:day-from-date($arg as xs:date?) as xs:integer? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns an xs:integerbetween 1 and 31, both inclusive, representing the day component inthe localized value of $arg. Examples The expressionfn:day-from-date(xs:date("1999-05-31-05:00")) returns31. The expressionfn:day-from-date(xs:date("2000-01-01+05:00")) returns1. 9.5.11 fn:timezone-from-date Summary Returns the timezone component of an xs:date. Signature fn:timezone-from-date($arg as xs:date?) as xs:dayTimeDuration? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns the timezone component of$arg, if any. If $arg has a timezonecomponent, then the result is an xs:dayTimeDurationthat indicates deviation from UTC; its value may range from +14:00to -14:00 hours, both inclusive. If $arg has notimezone component, the result is the empty sequence. Examples The expressionfn:timezone-from-date(xs:date("1999-05-31-05:00"))returns xs:dayTimeDuration("-PT5H"). The expressionfn:timezone-from-date(xs:date("2000-06-12Z")) returnsxs:dayTimeDuration("PT0S"). 9.5.12 fn:hours-from-time Summary Returns the hours component of an xs:time. Signature fn:hours-from-time($arg as xs:time?) as xs:integer? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns an xs:integerbetween 0 and 23, both inclusive, representing the value of thehours component in the local value of $arg. Examples Assume that the dynamic context provides an implicit timezonevalue of -05:00. The expressionfn:hours-from-time(xs:time("11:23:00")) returns11. The expressionfn:hours-from-time(xs:time("21:23:00")) returns21. The expressionfn:hours-from-time(xs:time("01:23:00+05:00")) returns1. The expressionfn:hours-from-time(fn:adjust-time-to-timezone(xs:time("01:23:00+05:00"),xs:dayTimeDuration("PT0S"))) returns 20. The expressionfn:hours-from-time(xs:time("24:00:00")) returns0. 9.5.13 fn:minutes-from-time Summary Returns the minutes component of an xs:time. Signature fn:minutes-from-time($arg as xs:time?) as xs:integer? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns an xs:integer valuebetween 0 and 59, both inclusive, representing the value of theminutes component in the local value of $arg. Examples The expressionfn:minutes-from-time(xs:time("13:00:00Z")) returns0. 9.5.14 fn:seconds-from-time Summary Returns the seconds component of an xs:time. Signature fn:seconds-from-time($arg as xs:time?) as xs:decimal? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns an xs:decimal valuegreater than or equal to zero and less than 60, representing theseconds and fractional seconds in the local value of$arg. Examples The expressionfn:seconds-from-time(xs:time("13:20:10.5")) returns10.5. 9.5.15 fn:timezone-from-time Summary Returns the timezone component of an xs:time. Signature fn:timezone-from-time($arg as xs:time?) as xs:dayTimeDuration? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the function returnsthe empty sequence. Otherwise, the function returns the timezone component of$arg, if any. If $arg has a timezonecomponent, then the result is an xs:dayTimeDurationthat indicates deviation from UTC; its value may range from +14:00to -14:00 hours, both inclusive. If $arg has notimezone component, the result is the empty sequence. Examples The expressionfn:timezone-from-time(xs:time("13:20:00-05:00"))returns xs:dayTimeDuration("-PT5H"). The expressionfn:timezone-from-time(xs:time("13:20:00")) returns(). 9.6Timezone adjustment functions on dates and time values Function Meaning fn:adjust-dateTime-to-timezone Adjusts an xs:dateTime value to a specifictimezone, or to no timezone at all. fn:adjust-date-to-timezone Adjusts an xs:date value to a specific timezone,or to no timezone at all; the result is the date in the targettimezone that contains the starting instant of the supplieddate. fn:adjust-time-to-timezone Adjusts an xs:time value to a specific timezone,or to no timezone at all. These functions adjust the timezone component of anxs:dateTime, xs:date orxs:time value. The $timezone argument tothese functions is defined as an xs:dayTimeDurationbut must be a valid timezone value. 9.6.1fn:adjust-dateTime-to-timezone Summary Adjusts an xs:dateTime value to a specifictimezone, or to no timezone at all. Signatures fn:adjust-dateTime-to-timezone($arg as xs:dateTime?) as xs:dateTime? fn:adjust-dateTime-to-timezone( $arg as xs:dateTime?, $timezone as xs:dayTimeDuration?) as xs:dateTime? Properties The one-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. The two-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $timezone is not specified, then the effectivevalue of $timezone is the value of the implicittimezone in the dynamic context. If $arg is the empty sequence, then the functionreturns the empty sequence. If $arg does not have a timezone component and$timezone is the empty sequence, then the result is$arg. If $arg does not have a timezone component and$timezone is not the empty sequence, then the resultis $arg with $timezone as the timezonecomponent. If $arg has a timezone component and$timezone is the empty sequence, then the result isthe local value of $arg without its timezonecomponent. If $arg has a timezone component and$timezone is not the empty sequence, then the resultis the xs:dateTime value that is equal to$arg and that has a timezone component equal to$timezone. Error Conditions A dynamic error is raised [err:FODT0003] if $timezone isless than -PT14H or greater than PT14H oris not an integral number of minutes. Examples Assume the dynamic context provides an implicit timezone of-05:00 (-PT5H0M). let $tz-10 :=xs:dayTimeDuration("-PT10H") The expressionfn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00'))returns xs:dateTime('2002-03-07T10:00:00-05:00'). The expressionfn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00-07:00'))returns xs:dateTime('2002-03-07T12:00:00-05:00'). The expressionfn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00'),$tz-10) returnsxs:dateTime('2002-03-07T10:00:00-10:00'). The expressionfn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00-07:00'),$tz-10) returnsxs:dateTime('2002-03-07T07:00:00-10:00'). The expressionfn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00-07:00'),xs:dayTimeDuration("PT10H")) returnsxs:dateTime('2002-03-08T03:00:00+10:00'). The expressionfn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T00:00:00+01:00'),xs:dayTimeDuration("-PT8H")) returnsxs:dateTime('2002-03-06T15:00:00-08:00'). The expressionfn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00'),()) returnsxs:dateTime('2002-03-07T10:00:00'). The expressionfn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00-07:00'),()) returnsxs:dateTime('2002-03-07T10:00:00'). 9.6.2fn:adjust-date-to-timezone Summary Adjusts an xs:date value to a specific timezone, orto no timezone at all; the result is the date in the targettimezone that contains the starting instant of the supplieddate. Signatures fn:adjust-date-to-timezone($arg as xs:date?) as xs:date? fn:adjust-date-to-timezone( $arg as xs:date?, $timezone as xs:dayTimeDuration?) as xs:date? Properties The one-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. The two-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $timezone is not specified, then the effectivevalue of $timezone is the value of the implicittimezone in the dynamic context. If $arg is the empty sequence, then the functionreturns the empty sequence. If $arg does not have a timezone component and$timezone is the empty sequence, then the result isthe value of $arg. If $arg does not have a timezone component and$timezone is not the empty sequence, then the resultis $arg with $timezone as the timezonecomponent. If $arg has a timezone component and$timezone is the empty sequence, then the result isthe local value of $arg without its timezonecomponent. If $arg has a timezone component and$timezone is not the empty sequence, then the functionreturns the value of the expression: Let $dt be the value of fn:dateTime($arg,xs:time('00:00:00')). Let $adt be the value of fn:adjust-dateTime-to-timezone($dt,$timezone) The function returns the value of xs:date($adt) Error Conditions A dynamic error is raised [err:FODT0003] if $timezone isless than -PT14H or greater than PT14H oris not an integral number of minutes. Examples Assume the dynamic context provides an implicit timezone of-05:00 (-PT5H0M). let $tz-10 :=xs:dayTimeDuration("-PT10H") The expressionfn:adjust-date-to-timezone(xs:date("2002-03-07"))returns xs:date("2002-03-07-05:00"). The expressionfn:adjust-date-to-timezone(xs:date("2002-03-07-07:00"))returns xs:date("2002-03-07-05:00").($arg is converted toxs:dateTime("2002-03-07T00:00:00-07:00"). This isadjusted to the implicit timezone, giving"2002-03-07T02:00:00-05:00". ). The expressionfn:adjust-date-to-timezone(xs:date("2002-03-07"),$tz-10) returnsxs:date("2002-03-07-10:00"). The expressionfn:adjust-date-to-timezone(xs:date("2002-03-07-07:00"),$tz-10) returns xs:date("2002-03-06-10:00").($arg is converted to the xs:dateTime"2002-03-07T00:00:00-07:00". This is adjusted to the giventimezone, giving "2002-03-06T21:00:00-10:00".). The expressionfn:adjust-date-to-timezone(xs:date("2002-03-07"), ())returns xs:date("2002-03-07"). The expressionfn:adjust-date-to-timezone(xs:date("2002-03-07-07:00"),()) returns xs:date("2002-03-07"). 9.6.3fn:adjust-time-to-timezone Summary Adjusts an xs:time value to a specific timezone, orto no timezone at all. Signatures fn:adjust-time-to-timezone($arg as xs:time?) as xs:time? fn:adjust-time-to-timezone( $arg as xs:time?, $timezone as xs:dayTimeDuration?) as xs:time? Properties The one-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. The two-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $timezone is not specified, then the effectivevalue of $timezone is the value of the implicittimezone in the dynamic context. If $arg is the empty sequence, then the functionreturns the empty sequence. If $arg does not have a timezone component and$timezone is the empty sequence, then the result is$arg. If $arg does not have a timezone component and$timezone is not the empty sequence, then the resultis $arg with $timezone as the timezonecomponent. If $arg has a timezone component and$timezone is the empty sequence, then the result isthe localized value of $arg without its timezonecomponent. If $arg has a timezone component and$timezone is not the empty sequence, then: Let $dt be the xs:dateTime valuefn:dateTime(xs:date('1972-12-31'),$arg). Let $adt be the value of fn:adjust-dateTime-to-timezone($dt,$timezone) The function returns the xs:time valuexs:time($adt). Error Conditions A dynamic error is raised [err:FODT0003] if $timezone isless than -PT14H or greater than PT14H orif does not contain an integral number of minutes. Examples Assume the dynamic context provides an implicit timezone of-05:00 (-PT5H0M). let $tz-10 :=xs:dayTimeDuration("-PT10H") The expressionfn:adjust-time-to-timezone(xs:time("10:00:00"))returns xs:time("10:00:00-05:00"). The expressionfn:adjust-time-to-timezone(xs:time("10:00:00-07:00"))returns xs:time("12:00:00-05:00"). The expressionfn:adjust-time-to-timezone(xs:time("10:00:00"),$tz-10) returns xs:time("10:00:00-10:00"). The expressionfn:adjust-time-to-timezone(xs:time("10:00:00-07:00"),$tz-10) returns xs:time("07:00:00-10:00"). The expressionfn:adjust-time-to-timezone(xs:time("10:00:00"), ())returns xs:time("10:00:00"). The expressionfn:adjust-time-to-timezone(xs:time("10:00:00-07:00"),()) returns xs:time("10:00:00"). The expressionfn:adjust-time-to-timezone(xs:time("10:00:00-07:00"),xs:dayTimeDuration("PT10H")) returnsxs:time("03:00:00+10:00"). 9.7Arithmetic operators on durations, dates and times These functions support adding or subtracting a duration valueto or from an xs:dateTime, an xs:date oran xs:time value. Appendix E of [XML Schema Part 2: Datatypes Second Edition]describes an algorithm for performing such operations. Function Meaning op:subtract-dateTimes Returns an xs:dayTimeDuration representing theamount of elapsed time between the instants arg2 andarg1. op:subtract-dates Returns the xs:dayTimeDuration that corresponds tothe elapsed time between the starting instant of $arg2and the starting instant of $arg2. op:subtract-times Returns the xs:dayTimeDuration that corresponds tothe elapsed time between the values of $arg2 and$arg1 treated as times on the same date. op:add-yearMonthDuration-to-dateTime Returns the xs:dateTime that is a given durationafter a specified xs:dateTime (or before, if theduration is negative). op:add-dayTimeDuration-to-dateTime Returns the xs:dateTime that is a given durationafter a specified xs:dateTime (or before, if theduration is negative). op:subtract-yearMonthDuration-from-dateTime Returns the xs:dateTime that is a given durationbefore a specified xs:dateTime (or after, if theduration is negative). op:subtract-dayTimeDuration-from-dateTime Returns the xs:dateTime that is a given durationbefore a specified xs:dateTime (or after, if theduration is negative). op:add-yearMonthDuration-to-date Returns the xs:date that is a given duration aftera specified xs:date (or before, if the duration isnegative). op:add-dayTimeDuration-to-date Returns the xs:date that is a given duration aftera specified xs:date (or before, if the duration isnegative). op:subtract-yearMonthDuration-from-date Returns the xs:date that is a given durationbefore a specified xs:date (or after, if the durationis negative). op:subtract-dayTimeDuration-from-date Returns the xs:date that is a given durationbefore a specified xs:date (or after, if the durationis negative). op:add-dayTimeDuration-to-time Returns the xs:time value that is a given durationafter a specified xs:time (or before, if the durationis negative or causes wrap-around past midnight) op:subtract-dayTimeDuration-from-time Returns the xs:time value that is a given durationbefore a specified xs:time (or after, if the durationis negative or causes wrap-around past midnight) 9.7.1 Limitsand precision A processor that limits the number of digits in date and timedatatype representations may encounter overflow and underflowconditions when it tries to execute the functions in this section.In these situations, the processor Â·mustÂ· return P0M or PT0S in case of durationunderflow and 00:00:00 in case of time underflow. It Â·mustÂ· raise adynamic error [err:FODT0001] in case of overflow. The value spaces of the two totally ordered subtypes ofxs:duration described in 8.1 Two totally ordered subtypes ofduration are xs:integer months forxs:yearMonthDuration and xs:decimalseconds for xs:dayTimeDuration. If a processor limitsthe number of digits allowed in the representation ofxs:integer and xs:decimal then overflowand underflow situations can arise when it tries to execute thefunctions in 8.4 Arithmeticoperators on durations. In these situations the processorÂ·mustÂ· return zero incase of numeric underflow and P0M or PT0S in case of durationunderflow. It Â·mustÂ· raise a dynamic error [err:FODT0002] in case ofoverflow. 9.7.2 op:subtract-dateTimes Summary Returns an xs:dayTimeDuration representing theamount of elapsed time between the instants arg2 andarg1. Operator Mapping Defines the semantics of the "-" operator when applied to twoxs:dateTime values. Signature op:subtract-dateTimes( $arg1 as xs:dateTime, $arg2 as xs:dateTime) as xs:dayTimeDuration Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules If either $arg1 or $arg2 do notcontain an explicit timezone then, for the purpose of theoperation, the implicit timezone provided by the dynamic context(See Section C.2 Dynamic Context ComponentsXP30.) is assumed to be present as partof the value. The function returns the elapsed time between the date/timeinstant arg2 and the date/time instantarg1, computed according to the algorithm given inAppendix E of [XML Schema Part 2: DatatypesSecond Edition], and expressed as axs:dayTimeDuration. If the normalized value of $arg1 precedes in timethe normalized value of $arg2, then the returned valueis a negative duration. Examples Assume that the dynamic context provides an implicit timezonevalue of -05:00. The expressionop:subtract-dateTimes(xs:dateTime("2000-10-30T06:12:00"),xs:dateTime("1999-11-28T09:00:00Z")) returnsxs:dayTimeDuration("P337DT2H12M"). 9.7.3 op:subtract-dates Summary Returns the xs:dayTimeDuration that corresponds tothe elapsed time between the starting instant of $arg2and the starting instant of $arg2. Operator Mapping Defines the semantics of the "-" operator when applied to twoxs:date values. Signature op:subtract-dates($arg1 as xs:date,$arg2 as xs:date) as xs:dayTimeDuration Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules If either $arg1 or $arg2 do notcontain an explicit timezone then, for the purpose of theoperation, the implicit timezone provided by the dynamic context(See Section C.2 Dynamic Context ComponentsXP30.) is assumed to be present as partof the value. The starting instant of an xs:date is thexs:dateTime at 00:00:00 on that date. The function returns the result of subtracting the two startinginstants using op:subtract-dateTimes. If the starting instant of $arg1 precedes in timethe starting instant of $arg2, then the returned valueis a negative duration. Examples Assume that the dynamic context provides an implicit timezonevalue of Z. The expression op:subtract-dates(xs:date("2000-10-30"),xs:date("1999-11-28")) returnsxs:dayTimeDuration("P337D"). (The normalizedvalues of the two starting instants are {2000, 10, 30, 0, 0,0, PT0S} and {1999, 11, 28, 0, 0, 0,PT0S}.). Now assume that the dynamic context provides an implicittimezone value of +05:00. The expression op:subtract-dates(xs:date("2000-10-30"),xs:date("1999-11-28Z")) returnsxs:dayTimeDuration("P336DT19H"). ( The normalizedvalues of the two starting instants are {2000, 10, 29, 19, 0,0, PT0S} and {1999, 11, 28, 0, 0, 0,PT0S}.). The expressionop:subtract-dates(xs:date("2000-10-15-05:00"),xs:date("2000-10-10+02:00")) returnsxs:dayTimeDuration("P5DT7H"). 9.7.4 op:subtract-times Summary Returns the xs:dayTimeDuration that corresponds tothe elapsed time between the values of $arg2 and$arg1 treated as times on the same date. Operator Mapping Defines the semantics of the "-" operator when applied to twoxs:time values. Signature op:subtract-times($arg1 as xs:time,$arg2 as xs:time) as xs:dayTimeDuration Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules The function returns the result of the expression: op-subtract-dateTimes(        fn:dateTime(xs:date('1972-12-31'), $arg1),        fn:dateTime(xs:date('1972-12-31'), $arg2)) Notes Any other reference date would work equally well. Examples Assume that the dynamic context provides an implicit timezonevalue of -05:00. Assume, also, that the datecomponents of the reference xs:dateTime correspond to"1972-12-31". The expression op:subtract-times(xs:time("11:12:00Z"),xs:time("04:00:00")) returnsxs:dayTimeDuration("PT2H12M"). (This is obtainedby subtracting from the xs:dateTime value {1972,12, 31, 11, 12, 0, PT0S} the xs:dateTime value{1972, 12, 31, 9, 0, 0, PT0S}.). The expressionop:subtract-times(xs:time("11:00:00-05:00"),xs:time("21:30:00+05:30")) returnsxs:dayTimeDuration("PT0S"). (The twoxs:dateTime values are {1972, 12, 31, 11, 0, 0,-PT5H} and {1972, 12, 31, 21, 30, 0, PT5H30M}.These normalize to {1972, 12, 31, 16, 0, 0, PT0S} and{1972, 12, 31, 16, 0, 0, PT0S}. ). The expressionop:subtract-times(xs:time("17:00:00-06:00"),xs:time("08:00:00+09:00")) returnsxs:dayTimeDuration("P1D"). (The two normalizedxs:dateTime values are {1972, 12, 31, 23, 0, 0,PT0S} and {1972, 12, 30, 23, 0, 0,PT0S}.). The expression op:subtract-times(xs:time("24:00:00"),xs:time("23:59:59")) returnsxs:dayTimeDuration("-PT23H59M59S"). (The twonormalized xs:dateTime values are {1972, 12, 31,0, 0, 0, ()} and {1972, 12, 31, 23, 59, 59.0,()}.). 9.7.5op:add-yearMonthDuration-to-dateTime Summary Returns the xs:dateTime that is a given durationafter a specified xs:dateTime (or before, if theduration is negative). Operator Mapping Defines the semantics of the "+" operator when applied to anxs:dateTime and an xs:yearMonthDurationvalue. Signature op:add-yearMonthDuration-to-dateTime( $arg1 as xs:dateTime, $arg2 as xs:yearMonthDuration) as xs:dateTime Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns the result of adding $arg2 tothe value of $arg1 using the algorithm described inAppendix E of [XML Schema Part 2: DatatypesSecond Edition], disregarding the rule about leap seconds. If$arg2 is negative, then the resultxs:dateTime precedes $arg1. The result has the same timezone as $arg1. If$arg1 has no timezone, the result has no timezone. Examples The expressionop:add-yearMonthDuration-to-dateTime(xs:dateTime("2000-10-30T11:12:00"),xs:yearMonthDuration("P1Y2M")) returnsxs:dateTime("2001-12-30T11:12:00"). 9.7.6op:add-dayTimeDuration-to-dateTime Summary Returns the xs:dateTime that is a given durationafter a specified xs:dateTime (or before, if theduration is negative). Operator Mapping Defines the semantics of the "+" operator when applied to anxs:dateTime and an xs:dayTimeDurationvalue. Signature op:add-dayTimeDuration-to-dateTime( $arg1 as xs:dateTime, $arg2 as xs:dayTimeDuration) as xs:dateTime Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns the result of adding $arg2 tothe value of $arg1 using the algorithm described inAppendix E of [XML Schema Part 2: DatatypesSecond Edition], disregarding the rule about leap seconds. If$arg2 is negative, then the resultxs:dateTime precedes $arg1. The result has the same timezone as $arg1. If$arg1 has no timezone, the result has no timezone. Examples The expressionop:add-dayTimeDuration-to-dateTime(xs:dateTime("2000-10-30T11:12:00"),xs:dayTimeDuration("P3DT1H15M")) returnsxs:dateTime("2000-11-02T12:27:00"). 9.7.7op:subtract-yearMonthDuration-from-dateTime Summary Returns the xs:dateTime that is a given durationbefore a specified xs:dateTime (or after, if theduration is negative). Operator Mapping Defines the semantics of the "-" operator when applied to anxs:dateTime and an xs:yearMonthDurationvalue. Signature op:subtract-yearMonthDuration-from-dateTime( $arg1 as xs:dateTime, $arg2 as xs:yearMonthDuration) as xs:dateTime Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns the xs:dateTime computed bynegating $arg2 and adding the result to the value of$arg1 using the function op:add-yearMonthDuration-to-dateTime. Examples The expressionop:subtract-yearMonthDuration-from-dateTime(xs:dateTime("2000-10-30T11:12:00"),xs:yearMonthDuration("P1Y2M")) returnsxs:dateTime("1999-08-30T11:12:00"). 9.7.8op:subtract-dayTimeDuration-from-dateTime Summary Returns the xs:dateTime that is a given durationbefore a specified xs:dateTime (or after, if theduration is negative). Operator Mapping Defines the semantics of the "-" operator when applied to anxs:dateTime an and xs:dayTimeDurationvalues Signature op:subtract-dayTimeDuration-from-dateTime( $arg1 as xs:dateTime, $arg2 as xs:dayTimeDuration) as xs:dateTime Rules The function returns the xs:dateTime computed bynegating $arg2 and adding the result to the value of$arg1 using the function op:add-dayTimeDuration-to-dateTime. Examples The expressionop:subtract-dayTimeDuration-from-dateTime(xs:dateTime("2000-10-30T11:12:00"),xs:dayTimeDuration("P3DT1H15M")) returnsxs:dateTime("2000-10-27T09:57:00"). 9.7.9op:add-yearMonthDuration-to-date Summary Returns the xs:date that is a given duration aftera specified xs:date (or before, if the duration isnegative). Operator Mapping Defines the semantics of the "+" operator when applied to anxs:date and an xs:yearMonthDurationvalue. Signature op:add-yearMonthDuration-to-date( $arg1 as xs:date, $arg2 as xs:yearMonthDuration) as xs:date Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns the result of casting $arg1 toan xs:dateTime, adding $arg2 using thefunction op:add-yearMonthDuration-to-dateTime,and casting the result back to an xs:date. Examples The expressionop:add-yearMonthDuration-to-date(xs:date("2000-10-30"),xs:yearMonthDuration("P1Y2M")) returnsxs:date("2001-12-30"). 9.7.10op:add-dayTimeDuration-to-date Summary Returns the xs:date that is a given duration aftera specified xs:date (or before, if the duration isnegative). Operator Mapping Defines the semantics of the "+" operator when applied to anxs:date and an xs:dayTimeDurationvalue. Signature op:add-dayTimeDuration-to-date( $arg1 as xs:date, $arg2 as xs:dayTimeDuration) as xs:date Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns the result of casting $arg1 toan xs:dateTime, adding $arg2 using thefunction op:add-dayTimeDuration-to-dateTime,and casting the result back to an xs:date. Examples The expressionop:add-dayTimeDuration-to-date(xs:date("2004-10-30Z"),xs:dayTimeDuration("P2DT2H30M0S")) returnsxs:date("2004-11-01Z"). ( The starting instant ofthe first argument is the xs:dateTime value{2004, 10, 30, 0, 0, 0, PT0S}. Adding the secondargument to this gives the xs:dateTime value{2004, 11, 1, 2, 30, 0, PT0S}. The time components arethen discarded. ). 9.7.11op:subtract-yearMonthDuration-from-date Summary Returns the xs:date that is a given duration beforea specified xs:date (or after, if the duration isnegative). Operator Mapping Defines the semantics of the "-" operator when applied to anxs:date and an xs:yearMonthDurationvalue. Signature op:subtract-yearMonthDuration-from-date( $arg1 as xs:date, $arg2 as xs:yearMonthDuration) as xs:date Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules Returns the xs:date computed by negating$arg2 and adding the result to $arg1using the function op:add-yearMonthDuration-to-date. Examples The expressionop:subtract-yearMonthDuration-from-date(xs:date("2000-10-30"),xs:yearMonthDuration("P1Y2M")) returnsxs:date("1999-08-30"). The expressionop:subtract-yearMonthDuration-from-date(xs:date("2000-02-29Z"),xs:yearMonthDuration("P1Y")) returnsxs:date("1999-02-28Z"). The expressionop:subtract-yearMonthDuration-from-date(xs:date("2000-10-31-05:00"),xs:yearMonthDuration("P1Y1M")) returnsxs:date("1999-09-30-05:00"). 9.7.12op:subtract-dayTimeDuration-from-date Summary Returns the xs:date that is a given duration beforea specified xs:date (or after, if the duration isnegative). Operator Mapping Defines the semantics of the "-" operator when applied to anxs:date and an xs:dayTimeDuration. Signature op:subtract-dayTimeDuration-from-date( $arg1 as xs:date, $arg2 as xs:dayTimeDuration) as xs:date Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules Returns the xs:date computed by negating$arg2 and adding the result to $arg1using the function op:add-dayTimeDuration-to-date. Examples The expressionop:subtract-dayTimeDuration-from-date(xs:date("2000-10-30"),xs:dayTimeDuration("P3DT1H15M")) returnsxs:date("2000-10-26"). 9.7.13op:add-dayTimeDuration-to-time Summary Returns the xs:time value that is a given durationafter a specified xs:time (or before, if the durationis negative or causes wrap-around past midnight) Operator Mapping Defines the semantics of the "+" operator when applied to anxs:time and an xs:dayTimeDurationvalue. Signature op:add-dayTimeDuration-to-time( $arg1 as xs:time, $arg2 as xs:dayTimeDuration) as xs:time Rules First, the days component in the canonical lexicalrepresentation of $arg2 is set to zero (0) and thevalue of the resulting xs:dayTimeDuration iscalculated. Alternatively, the value of $arg2 modulus86,400 is used as the second argument. This value is added to thevalue of $arg1 converted to anxs:dateTime using a reference date such as1972-12-31, and the time component of the result isreturned. Note that the xs:time returned may occur ina following or preceding day and may be less than$arg1. The result has the same timezone as $arg1. If$arg1 has no timezone, the result has no timezone. Examples The expressionop:add-dayTimeDuration-to-time(xs:time("11:12:00"),xs:dayTimeDuration("P3DT1H15M")) returnsxs:time("12:27:00"). The expressionop:add-dayTimeDuration-to-time(xs:time("23:12:00+03:00"),xs:dayTimeDuration("P1DT3H15M")) returnsxs:time("02:27:00+03:00"). (That is, {0, 0,0, 2, 27, 0, PT3H}). 9.7.14op:subtract-dayTimeDuration-from-time Summary Returns the xs:time value that is a given durationbefore a specified xs:time (or after, if the durationis negative or causes wrap-around past midnight) Operator Mapping Defines the semantics of the "-" operator when applied to anxs:time and an xs:dayTimeDurationvalue. Signature op:subtract-dayTimeDuration-from-time( $arg1 as xs:time, $arg2 as xs:dayTimeDuration) as xs:time Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns the result of negating $arg2and adding the result to $arg1 using the functionadd-dayTimeDuration-to-time. Examples The expressionop:subtract-dayTimeDuration-from-time(xs:time("11:12:00"),xs:dayTimeDuration("P3DT1H15M")) returnsxs:time("09:57:00"). The expressionop:subtract-dayTimeDuration-from-time(xs:time("08:20:00-05:00"),xs:dayTimeDuration("P23DT10H10M")) returnsxs:time("22:10:00-05:00"). 9.8 Formatting dates andtimes Function Meaning fn:format-dateTime Returns a string containing an xs:dateTime valueformatted for display. fn:format-date Returns a string containing an xs:date valueformatted for display. fn:format-time Returns a string containing an xs:time valueformatted for display. Three functions are provided to represent dates and times as astring, using the conventions of a selected calendar, language, andcountry. The signatures are presented first, followed by the ruleswhich apply to each of the functions. 9.8.1 fn:format-dateTime Summary Returns a string containing an xs:dateTime valueformatted for display. Signatures fn:format-dateTime($value as xs:dateTime?,$picture as xs:string) as xs:string? fn:format-dateTime( $value as xs:dateTime?, $picture as xs:string, $language as xs:string?, $calendar as xs:string?, $place as xs:string?) as xs:string? Properties The two-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on default calendar, and default language, and defaultplace, and implicit timezone. The five-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone, and namespaces. Rules See 9.8.4 Thedate/time formatting functions. 9.8.2fn:format-date Summary Returns a string containing an xs:date valueformatted for display. Signatures fn:format-date($value as xs:date?,$picture as xs:string) as xs:string? fn:format-date( $value as xs:date?, $picture as xs:string, $language as xs:string?, $calendar as xs:string?, $place as xs:string?) as xs:string? Properties The two-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on default calendar, and default language, and defaultplace, and implicit timezone. The five-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone, and namespaces. Rules See 9.8.4 Thedate/time formatting functions. 9.8.3fn:format-time Summary Returns a string containing an xs:time valueformatted for display. Signatures fn:format-time($value as xs:time?,$picture as xs:string) as xs:string? fn:format-time( $value as xs:time?, $picture as xs:string, $language as xs:string?, $calendar as xs:string?, $place as xs:string?) as xs:string? Properties The two-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on default calendar, and default language, and defaultplace, and implicit timezone. The five-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone, and namespaces. Rules See 9.8.4 Thedate/time formatting functions. 9.8.4 The date/time formattingfunctions The fn:format-dateTime,fn:format-date, andfn:format-timefunctions format $value as a string using the picturestring specified by the $picture argument, thecalendar specified by the $calendar argument, thelanguage specified by the $language argument, and thecountry or other place name specified by the$place argument. The result of the function is theformatted string representation of the suppliedxs:dateTime, xs:date, orxs:time value. [Definition] The three functionsfn:format-dateTime,fn:format-date, andfn:format-time arereferred to collectively as the date formattingfunctions. If $value is the empty sequence, the functionreturns the empty sequence. Calling the two-argument form of each of the three functions isequivalent to calling the five-argument form with each of the lastthree arguments set to an empty sequence. For details of the $language,$calendar, and $place arguments, see9.8.4.3 The language, calendar, andplace arguments. In general, the use of an invalid $picture,$language, $calendar, or$place argument results in a dynamic error([err:FOFD1340]). By contrast, use of anoption in any of these arguments that is valid but not supported bythe implementation is not an error, and in these cases theimplementation is required to output the value in a fallbackrepresentation. More detailed rules are givenbelow. 9.8.4.1 The picture string The picture consists of a sequence of variable markers andliteral substrings. A substring enclosed in square brackets isinterpreted as a variable marker; substrings not enclosed in squarebrackets are taken as literal substrings. The literal substringsare optional and if present are rendered unchanged, including anywhitespace. If an opening or closing square bracket is requiredwithin a literal substring, it must be doubled.The variable markers are replaced in the result by stringsrepresenting aspects of the date and/or time to be formatted. Theseare described in detail below. A variable marker consists of a component specifier followedoptionally by one or two presentation modifiers and/or optionallyby a width modifier. Whitespace within a variable marker isignored. The variable marker may be separated into its components byapplying the following rules: The component specifier is always present and is always a singleletter. The width modifier may be recognized by the presence of acomma. The substring between the component specifier and the comma (ifpresent) or the end of the string (if there is no comma) containsthe first and second presentation modifiers, both of which areoptional. If this substring contains a single character, this isinterpreted as the first presentation modifier. If it contains morethan one character, the last character is examined: if it is validas a second presentation modifier then it is treated as such, andthe preceding part of the substring constitutes the firstpresentation modifier. Otherwise, the second presentation modifieris presumed absent and the whole substring is interpreted as thefirst presentation modifier. The component specifier indicates the component of thedate or time that is required, and takes the following values: Specifier Meaning Default Presentation Modifier Y year (absolute value) 1 M month in year 1 D day in month 1 d day in year 1 F day of week n W week in year 1 w week in month 1 H hour in day (24 hours) 1 h hour in half-day (12 hours) 1 P am/pm marker n m minute in hour 01 s second in minute 01 f fractional seconds 1 Z timezone 01:01 z timezone (same as Z, but modified where appropriate to includea prefix as a time offset using GMT, for example GMT+1 orGMT-05:00. For this component there is a fixed prefix ofGMT, or a localized variation thereof for the chosenlanguage, and the remainder of the value is formatted as forspecifier Z. 01:01 C calendar: the name or abbreviation of a calendar name n E era: the name of a baseline for the numbering of years, forexample the reign of a monarch n A dynamic error is reported [err:FOFD1340] if the syntax of the pictureis incorrect. A dynamic error is reported [err:FOFD1350] if a component specifierwithin the picture refers to components that are not available inthe given type of $value, for example if the picturesupplied to the fn:format-time refers to theyear, month, or day component. It is not an error to include a timezone component when thesupplied value has no timezone. In these circumstances the timezonecomponent will be ignored. The first presentation modifier indicates the style inwhich the value of a component is to be represented. Its value maybe either: any format token permitted as a primary format token in thesecond argument of the fn:format-integer function,indicating that the value of the component is to be outputnumerically using the specified number format (for example,1, 01, i, I,w, W, or Ww) or the format token n, N, orNn, indicating that the value of the component is tobe output by name, in lower-case, upper-case, or title-caserespectively. Components that can be output by name include (butare not limited to) months, days of the week, timezones, and eras.If the processor cannot output these components by name for thechosen calendar and language then it must use an Â·implementation-definedÂ· fallback representation. If a comma is to be used as a grouping separator within theformat token, then there must be a width specifier. Morespecifically: if a variable marker contains one or more commas,then the last comma is treated as introducing the width modifier,and all others are treated as grouping separators. So[Y9,999,*] will output the year as2,008. If the implementation does not support the use of the requestedformat token, it must use the default presentationmodifier for that component. If the first presentation modifier is present, then it mayoptionally be followed by a second presentation modifier asfollows: Modifier Meaning either a or t indicates alphabetic or traditional numberingrespectively, the default being Â·implementation-definedÂ·. This has the same meaning as in the secondargument of fn:format-integer. either c or o indicates cardinal or ordinal numberingrespective, for example 7 or seven for acardinal number, or 7th, seventh, or7Âº for an ordinal number. This has the same meaning asin the second argument of fn:format-integer. Theactual representation of the ordinal form of a number may dependnot only on the language, but also on the grammatical context (forexample, in some languages it must agree in gender). Note: Although the formatting rules are expressed in terms of therules for format tokens in fn:format-integer, theformats actually used may be specialized to the numbering of datecomponents where appropriate. For example, in Italian, it isconventional to use an ordinal number (primo) for thefirst day of the month, and cardinal numbers (due, tre,quattro ...) for the remaining days. A processor maytherefore use this convention to number days of the month, ignoringthe presence or absence of the ordinal presentation modifier. Whether or not a presentation modifier is included, a widthmodifier may be supplied. This indicates the number of charactersor digits to be included in the representation of the value. The width modifier, if present, is introduced by a comma orsemicolon. It takes the form: "," min-width ("-"max-width)? where min-width is either an unsigned integerindicating the minimum number of characters to be output, or* indicating that there is no explicit minimum, andmax-width is either an unsigned integer indicating themaximum number of characters to be output, or *indicating that there is no explicit maximum; ifmax-width is omitted then * is assumed.Both integers, if present, must be greater thanzero. A format token containing more than one digit, such as001 or 9999, sets the minimum and maximumwidth to the number of digits appearing in the format token; if awidth modifier is also present, then the width modifier takesprecedence. A numeric format token may containoptional-digit-signs and grouping-separatorsas described for fn:format-integer. However,the grouping separator cannot be a closing square bracket("]"). Note: A format token consisting of a single digit, such as1, does not constrain the number of digits in theoutput. In the case of fractional seconds in particular,[f001] requests three decimal digits,[f01] requests two digits, but [f1] willproduce an Â·implementation-definedÂ· number of digits. If exactly one digit isrequired, this can be achieved using the component specifier[f1,1-1]. If the minimum and maximum width are unspecified, then theoutput uses as many characters as are required to represent thevalue of the component without truncation and without padding: thisis referred to below as the full representation of thevalue. For a timezone offset (component specifier z),the full representation consists of a sign for the offset, thenumber of hours of the offset, and if the offset is not an integralnumber of hours, a colon (:) followed by the twodigits of the minutes of the offset.. If the full representation of the value exceeds the specifiedmaximum width, then the processor should attemptto use an alternative shorter representation that fits within themaximum width. Where the presentation modifier is N,n, or Nn, this is done by abbreviatingthe name, using either conventional abbreviations if available, orcrude right-truncation if not. For example, settingmax-width to 4 indicates that four-letterabbreviations should be used, though it would beacceptable to use a three-letter abbreviation if this is inconventional use. (For example, "Tuesday" might be abbreviated to"Tues", and "Friday" to "Fri".) In the case of the year component,setting max-width requests omission of high-orderdigits from the year, for example, if max-width is setto 2 then the year 2003 will be output as03. In the case of the fractional seconds component,the value is rounded to the specified size as if by applying thefunction round-half-to-even(fractional-seconds,max-width). If no mechanism is available for fitting thevalue within the specified maximum width (for example, when romannumerals are used), then the value should beoutput in its full representation. If the full representation of the value is shorter than thespecified minimum width, then the processor shouldpad the value to the specified width. For decimal representations of numbers, thisshould be done by prepending zero digits from theappropriate set of digit characters, or appending zero digits inthe case of the fractional seconds component. For timezone offsets this should be done by first appending acolon (:) followed by two zero digits from theappropriate set of digit characters if the full representation doesnot already include a minutes component and if the specifiedminimum width permits adding three characters, and then ifnecessary prepending zero digits from the appropriate set of digitcharacters to the hour component. In other cases, it should be done by appendingspaces. 9.8.4.2 Formatting timezones Special rules apply to the formatting of timezones. When thecomponent specifiers Z or z are used, therules in this section override any rules given elsewhere in thecase of discrepancies. If the date/time value to be formatted does not include atimezone offset, then the timezone component specifier is generallyignored (results in no output). The exception is where militarytimezones are used (format ZZ) in which case the string "J" isoutput, indicating local time. When the component specifier is z, the output isthe same as for component specifier Z, except that itis prefixed by the characters GMT or some localizedequivalent. The prefix is omitted, however, in cases where thetimezone is identified by name rather than by a numeric offset fromUTC. If the first presentation modifier is numeric andcomprises one or two digits with no grouping-separator(for example 1 or 01), then the timezoneis formatted as a displacement from UTC in hours, preceded by aplus or minus sign: for example -5 or+03. If the actual timezone offset is not an integralnumber of hours, then the minutes part of the offset is appended,separated by a colon: for example +10:30 or-1:15. If the first presentation modifier is numeric with agrouping-separator (for example 1:01 or01.01), then the timezone offset is output in hoursand minutes, separated by the grouping separator, even if thenumber of minutes is zero: for example +5:00 or+10.30. If the first presentation modifier is numeric andcomprises three or four digits with nogrouping-separator, for example 001 or0001, then the timezone offset is shown in hours andminutes with no separator, for example -0500 or+1030. If the first presentation modifier is numeric, in anyof the above formats, and the second presentationmodifier is t, then a zero timezone offset (thatis, UTC) is output as Z instead of a signed numericvalue. In this presentation modifier is absent or if the timezoneoffset is non-zero, then the displayed timezone offset is precededby a "-" sign for negative offsets or a "+" sign for non-negativeoffsets. If the first presentation modifier is Z,then the timezone is formatted as a military timezone letter, usingthe convention Z = +00:00, A = +01:00, B = +02:00, ..., M = +12:00,N = -01:00, O = -02:00, ... Y = -12:00. The letter J (meaning localtime) is used in the case of a value that does not specify atimezone offset. Timezone offsets that have no representation inthis system (for example Indian Standard Time, +05:30) are outputas if the format 01:01 had been requested. If the first presentation modifier is N,then the timezone is output (where possible) as a timezone name,for example EST or CET. The same timezoneoffset has different names in different places; it is thereforerecommended that this option should be used onlyif a country code or Olson timezone name is supplied in the$place argument. In the absence of this information,the implementation may apply a default, for example by using thetimezone names that are conventional in North America. If notimezone name can be identified, the timezone offset is outputusing the fallback format +01:01. The following examples illustrate options for timezoneformatting. Variable marker $place Timezone offsets (with time = 12:00:00) -10:00 -05:00 +00:00 +05:30 +13:00 [Z] () -10:00 -05:00 +00:00 +05:30 +13:00 [Z0] () -10 -5 +0 +5:30 +13 [Z0:00] () -10:00 -5:00 +0:00 +5:30 +13:00 [Z00:00] () -10:00 -05:00 +00:00 +05:30 +13:00 [Z0000] () -1000 -0500 +0000 +0530 +1300 [Z00:00t] () -10:00 -05:00 Z +05:30 +13:00 [z] () GMT-10:00 GMT-05:00 GMT+00:00 GMT+05:30 GMT+13:00 [ZZ] () W R Z +05:30 +13:00 [ZN] "us" HST EST GMT IST +13:00 [H00]:[M00] [ZN] "America/New_York" 06:00 EST 12:00 EST 07:00 EST 01:30 EST 18:00 EST 9.8.4.3 Thelanguage, calendar, and place arguments The set of languages, calendars, and places thatare supported in the Â·date formatting functionsÂ· is Â·implementation-definedÂ·. When any of these arguments is omitted or isan empty sequence, an Â·implementation-definedÂ· default value is used. If the fallback representation uses a different calendar fromthat requested, the output string must identifythe calendar actually used, for example by prefixing the stringwith [Calendar: X] (where X is the calendar actuallyused), localized as appropriate to the requested language. If thefallback representation uses a different language from thatrequested, the output string must identify thelanguage actually used, for example by prefixing the string with[Language: Y] (where Y is the language actually used)localized in an implementation-dependent way. If a particularcomponent of the value cannot be output in the requested format, itshould be output in the default format for thatcomponent. The $language argument specifies the language to beused for the result string of the function. The value of theargument should be either the emptysequence or a value that would be valid for thexml:lang attribute (see [XML]). Note that this permitsthe identification of sublanguages based on country codes (from[ISO 3166-1]) as well as identification ofdialects and of regions within a country. If the $language argument is omitted or is set toan empty sequence, or if it is set to an invalid value or a valuethat the implementation does not recognize, then the processor usesthe default language defined in the dynamiccontext. The language is used to select the appropriatelanguage-dependent forms of: names (for example, of months) numbers expressed as words or as ordinals (twenty, 20th,twentieth) hour convention (0-23 vs 1-24, 0-11 vs 1-12) first day of week, first week of year Where appropriate this choice may also take into account thevalue of the $place argument, though thisshould not be used to override the language or anysublanguage that is specified as part of the languageargument. The choice of the names and abbreviations used in any givenlanguage is Â·implementation-definedÂ·. For example, one implementation mightabbreviate July as Jul while another usesJly. In German, one implementation might representSaturday as Samstag while another usesSonnabend. Implementations mayprovide mechanisms allowing users to control such choices. Where ordinal numbers are used, the selection of the correctrepresentation of the ordinal (for example, the linguistic gender)may depend on the component being formatted and onits textual context in the picture string. The calendar attribute specifies that thedateTime, date, or timesupplied in the $value argument mustbe converted to a value in the specified calendar and thenconverted to a string using the conventions of that calendar. The calendar value if present must be a validEQName (dynamic error: [err:FOFD1340]). Ifit is a lexical QName then it is expanded into anexpanded QName using the statically known namespaces;if it has no prefix then it represents an expanded-QName in nonamespace. If the expanded QName is in no namespace, then itmust identify a calendar with a designatorspecified below (dynamic error: [err:FOFD1340]). If the expandedQName is in a namespace then it identifies the calendar in anÂ·implementation-definedÂ· way. If the $calendar argument is omitted or is set toan empty sequence then the default calendar defined in the dynamiccontext is used. Note: The calendars listed below were known to be in use during thelast hundred years. Many other calendars have been used in thepast. This specification does not define any of these calendars, northe way that they map to the value space of thexs:date data type in [XMLSchema Part 2: Datatypes Second Edition]. There may beambiguities when dates are recorded using different calendars. Forexample, the start of a new day is not simultaneous in differentcalendars, and may also vary geographically (for example, based onthe time of sunrise or sunset). Translation of dates is thereforemore reliable when the time of day is also known, and when thegeographic location is known. When translating dates between onecalendar and another, the processor may take account of the valuesof the $place and/or $language arguments,with the $place argument taking precedence. Information about some of these calendars, and algorithms forconverting between them, may be found in [Calendrical Calculations]. Designator Calendar AD Anno Domini (Christian Era) AH Anno Hegirae (Muhammedan Era) AME Mauludi Era (solar years since Mohammed's birth) AM Anno Mundi (Jewish Calendar) AP Anno Persici AS Aji Saka Era (Java) BE Buddhist Era CB Cooch Behar Era CE Common Era CL Chinese Lunar Era CS Chula Sakarat Era EE Ethiopian Era FE Fasli Era ISO ISO 8601 calendar JE Japanese Calendar KE Khalsa Era (Sikh calendar) KY Kali Yuga ME Malabar Era MS Monarchic Solar Era NS Nepal Samwat Era OS Old Style (Julian Calendar) RS Rattanakosin (Bangkok) Era SE Saka Era SH Mohammedan Solar Era (Iran) SS Saka Samvat TE Tripurabda Era VE Vikrama Era VS Vikrama Samvat Era At least one of the above calendars must besupported. It is Â·implementation-definedÂ· which calendars are supported. The ISO 8601 calendar ([ISO 8601]), whichis included in the above list and designated ISO, isvery similar to the Gregorian calendar designated AD,but it differs in several ways. The ISO calendar is intended toensure that date and time formats can be read easily by othersoftware, as well as being legible for human users. The ISOcalendar prescribes the use of particular numbering conventions asdefined in ISO 8601, rather than allowing these to be localized ona per-language basis. In particular it provides a numeric 'weekdate' format which identifies dates by year, week of the year, andday in the week; in the ISO calendar the days of the week arenumbered from 1 (Monday) to 7 (Sunday), and week 1 in any calendaryear is the week (from Monday to Sunday) that includes the firstThursday of that year. The numeric values of the components year,month, day, hour, minute, and second are the same in the ISOcalendar as the values used in the lexical representation of thedate and time as defined in [XML Schema Part2: Datatypes Second Edition]. The era ("E" component) with thiscalendar is either a minus sign (for negative years) or azero-length string (for positive years). For dates before 1January, AD 1, year numbers in the ISO and AD calendars are off byone from each other: ISO year 0000 is 1 BC, -0001 is 2 BC, etc. ISO 8601 does not define a numbering for weeks within a month.When the w component is used, the convention to beadopted is that each Monday-to-Sunday week is considered to fallwithin a particular month if its Thursday occurs in that month; theweeks that fall in a particular month under this definition arenumbered starting from 1. Thus, for example, 29 January 2013 fallsin week 5 because the Thursday of the week (31 January 2013) is thefifth Thursday in January, and 1 February 2013 is also in week 5for the same reason. Note: The value space of the date and time data types, as defined inXML Schema, is based on absolute points in time. The lexical spaceof these data types defines a representation of these absolutepoints in time using the proleptic Gregorian calendar, that is, themodern Western calendar extrapolated into the past and the future;but the value space is calendar-neutral. The Â·dateformatting functionsÂ· produce arepresentation of this absolute point in time, but denoted in apossibly different calendar. So, for example, the date whoselexical representation in XML Schema is 1502-01-11(the day on which Pope Gregory XIII was born) might be formattedusing the Old Style (Julian) calendar as 1 January1502. This reflects the fact that there was at that time aten-day difference between the two calendars. It would beincorrect, and would produce incorrect results, to represent thisdate in an element or attribute of type xs:date as1502-01-01, even though this might reflect the way thedate was recorded in contemporary documents. When referring to years occurring in antiquity, modernhistorians generally use a numbering system in which there is noyear zero (the year before 1 CE is thus 1 BCE). This is theconvention that should be used when the requestedcalendar is OS (Julian) or AD (Gregorian). When the requestedcalendar is ISO, however, the conventions of ISO 8601should be followed: here the year before +0001 isnumbered zero. In [XML Schema Part 2:Datatypes Second Edition] (version 1.0), the value space forxs:date and xs:dateTime does not includea year zero: however, XSD 1.1 endorses the ISO 8601convention. This means that the date on which Julius Caesar wasassassinated has the ISO 8601 lexical representation -0043-03-13,but will be formatted as 15 March 44 BCE in the Julian calendar or13 March 44 BCE in the Gregorian calendar (dependant on the chosenlocalization of the names of months and eras). The intended use of the $place argument is toidentify the place where an event represented by thedateTime, date, or timesupplied in the $value argument took place or willtake place. If the $place argument is omitted oris set to an empty sequence, then the default place defined in thedynamic context is used. If the value is supplied, and isnot the empty sequence, then it shouldeither be a country code or an Olson timezone name.If the value does not take this form, or if its value is notrecognized by the implementation, then the default place defined inthe dynamic context is used. Country codes are defined in [ISO3166-1]. Examples are "de" for Germany and "jp" for Japan.Implementations may also allow the use of codesrepresenting subdivisions of a country from ISO 3166-2, or codesrepresenting formerly used names of countries from ISO 3166-3 Olson timezone names are defined in the public-domain tztimezone database [Olson Timezone Database].Examples are "America/New_York" and "Europe/Rome". This argument is not intended to identify the location of theuser for whom the date or time is being formatted; that should bedone by means of the $language attribute. Thisinformation may be used to provide additionalinformation when converting dates between calendars or whendeciding how individual components of the date and time are to beformatted. For example, different countries using the Old Style(Julian) calendar started the new year on different days, and somecountries used variants of the calendar that were out ofsynchronization as a result of differences in calculating leapyears. The geographical area identified by a country code is defined bythe boundaries as they existed at the time of the date to beformatted, or the present-day boundaries for dates in thefuture. If the $place argument is supplied in the form ofan Olson timezone name that is recognized by the implementation,then the date or time being formatted is adjusted to the timezoneoffset applicable in that timezone. For example, if thexs:dateTime value 2010-02-15T12:00:00Z isformatted with the $place argument set toAmerica/New_York, then the output will be as if thevalue 2010-02-15T07:00:00-05:00 had been supplied.This adjustment takes daylight savings time into account wherepossible; if the date in question falls during daylight savingstime in New York, then it is adjusted to timezone offset-PT4H rather than -PT5H. Adjustment usingdaylight savings time is only possible where the value includes adate, and where the date is within the range covered by thetimezone database. 9.8.5Examples of date and time formatting Example: Gregorian calendar The following examples show a selection of dates and times andthe way they might be formatted. These examples assume the use ofthe Gregorian calendar as the default calendar. Required Output Expression 2002-12-31 format-date($d, "[Y0001]-[M01]-[D01]") 12-31-2002 format-date($d, "[M]-[D]-[Y]") 31-12-2002 format-date($d, "[D]-[M]-[Y]") 31 XII 2002 format-date($d, "[D1] [MI] [Y]") 31st December, 2002 format-date($d, "[D1o] [MNn], [Y]", "en", (),()) 31 DEC 2002 format-date($d, "[D01] [MN,*-3] [Y0001]", "en", (),()) December 31, 2002 format-date($d, "[MNn] [D], [Y]", "en", (),()) 31 Dezember, 2002 format-date($d, "[D] [MNn], [Y]", "de", (),()) Tisdag 31 December 2002 format-date($d, "[FNn] [D] [MNn] [Y]", "sv", (),()) [2002-12-31] format-date($d, "[[[Y0001]-[M01]-[D01]]]") Two Thousand and Three format-date($d, "[YWw]", "en", (), ()) einunddreiÃŸigste Dezember format-date($d, "[Dwo] [MNn]", "de", (), ()) 3:58 PM format-time($t, "[h]:[m01] [PN]", "en", (),()) 3:58:45 pm format-time($t, "[h]:[m01]:[s01] [Pn]", "en", (),()) 3:58:45 PM PDT format-time($t, "[h]:[m01]:[s01] [PN] [ZN,*-3]", "en",(), ()) 3:58:45 o'clock PM PDT format-time($t, "[h]:[m01]:[s01] o'clock [PN] [ZN,*-3]","en", (), ()) 15:58 format-time($t,"[H01]:[m01]") 15:58:45.762 format-time($t,"[H01]:[m01]:[s01].[f001]") 15:58:45 GMT+02:00 format-time($t,"[H01]:[m01]:[s01] [z,6-6]", "en", (),()) 15.58 Uhr GMT+2 format-time($t,"[H01]:[m01] Uhr [z]", "de", (),()) 3.58pm on Tuesday, 31st December format-dateTime($dt, "[h].[m01][Pn] on [FNn], [D1o][MNn]") 12/31/2002 at 15:58:45 format-dateTime($dt, "[M01]/[D01]/[Y0001] at[H01]:[m01]:[s01]") Example: Non-Gregorian calendars The following examples use calendars other than the Gregoriancalendar. These examples use non-Latin characters which might not displaycorrectly in all browsers, depending on the systemconfiguration. Description Request Result Islamic format-date($d, "[D&#x0661;] [Mn][Y&#x0661;]", "ar", "AH", ()) Ù¢Ù¦ ïº¸ï»Ù‘ïº?ï»? Ù¡Ù¤Ù¢Ù£ Jewish (with Western numbering) format-date($d, "[D] [Mn] [Y]", "he", "AM",()) â€?26 ×˜×‘×ª 5763 Jewish (with traditional numbering) format-date($d, "[D&#x05D0;t] [Mn][Y&#x05D0;t]", "he", "AM", ()) ×›×´×• ×˜×‘×ª ×ª×©×¡×´×’ Julian (Old Style) format-date($d, "[D] [MNn] [Y]", "en", "OS",()) 18 December 2002 Thai format-date($d, "[D&#x0E51;] [Mn][Y&#x0E51;]", "th", "BE", ()) à¹“à¹‘ à¸˜à¸±à¸™à¸§à¸²à¸„à¸¡ à¹’à¹•à¹”à¹• 10 Functions relatedto QNames 10.1Functions to create a QName In addition to the xs:QName constructor function,QName values can be constructed by combining a namespace URI,prefix, and local name, or by resolving a lexical QName against thein-scope namespaces of an element node. This section defines thesefunctions. Leading and trailing whitespace, if present, is strippedfrom string arguments before the result is constructed. Function Meaning fn:resolve-QName Returns an xs:QName value (that is, anexpanded-QName) by taking an xs:string that has thelexical form of an xs:QName (a string in the form"prefix:local-name" or "local-name") and resolving it using thein-scope namespaces for a given element. fn:QName Constructs an xs:QName value given a namespace URIand a lexical QName. 10.1.1fn:resolve-QName Summary Returns an xs:QName value (that is, anexpanded-QName) by taking an xs:string that has thelexical form of an xs:QName (a string in the form"prefix:local-name" or "local-name") and resolving it using thein-scope namespaces for a given element. Signature fn:resolve-QName($qname as xs:string?,$element as element()) as xs:QName? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $qname is the empty sequence, returns the emptysequence. More specifically, the function searches the namespace bindingsof $element for a binding whose name matches theprefix of $qname, or the zero-length string if it hasno prefix, and constructs an expanded-QName whose local name istaken from the supplied $qname, and whose namespaceURI is taken from the string value of the namespace binding. If the $qname has no prefix, and there is nonamespace binding for $element corresponding to thedefault (unnamed) namespace, then the resulting expanded-QName hasno namespace part. The prefix (or absence of a prefix) in the supplied$qname argument is retained in the returnedexpanded-QName, as discussed in Section 2.1Terminology DM30. Error Conditions A dynamic error is raised [err:FOCA0002] if $qname doesnot have the correct lexical form for an instance ofxs:QName. A dynamic error is raised [err:FONS0004] if $qname has aprefix and there is no namespace binding for $elementthat matches this prefix. Notes Sometimes the requirement is to construct anxs:QName without using the default namespace. This canbe achieved by writing:  if (contains($qname, ":")) then fn:resolve-QName($qname, $element) else            fn:QName("", $qname) If the requirement is to construct an xs:QNameusing the namespaces in the static context, then thexs:QName constructor should be used. Examples Assume that the element bound to $element has asingle namespace binding bound to the prefix eg. fn:resolve-QName("hello", $element) returns a QNamewith local name "hello" that is in no namespace. fn:resolve-QName("eg:myFunc", $element) returns anxs:QName whose namespace URI is specified by thenamespace binding corresponding to the prefix "eg" and whose localname is "myFunc". 10.1.2 fn:QName Summary Constructs an xs:QName value given a namespace URIand a lexical QName. Signature fn:QName($paramURI as xs:string?,$paramQName as xs:string) as xs:QName Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The namespace URI in the returned QName is taken from$paramURI. If $paramURI is thezero-length string or the empty sequence, it represents "nonamespace". The prefix (or absence of a prefix) in $paramQNameis retained in the returned xs:QName value. The local name in the result is taken from the local part of$paramQName. Error Conditions A dynamic error is raised [err:FOCA0002] if $paramQNamedoes not have the correct lexical form for an instance ofxs:QName. A dynamic error is raised [err:FOCA0002] if $paramURI isthe zero-length string or the empty sequence, and the value of$paramQName contains a colon (:). A dynamic error may be raised[err:FOCA0002] if$paramURI is not a valid URI (XML Namespaces 1.0) orIRI (XML Namespaces 1.1). Notes Examples fn:QName("http://www.example.com/example","person") returns an xs:QName with namespaceURI = "http://www.example.com/example", local name = "person" andprefix = "". fn:QName("http://www.example.com/example","ht:person") returns an xs:QName with namespaceURI = "http://www.example.com/example", local name = "person" andprefix = "ht". 10.2Functions and operators related to QNames This section specifies functions on QNames as defined in[XML Schema Part 2: Datatypes SecondEdition]. Function Meaning op:QName-equal Returns true if two supplied QNames have the samenamespace URI and the same local part. fn:prefix-from-QName Returns the prefix component of the supplied QName. fn:local-name-from-QName Returns the local part of the supplied QName. fn:namespace-uri-from-QName Returns the namespace URI part of the supplied QName. fn:namespace-uri-for-prefix Returns the namespace URI of one of the in-scope namespaces for$element, identified by its namespace prefix. fn:in-scope-prefixes Returns the prefixes of the in-scope namespaces for an elementnode. 10.2.1op:QName-equal Summary Returns true if two supplied QNames have the samenamespace URI and the same local part. Operator Mapping Defines the semantics of the "eq" and "ne" operators whenapplied to two values of type xs:QName. Signature op:QName-equal($arg1 as xs:QName,$arg2 as xs:QName) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns true if the namespace URIs of$arg1 and $arg2 are equal and the localnames of $arg1 and $arg2 are equal. Otherwise, the function returns false. The namespace URI parts are considered equal if they are bothabsentDM30,or if they are both present and equal under the rules of thefn:codepoint-equalfunction. The local parts are also compared under the rules of thefn:codepoint-equalfunction. Notes The prefix parts of $arg1 and $arg2,if any, are ignored. 10.2.2 fn:prefix-from-QName Summary Returns the prefix component of the supplied QName. Signature fn:prefix-from-QName($arg as xs:QName?) as xs:NCName? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence the function returnsthe empty sequence. If $arg has no prefix component the functionreturns the empty sequence. Otherwise, the function returns an xs:NCNamerepresenting the prefix component of $arg. 10.2.3fn:local-name-from-QName Summary Returns the local part of the supplied QName. Signature fn:local-name-from-QName($arg as xs:QName?) as xs:NCName? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence the function returnsthe empty sequence. Otherwise, the function returns an xs:NCNamerepresenting the local part of $arg. Examples The expressionfn:local-name-from-QName(fn:QName("http://www.example.com/example","person")) returns "person". 10.2.4fn:namespace-uri-from-QName Summary Returns the namespace URI part of the supplied QName. Signature fn:namespace-uri-from-QName($arg as xs:QName?) as xs:anyURI? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence the function returnsthe empty sequence. Otherwise, the function returns an xs:anyURIrepresenting the namespace URI part of $arg. If $arg is in no namespace, the function returnsthe zero-length xs:anyURI. Examples The expressionfn:namespace-uri-from-QName(fn:QName("http://www.example.com/example","person")) returnsxs:anyURI("http://www.example.com/example"). 10.2.5fn:namespace-uri-for-prefix Summary Returns the namespace URI of one of the in-scope namespaces for$element, identified by its namespace prefix. Signature fn:namespace-uri-for-prefix( $prefix as xs:string?, $element as element()) as xs:anyURI? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $element has an in-scope namespace whosenamespace prefix is equal to $prefix, the functionreturns the namespace URI of that namespace. If $element has no in-scope namespace whosenamespace prefix is equal to $prefix, the functionreturns the empty sequence. If $prefix is the zero-length string or the emptysequence, then if $element has a default namespace(that is, a namespace node with no name), the function returns thenamespace URI of the default namespace. If $elementhas no default namespace, the function returns the emptysequence. Prefixes are equal only if their Unicode codepoints matchexactly. Examples let $e := <z:a xmlns="http://example.org/one" xmlns:z="http://example.org/two">  <b xmlns=""/></z:a> The expression fn:namespace-uri-for-prefix("z", $e)returns "http://example.org/two". The expression fn:namespace-uri-for-prefix("", $e)returns "http://example.org/one". The expression fn:namespace-uri-for-prefix((), $e)returns "http://example.org/one". The expression fn:namespace-uri-for-prefix("xml",$e) returns"http://www.w3.org/XML/1998/namespace". The expression fn:namespace-uri-for-prefix("xml",$e) returns"http://www.w3.org/XML/1998/namespace". 10.2.6 fn:in-scope-prefixes Summary Returns the prefixes of the in-scope namespaces for an elementnode. Signature fn:in-scope-prefixes($element as element()) as xs:string* Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns a sequence of strings representing theprefixes of the in-scope namespaces for $element. For namespace bindings that have a prefix, the function returnsthe prefix as an xs:NCName. For the default namespace,which has no prefix, it returns the zero-length string. The result sequence contains no duplicates. The ordering of the result sequence is Â·implementation-dependentÂ·. 11Operators on base64Binary and hexBinary 11.1 Comparisons of base64Binary andhexBinary values The following comparison operators onxs:base64Binary and xs:hexBinary valuesare defined. Comparisons take two operands of the same type; thatis, both operands must be xs:base64Binary or bothoperands may be xs:hexBinary. Each returns a booleanvalue. A value of type xs:hexBinary can be compared with avalue of type xs:base64Binary by casting one value tothe other type. See 18.1.6 Castingto xs:base64Binary and xs:hexBinary. Function Meaning op:hexBinary-equal Returns true if two xs:hexBinary values containthe same octet sequence. op:base64Binary-equal Returns true if two xs:base64Binary values containthe same octet sequence. 11.1.1 op:hexBinary-equal Summary Returns true if two xs:hexBinary values contain thesame octet sequence. Operator Mapping Defines the semantics of the "eq" and "ne" operators whenapplied to two xs:hexBinary values. Signature op:hexBinary-equal( $value1 as xs:hexBinary, $value2 as xs:hexBinary) as xs:boolean Rules The function returns true if $value1and $value2 are of the same length, measured in binaryoctets, and contain the same octets in the same order. Otherwise,it returns false. 11.1.2 op:base64Binary-equal Summary Returns true if two xs:base64Binary values containthe same octet sequence. Operator Mapping Defines the semantics of the "eq" and "ne" operators whenapplied to two xs:base64Binary values. Signature op:base64Binary-equal( $value1 as xs:base64Binary, $value2 as xs:base64Binary) as xs:boolean Rules The function returns true if $value1and $value2 are of the same length, measured in binaryoctets, and contain the same octets in the same order. Otherwise,it returns false. 12Operators on NOTATION This section specifies operators that takexs:NOTATION values as arguments. Function Meaning op:NOTATION-equal Returns true if the two xs:NOTATIONvalues have the same namespace URI and the same local part. 12.1op:NOTATION-equal Summary Returns true if the two xs:NOTATIONvalues have the same namespace URI and the same local part. Operator Mapping Defines the semantics of the "eq" and "ne" operators whenapplied to two values of type xs:NOTATION. Signature op:NOTATION-equal($arg1 as xs:NOTATION,$arg2 as xs:NOTATION) as xs:boolean Rules The function returns true if the namespace URIs of$arg1 and $arg2 are equal and the localnames of $arg1 and $arg2 are equal. Otherwise, the function returns false. The namespace URI parts are considered equal if they are bothabsentDM30,or if they are both present and equal under the rules of thefn:codepoint-equalfunction. The local parts are also compared under the rules of thefn:codepoint-equalfunction. Notes The prefix parts of $arg1 and $arg2,if any, are ignored. 13 Functionsand operators on nodes This section specifies functions and operators on nodes. Nodesare formally defined in Section 6 NodesDM30. Function Meaning fn:name Returns the name of a node, as an xs:string thatis either the zero-length string, or has the lexical form of anxs:QName. fn:local-name Returns the local part of the name of $arg as anxs:string that is either the zero-length string, orhas the lexical form of an xs:NCName. fn:namespace-uri Returns the namespace URI part of the name of$arg, as an xs:anyURI value. fn:lang This function tests whether the language of $node,or the context item if the second argument is omitted, as specifiedby xml:lang attributes is the same as, or is asublanguage of, the language specified by$testlang. op:is-same-node Returns true if the two arguments refer to the same node. op:node-before Returns true if the node identified by the first argumentprecedes the node identified by the second argument in documentorder. op:node-after Returns true if the node identified by the first argumentfollows the node identified by the second argument in documentorder. fn:root Returns the root of the tree to which $argbelongs. This will usually, but not necessarily, be a documentnode. fn:path Returns a path expression that can be used to select thesupplied node relative to the root of its containing document. fn:has-children Returns true if the supplied node has one or more child nodes(of any kind). fn:innermost Returns every node within the input sequence that is not anancestor of another member of the input sequence; the nodes arereturned in document order with duplicates eliminated. fn:outermost Returns every node within the input sequence that has noancestor that is itself a member of the input sequence; the nodesare returned in document order with duplicates eliminated. For the illustrative examples below assume an XQuery ortransformation operating on a PurchaseOrder document containing anumber of line-item elements. Each line-item has child elementscalled description, price, quantity, etc. whose content isdifferent for each line-item. Quantity has simple content of typexs:decimal. Further assume that variables$item1, $item2, etc. are each bound tosingle line-item element nodes in the document in sequence and thatthe value of the quantity child of the first line-item is5.0. let $po := <PurchaseOrder>  <line-item>    <description>Large widget</description>    <price>8.95</price>    <quantity>5.0</quantity>  </line-item>  <line-item>    <description>Small widget</description>    <price>3.99</price>    <quantity>2.0</quantity>  </line-item>  <line-item>    <description>Tiny widget</description>    <price>1.49</price>    <quantity>805</quantity>  </line-item></PurchaseOrder> let $item1 :=$po/line-item[1] let $item2 :=$po/line-item[2] let $item3 :=$po/line-item[3] 13.1 fn:name Summary Returns the name of a node, as an xs:string that iseither the zero-length string, or has the lexical form of anxs:QName. Signatures fn:name() as xs:string fn:name($arg as node()?) as xs:string Properties The zero-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The one-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the argument is omitted, it defaults to the context item(.). The behavior of the function if the argument isomitted is exactly the same as if the context item had been passedas the argument. If the argument is supplied and is the empty sequence, thefunction returns the zero-length string. If the node identified by $arg has no name (thatis, if it is a document node, a comment, a text node, or anamespace node having no name), the function returns thezero-length string. Otherwise, the function returns the value of the expressionfn:string(fn:node-name($arg)). Error Conditions The following errors may be raised when $arg isomitted: If the context item is absentDM30,dynamic error [err:XPDY0002]XP30 If the context item is not a node, type error[err:XPTY0004]XP30. 13.2fn:local-name Summary Returns the local part of the name of $arg as anxs:string that is either the zero-length string, orhas the lexical form of an xs:NCName. Signatures fn:local-name() as xs:string fn:local-name($arg as node()?) as xs:string Properties The zero-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The one-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the argument is omitted, it defaults to the context item(.). The behavior of the function if the argument isomitted is exactly the same as if the context item had been passedas the argument. If the argument is supplied and is the empty sequence, thefunction returns the zero-length string. If the node identified by $arg has no name (thatis, if it is a document node, a comment, a text node, or anamespace node having no name), the function returns thezero-length string. Otherwise, the function returns the local part of theexpanded-QName of the node identified by $arg, asdetermined by the dm:node-name accessor defined inSection5.11 node-name Accessor DM30). Thiswill be an xs:string whose lexical form is anxs:NCName. Error Conditions The following errors may be raised when $arg isomitted: If the context item is absentDM30,dynamic error [err:XPDY0002]XP30 If the context item is not a node, type error[err:XPTY0004]XP30. 13.3fn:namespace-uri Summary Returns the namespace URI part of the name of $arg,as an xs:anyURI value. Signatures fn:namespace-uri() as xs:anyURI fn:namespace-uri($arg as node()?) as xs:anyURI Properties The zero-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The one-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the argument is omitted, it defaults to the context node(.). The behavior of the function if the argument isomitted is exactly the same as if the context item had been passedas the argument. If the node identified by $arg is neither anelement nor an attribute node, or if it is an element or attributenode whose expanded-QName (as determined by thedm:node-name accessor in the Section5.11 node-name Accessor DM30) is inno namespace, then the function returns the zero-lengthxs:anyURI value. Otherwise, the result will be the namespace URI part of theexpanded-QName of the node identified by $arg, asdetermined by the dm:node-name accessor defined inSection5.11 node-name Accessor DM30),returned as an xs:anyURI value. Error Conditions The following errors may be raised when $arg isomitted: If the context item is absentDM30,dynamic error [err:XPDY0002]XP30 If the context item is not a node, type error[err:XPTY0004]XP30. 13.4 fn:lang Summary This function tests whether the language of $node,or the context item if the second argument is omitted, as specifiedby xml:lang attributes is the same as, or is asublanguage of, the language specified by$testlang. Signatures fn:lang($testlang as xs:string?) as xs:boolean fn:lang($testlang as xs:string?,$node as node()) as xs:boolean Properties The one-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The two-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The behavior of the function if the second argument is omittedis exactly the same as if the context item (.) hadbeen passed as the second argument. The language of the argument $node, or the contextitem if the second argument is omitted, is determined by the valueof the xml:lang attribute on the node, or, if the nodehas no such attribute, by the value of the xml:langattribute on the nearest ancestor of the node that has anxml:lang attribute. If there is no such ancestor, thenthe function returns false. If $testlang is the empty sequence it isinterpreted as the zero-length string. The relevant xml:lang attribute is determined bythe value of the XPath expression: (ancestor-or-self::*/@xml:lang)[last()] If this expression returns an empty sequence, the functionreturns false. Otherwise, the function returns true if and onlyif, based on a caseless default match as specified in section 3.13of [The Unicode Standard], either: $testlang is equal to the string-value of therelevant xml:lang attribute, or $testlang is equal to some substring of thestring-value of the relevant xml:lang attribute thatstarts at the start of the string-value and ends immediately beforea hyphen, "-" (the character "-" is HYPHEN-MINUS, #x002D). Error Conditions The following errors may be raised when $arg isomitted: If the context item is absentDM30,dynamic error [err:XPDY0002]XP30 If the context item is not a node, type error[err:XPTY0004]XP30. Examples The expression fn:lang("en") would returntrue if the context node were any of the followingfour elements: <para xml:lang="en"/> <div xml:lang="en"><para>And now, andforever!</para></div> <para xml:lang="EN"/> <para xml:lang="en-us"/> The expression fn:lang("fr") would returnfalse if the context node were <paraxml:lang="EN"/> 13.5op:is-same-node Summary Returns true if the two arguments refer to the same node. Operator Mapping Defines the semantics of the "is" operator when applied to twonodes. Signature op:is-same-node($arg1 as node(),$arg2 as node()) as xs:boolean Rules If the node identified by the value of $arg1 is thesame node as the node identified by the value of $arg2(that is, the two nodes have the same identity), then the functionreturns true; otherwise, the function returnsfalse. Examples The expression op:is-same-node($item1, $item1)returns true(). The expression op:is-same-node($item1, $item2)returns false(). 13.6op:node-before Summary Returns true if the node identified by the first argumentprecedes the node identified by the second argument in documentorder. Operator Mapping Defines the semantics of the "<<" operator when applied totwo nodes. Signature op:node-before($arg1 as node(),$arg2 as node()) as xs:boolean Rules If the node identified by the value of $arg1 occursin document order before the node identified by the value of$arg2, then the function returns true;otherwise, it returns false. The rules determining the order of nodes within a singledocument and in different documents can be found in Section2.4 Document Order DM30. Examples The expression op:node-before($item1, $item2)returns true(). The expression op:node-before($item1, $item1)returns false(). 13.7op:node-after Summary Returns true if the node identified by the first argumentfollows the node identified by the second argument in documentorder. Operator Mapping Defines the semantics of the ">>" operator when applied totwo nodes. Signature op:node-after($arg1 as node(),$arg2 as node()) as xs:boolean Rules If the node identified by the value of $arg1 occursin document order after the node identified by the value of$arg2, the function returns true;otherwise, it returns false. The rules determining the order of nodes within a singledocument and in different documents can be found in Section2.4 Document Order DM30. Examples The expression op:node-after($item1, $item2)returns false(). The expression op:node-after($item1, $item1)returns false(). The expression op:node-after($item2, $item1)returns true(). 13.8 fn:root Summary Returns the root of the tree to which $arg belongs.This will usually, but not necessarily, be a document node. Signatures fn:root() as node() fn:root($arg as node()?) as node()? Properties The zero-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The one-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the function is called without an argument, the context item(.) is used as the default argument. The behavior ofthe function if the argument is omitted is exactly the same as ifthe context item had been passed as the argument. The function returns the value of the expression($arg/ancestor-or-self::node())[1]. Error Conditions The following errors may be raised when $arg isomitted: If the context item is absentDM30,dynamic error [err:XPDY0002]XP30 If the context item is not a node, type error[err:XPTY0004]XP30. Examples These examples use some variables which could be defined in[XQuery 1.0: An XML Query Language] as: let $i := <tool>wrench</tool>let $o := <order> {$i} <quantity>5</quantity> </order>let $odoc := document {$o}let $newi := $o/tool Or they could be defined in [XSLTransformations (XSLT) Version 2.0] as: <xsl:variable name="i" as="element()">  <tool>wrench</tool></xsl:variable><xsl:variable name="o" as="element()">  <order>    <xsl:copy-of select="$i"/>    <quantity>5</quantity>  </order></xsl:variable><xsl:variable name="odoc">  <xsl:copy-of select="$o"/></xsl:variable><xsl:variable name="newi" select="$o/tool"/> fn:root($i) returns the element node$i fn:root($o/quantity) returns the element node$o fn:root($odoc//quantity) returns the document node$odoc fn:root($newi) returns the element node$o The final three examples could be made type-safe by wrappingtheir operands with fn:exactly-one(). 13.9 fn:path Summary Returns a path expression that can be used to select thesupplied node relative to the root of its containing document. Signatures fn:path() as xs:string? fn:path($arg as node()?) as xs:string? Properties The one-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The two-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The behavior of the function if the argument is omitted isexactly the same as if the context item (.) had beenpassed as the argument. If $arg is the empty sequence, the function returnsthe empty sequence. If $arg is a document node, the function returnsthe string "/". Otherwise, the function constructs a string that consists of asequence of steps, one for each ancestor-or-self of$arg other than the root node. Thisstring is prefixed by"Q{http://www.w3.org/2005/xpath-functions}root()" ifthe root node is not a document node. Each step consists ofthe character "/" followed by a string whose formdepends on the kind of node selected by that step, as follows: For an element node,Q{uri}local[position],where uri is the namespace URI of the nodename or the empty string if the node is in no namespace,local is the local part of the node name, andposition is an integer representing theposition of the selected node among its like-named siblings. For an attribute node: if the node is in no namespace, @local,where local is the local part of the nodename otherwise, @Q{uri}local, whereuri is the namespace URI of the node name,and local is the local part of the nodename For a text node: text()[position] whereposition is an integer representing theposition of the selected node among its text node siblings For a comment node: comment()[position]where position is an integer representing theposition of the selected node among its comment node siblings For a processing-instruction node:processing-instruction(local)[position]where local is the name of the processinginstruction node and position is an integerrepresenting the position of the selected node among its like-namedprocessing-instruction node siblings For a namespace node: If the namespace node has a name:namespace::prefix, whereprefix is the local part of the name of thenamespace node (which represents the namespace prefix). If the namespace node has no name (that is, it represents thedefault namespace):namespace::*[Q{http://www.w3.org/2005/xpath-functions}local-name()=""] Examples let $e := fn:parse-xml('<?xml version="1.0"?><p xmlns="http://example.com/one" xml:lang="de" author="Friedrich von Schiller">Freude, schÃ¶ner GÃ¶tterfunken,<br/>Tochter aus Elysium,<br/>Wir betreten feuertrunken,<br/>Himmlische, dein Heiligtum.</p>')         The expression fn:path($e) returns'/'. The expression fn:path($e/*:p) returns'/Q{http://example.com/one}p[1]'. The expression fn:path($e/*:p/@xml:lang) returns'/Q{http://example.com/one}p[1]/@Q{http://www.w3.org/XML/1998/namespace}lang'. The expression fn:path($e/*:p/@author) returns'/Q{http://example.com/one}p[1]/@author'. The expression fn:path($e/*:p/*:br[2]) returns'/Q{http://example.com/one}p[1]/Q{http://example.com/one}br[2]'. The expressionfn:path($e//text()[starts-with(normalize-space(),'Tochter')]) returns'/Q{http://example.com/one}p[1]/text()[2]'. let $emp :=             <employee xml:id="ID21256">               <empnr>E21256</empnr>               <first>John</first>               <last>Brown</last>            </employee>         The expression fn:path($emp) returns'Q{http://www.w3.org/2005/xpath-functions}root()'. The expression fn:path($emp/@xml:id) returns'Q{http://www.w3.org/2005/xpath-functions}root()/@Q{http://www.w3.org/XML/1998/namespace}id'. The expression fn:path($emp/empnr) returns'Q{http://www.w3.org/2005/xpath-functions}root()/Q{}empnr[1]'. 13.10fn:has-children Summary Returns true if the supplied node has one or more child nodes(of any kind). Signatures fn:has-children() as xs:boolean fn:has-children($node as node()?) as xs:boolean Properties The zero-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The one-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the argument is omitted, it defaults to the context item(.). The behavior of the function if the argument isomitted is exactly the same as if the context item had been passedas the argument. Provided that the supplied argument $nodematches the expected type node()?, the resultof the function call fn:has-children($node) is definedto be the same as the result of the expression fn:exists($node/child::node()). Error Conditions The following errors may be raised when $node isomitted: If the context item is absentDM30,dynamic error [err:XPDY0002]XP30 If the context item is not a node, type error[err:XPTY0004]XP30. Notes If $node is an empty sequence the result isfalse. The motivation for this function is to support streamedevaluation. According to the streaming rules in [XSL Transformations (XSLT) Version 3.0], thefollowing construct is not streamable: <xsl:if test="exists(row)">  <ul>    <xsl:for-each select="row">       <li><xsl:value-of select="."/></li>    </xsl:for-each>  </ul></xsl:if>  This is because it makes two downward selections to read thechild row elements. The use offn:has-children in the xsl:if conditionalis intended to circumvent this restriction. Although the function was introduced to support streaming usecases, it has general utility as a convenience function. 13.11fn:innermost Summary Returns every node within the input sequence that is not anancestor of another member of the input sequence; the nodes arereturned in document order with duplicates eliminated. Signature fn:innermost($nodes as node()*) as node()* Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The effect of the function callfn:innermost($nodes) is defined to be equivalent tothe result of the expression $nodes except$nodes/ancestor::node(). That is, the function takes as input a sequence of nodes, andreturns every node within the sequence that is not an ancestor ofanother node within the sequence; the nodes are returned indocument order with duplicates eliminated. Examples If the source document contains nested sections represented bydiv elements, the expressioninnermost(//div) returns those divelements that do not contain further div elements. 13.12fn:outermost Summary Returns every node within the input sequence that has noancestor that is itself a member of the input sequence; the nodesare returned in document order with duplicates eliminated. Signature fn:outermost($nodes as node()*) as node()* Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The effect of the function callfn:outermost($nodes) is defined to be equivalent tothe result of the expression $nodes[not(ancestor::node()intersect $nodes)]/.. That is, the function takes as input a sequence of nodes, andreturns every node within the sequence that does not haveanother node within the sequence as an ancestor; the nodesare returned in document order with duplicates eliminated. Notes The formulation $nodes except$nodes/descendant::node() might appear to be simpler, butdoes not correctly account for attribute nodes, as these are notdescendants of their parent element. The motivation for the function was based on XSLT streaming usecases. There are cases where the [XSLTransformations (XSLT) Version 3.0] streaming rules allow theconstruct outermost(//section) but do not allow//section; the function can therefore be useful incases where it is known that sections will not be nested, as wellas cases where the application actually wishes to process allsections except those that are nested within another. Examples If the source document contains nested sections represented bydiv elements, the expressionoutermost(//div) returns those divelements that are not contained within furtherdiv elements. 14Functions and operators on sequences A sequence is an ordered collection of zero or moreitems. An item is either a node or anatomic value. The terms sequence and itemare defined formally in [XQuery 3.0: An XMLQuery Language] and [XML Path Language(XPath) 3.0]. 14.1General functions and operators on sequences The following functions are defined on sequences. Thesefunctions work on any sequence, without performing any operationsthat are sensitive to the individual items in the sequence. Function Meaning op:concatenate Returns the concatenation of two sequences. fn:empty Returns true if the argument is the empty sequence. fn:exists Returns true if the argument is a non-empty sequence. fn:head Returns the first item in a sequence. fn:tail Returns all but the first item in a sequence. fn:insert-before Returns a sequence constructed by inserting an item or asequence of items at a given position within an existingsequence. fn:remove Returns a new sequence containing all the items of$target except the item at position$position. fn:reverse Reverses the order of items in a sequence. fn:subsequence Returns the contiguous sequence of items in the value of$sourceSeq beginning at the position indicated by thevalue of $startingLoc and continuing for the number ofitems indicated by the value of $length. fn:unordered Returns the items of $sourceSeq in an Â·implementation dependentÂ· order. As in the previous section, for the illustrative examples below,assume an XQuery or transformation operating on a non-emptyPurchase Order document containing a number of line-item elements.The variable $seq is bound to the sequence ofline-item nodes in document order. The variables$item1, $item2, etc. are bound toseparate, individual line-item nodes in the sequence. 14.1.1op:concatenate Summary Returns the concatenation of two sequences. Operator Mapping Defines the semantics of the infix operator "," when applied toany two sequences. Signature op:concatenate($seq1 as item()*,$seq2 as item()*) as item()* Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns a sequence consisting of all the items in$seq1 followed by all the items in$seq2. Notes If either sequence is the empty sequence, the other operand isreturned. Examples The expression op:concatenate((1, 2, 3), (4, 5))returns (1, 2, 3, 4, 5). The expression op:concatenate((1, 2, 3), ())returns (1, 2, 3). The expression op:concatenate((), ()) returns(). 14.1.2 fn:empty Summary Returns true if the argument is the empty sequence. Signature fn:empty($arg as item()*) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the value of $arg is the empty sequence, thefunction returns true; otherwise, the function returnsfalse. Examples The expression fn:empty((1,2,3)[10]) returnstrue(). The expression fn:empty(fn:remove(("hello", "world"),1)) returns false(). 14.1.3fn:exists Summary Returns true if the argument is a non-empty sequence. Signature fn:exists($arg as item()*) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the value of $arg is a non-empty sequence, thefunction returns true; otherwise, the function returnsfalse. Examples The expression fn:exists(fn:remove(("hello"), 1))returns false(). The expression fn:exists(fn:remove(("hello", "world"),1)) returns true(). 14.1.4 fn:head Summary Returns the first item in a sequence. Signature fn:head($arg as item()*) as item()? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns the value of the expression$arg[1] Notes If $arg is the empty sequence, the empty sequenceis returned. Otherwise the first item in the sequence isreturned. Examples The expression fn:head(1 to 5) returns1. The expression fn:head(("a", "b", "c")) returns"a". The expression fn:head(()) returns(). 14.1.5 fn:tail Summary Returns all but the first item in a sequence. Signature fn:tail($arg as item()*) as item()* Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns the value of the expressionsubsequence($arg, 2) Notes If $arg is the empty sequence, or a sequencecontaining a single item, then the empty sequence is returned. Examples The expression fn:tail(1 to 5) returns (2, 3,4, 5). The expression fn:tail(("a", "b", "c")) returns("b", "c"). The expression fn:tail("a") returns(). The expression fn:tail(()) returns(). 14.1.6fn:insert-before Summary Returns a sequence constructed by inserting an item or asequence of items at a given position within an existingsequence. Signature fn:insert-before( $target as item()*, $position as xs:integer, $inserts as item()*) as item()* Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The value returned by the function consists of all items of$target whose index is less than$position, followed by all items of$inserts, followed by the remaining elements of$target, in that order. Notes If $target is the empty sequence,$inserts is returned. If $inserts is theempty sequence, $target is returned. If $position is less than one (1), the firstposition, the effective value of $position is one (1).If $position is greater than the number of items in$target, then the effective value of$position is equal to the number of items in$target plus 1. The value of $target is not affected by thesequence construction. Examples let $abc := ("a", "b", "c") The expression fn:insert-before($abc, 0, "z")returns ("z", "a", "b", "c"). The expression fn:insert-before($abc, 1, "z")returns ("z", "a", "b", "c"). The expression fn:insert-before($abc, 2, "z")returns ("a", "z", "b", "c"). The expression fn:insert-before($abc, 3, "z")returns ("a", "b", "z", "c"). The expression fn:insert-before($abc, 4, "z")returns ("a", "b", "c", "z"). 14.1.7fn:remove Summary Returns a new sequence containing all the items of$target except the item at position$position. Signature fn:remove($target as item()*,$position as xs:integer) as item()* Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns a sequence consisting of all items of$target whose index is less than$position, followed by all items of$target whose index is greater than$position. Notes If $position is less than 1 or greater than thenumber of items in $target, $target isreturned. If $target is the empty sequence, the emptysequence is returned. Examples let $abc := ("a", "b", "c") The expression fn:remove($abc, 0) returns("a", "b", "c"). The expression fn:remove($abc, 1) returns("b", "c"). The expression fn:remove($abc, 6) returns("a", "b", "c"). The expression fn:remove((), 3) returns(). 14.1.8fn:reverse Summary Reverses the order of items in a sequence. Signature fn:reverse($arg as item()*) as item()* Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns a sequence containing the items in$arg in reverse order. Notes If $arg is the empty sequence, the empty sequenceis returned. Examples let $abc := ("a", "b", "c") The expression fn:reverse($abc) returns ("c","b", "a"). The expression fn:reverse(("hello")) returns("hello"). The expression fn:reverse(()) returns(). 14.1.9fn:subsequence Summary Returns the contiguous sequence of items in the value of$sourceSeq beginning at the position indicated by thevalue of $startingLoc and continuing for the number ofitems indicated by the value of $length. Signatures fn:subsequence($sourceSeq as item()*,$startingLoc as xs:double) as item()* fn:subsequence( $sourceSeq as item()*, $startingLoc as xs:double, $length as xs:double) as item()* Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules In the two-argument case, returns: $sourceSeq[fn:round($startingLoc) le position()] In the three-argument case, returns: $sourceSeq[fn:round($startingLoc) le position()          and position() lt fn:round($startingLoc) + fn:round($length)] Notes The first item of a sequence is located at position 1, notposition 0. If $sourceSeq is the empty sequence, the emptysequence is returned. If $startingLoc is zero or negative, thesubsequence includes items from the beginning of the$sourceSeq. If $length is not specified, the subsequenceincludes items to the end of $sourceSeq. If $length is greater than the number of items inthe value of $sourceSeq following$startingLoc, the subsequence includes items to theend of $sourceSeq. As an exception to the previous two notes, if$startingLoc is -INF and$length is +INF, then fn:round($startingLoc) +fn:round($length) is NaN; sinceposition() lt NaN is always false, the result is anempty sequence. The reason the function accepts arguments of typexs:double is that many computations on untyped datareturn an xs:double result; and the reason for therounding rules is to compensate for any imprecision in thesefloating-point computations. Examples let $seq := ("item1", "item2", "item3","item4", "item5") The expression fn:subsequence($seq, 4) returns("item4", "item5"). The expression fn:subsequence($seq, 3, 2) returns("item3", "item4"). 14.1.10fn:unordered Summary Returns the items of $sourceSeq in an Â·implementation dependentÂ· order. Signature fn:unordered($sourceSeq as item()*) as item()* Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns the items of $sourceSeq in anÂ·implementation dependentÂ· order. Notes Query optimizers may be able to do a better job if the order ofthe output sequence is not specified. For example, when retrievingprices from a purchase order, if an index exists on prices, it maybe more efficient to return the prices in index order rather thanin document order. Examples The expression fn:unordered((1, 2, 3, 4, 5))returns some permutation of (1, 2, 3, 4, 5). 14.2Functions that compare values in sequences The functions in this section rely on comparisons between theitems in one or more sequences. Function Meaning fn:distinct-values Returns the values that appear in a sequence, with duplicateseliminated. fn:index-of Returns a sequence of positive integers giving the positionswithin the sequence $seq of items that are equal to$search. fn:deep-equal This function assesses whether two sequences are deep-equal toeach other. To be deep-equal, they must contain items that arepairwise deep-equal; and for two items to be deep-equal, they musteither be atomic values that compare equal, or nodes of the samekind, with the same name, whose children are deep-equal. 14.2.1 fn:distinct-values Summary Returns the values that appear in a sequence, with duplicateseliminated. Signatures fn:distinct-values($arg as xs:anyAtomicType*) as xs:anyAtomicType* fn:distinct-values( $arg as xs:anyAtomicType*, $collation as xs:string) as xs:anyAtomicType* Properties The one-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations, and implicit timezone. The two-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations, and static base uri, and implicittimezone. Rules The function returns the sequence that results from removingfrom $arg all but one of a set of values that areequal to one another. Values are compared using the eqoperator, subject to the caveats defined below. Values of type xs:untypedAtomic are compared as ifthey were of type xs:string. Values that cannot be compared, because the eqoperator is not defined for their types, are considered to bedistinct. The collation used by this function is determined according tothe rules in 5.3.3 Choosing acollation. This collation is used when string comparison isrequired. For xs:float and xs:double values,positive zero is equal to negative zero and, althoughNaN does not equal itself, if $argcontains multiple NaN values a single NaNis returned. If xs:dateTime, xs:date orxs:time values do not have a timezone, they areconsidered to have the implicit timezone provided by the dynamiccontext for the purpose of comparison. Note thatxs:dateTime, xs:date orxs:time values can compare equal even if theirtimezones are different. The order in which the sequence of values is returned isÂ·implementation dependentÂ·. Which value of a set of values that compare equal is returned isÂ·implementation dependentÂ·. If the input sequence contains values of different numeric typesthat differ from each other by small amounts, then the eq operatoris not transitive, because of rounding effects occurring duringtype promotion. In the situation where the input contains threevalues A, B, and C such thatA eq B, B eq C, but A ne C,then the number of items in the result of the function (as well asthe choice of which items are returned) is Â·implementation dependentÂ·, subject only to the constraints that (a) notwo items in the result sequence compare equal to each other, and(b) every input item that does not appear in the result sequencecompares equal to some item that does appear in the resultsequence. For example, this arises when computing:     distinct-values(            (xs:float('1.0'),            xs:decimal('1.0000000000100000000001',            xs:double( '1.00000000001')) because the values of type xs:float andxs:double both compare equal to the value of typexs:decimal but not equal to each other. Notes If $arg is the empty sequence, the function returnsthe empty sequence. Examples The expression fn:distinct-values((1, 2.0, 3, 2))returns some permutation of (1, 3, 2.0). The expressionfn:distinct-values((xs:untypedAtomic("cherry"),xs:untypedAtomic("plum"), xs:untypedAtomic("plum"))) returnssome permutation of (xs:untypedAtomic("cherry"),xs:untypedAtomic("plum")). 14.2.2fn:index-of Summary Returns a sequence of positive integers giving the positionswithin the sequence $seq of items that are equal to$search. Signatures fn:index-of( $seq as xs:anyAtomicType*, $search as xs:anyAtomicType) as xs:integer* fn:index-of( $seq as xs:anyAtomicType*, $search as xs:anyAtomicType, $collation as xs:string) as xs:integer* Properties The two-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations, and implicit timezone. The three-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations, and static base uri, and implicittimezone. Rules The function returns a sequence of positive integers giving thepositions within the sequence $seq of items that areequal to $search. The collation used by this function is determined according tothe rules in 5.3.3 Choosing acollation. This collation is used when string comparison isrequired. The items in the sequence $seq are compared with$search under the rules for the eqoperator. Values of type xs:untypedAtomic are comparedas if they were of type xs:string. Values that cannotbe compared, because the eq operator is not definedfor their types, are considered to be distinct. If an item comparesequal, then the position of that item in the sequence$seq is included in the result. The first item in a sequence is at position 1, not position0. The result sequence is in ascending numeric order. Notes If the value of $seq is the empty sequence, or ifno item in $seq matches $search, then thefunction returns the empty sequence. No error occurs if non-comparable values are encountered. Sowhen comparing two atomic values, the effective boolean value offn:index-of($a, $b) is true if $a and$b are equal, false if they are not equal or notcomparable. Examples The expression fn:index-of((10, 20, 30, 40), 35)returns (). The expression fn:index-of((10, 20, 30, 30, 20, 10),20) returns (2, 5). The expression fn:index-of(("a", "sport", "and", "a","pastime"), "a") returns (1, 4). The expression fn:index-of(current-date(), 23)returns (). If @a is an attribute of typexs:NMTOKENS whose string value is "red greenblue", and whose typed value is therefore ("red","green", "blue"), then fn:index-of(@a, "blue")returns 3. This is because the function callingmechanism atomizes the attribute node to produce a sequence ofthree xs:NMTOKEN values. 14.2.3fn:deep-equal Summary This function assesses whether two sequences are deep-equal toeach other. To be deep-equal, they must contain items that arepairwise deep-equal; and for two items to be deep-equal, they musteither be atomic values that compare equal, or nodes of the samekind, with the same name, whose children are deep-equal. Signatures fn:deep-equal($parameter1 as item()*,$parameter2 as item()*) as xs:boolean fn:deep-equal( $parameter1 as item()*, $parameter2 as item()*, $collation as xs:string) as xs:boolean Properties The two-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations, and implicit timezone. The three-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations, and static base uri, and implicittimezone. Rules The $collation argument identifies a collationwhich is used at all levels of recursion when strings are compared(but not when names are compared), according to the rules in5.3.3 Choosing acollation. If the two sequences are both empty, the function returnstrue. If the two sequences are of different lengths, the functionreturns false. If the two sequences are of the same length, the functionreturns true if and only if every item in the sequence$parameter1 is deep-equal to the item at the sameposition in the sequence $parameter2. The rules fordeciding whether two items are deep-equal follow. Call the two items $i1 and $i2respectively. If $i1 and $i2 are both atomic values,they are deep-equal if and only if ($i1 eq $i2) istrue, or if both values are NaN. If theeq operator is not defined for $i1 and$i2, the function returns false. If one of the pair $i1 or $i2 is anatomic value and the other is not, the function returnsfalse. If $i1 and $i2 are both nodes, theyare compared as described below: If the two nodes are of different kinds, the result isfalse. If the two nodes are both document nodes then they aredeep-equal if and only if the sequence $i1/(*|text())is deep-equal to the sequence $i2/(*|text()). If the two nodes are both element nodes then they are deep-equalif and only if all of the following conditions are satisfied: The two nodes have the same name, that is (node-name($i1)eq node-name($i2)). Either both nodes are both annotated as having simple content orboth nodes are annotated as having complex content. For thispurpose "simple content" means either a simple type or a complextype with simple content; "complex content" means a complex typewhose variety is mixed, element-only, or empty. Note: It is a consequence of this rule that validating a documentD against a schema will usually (but not necessarily)result in a document that is not deep-equal to D. Theexception is when the schema allows all elements to have mixedcontent. The two nodes have the same number of attributes, and for everyattribute $a1 in $i1/@* there exists anattribute $a2 in $i2/@* such that$a1 and $a2 are deep-equal. One of the following conditions holds: Both element nodes are annotated as having simple content(as defined in 3(b) above), and the typed value of$i1 is deep-equal to the typed value of$i2. Both element nodes have a type annotation that is acomplex type with variety element-only, and the sequence$i1/* is deep-equal to the sequence$i2/*. Both element nodes have a type annotation that is acomplex type with variety mixed, and the sequence$i1/(*|text()) is deep-equal to the sequence$i2/(*|text()). Both element nodes have a type annotation that is acomplex type with variety empty. If the two nodes are both attribute nodes then they aredeep-equal if and only if both the following conditions aresatisfied: The two nodes have the same name, that is (node-name($i1)eq node-name($i2)). The typed value of $i1 is deep-equal to the typedvalue of $i2. If the two nodes are both processing instruction nodes, thenthey are deep-equal if and only if both the following conditionsare satisfied: The two nodes have the same name, that is (node-name($i1)eq node-name($i2)). The string value of $i1 is equal to the stringvalue of $i2. If the two nodes are both namespace nodes, then they aredeep-equal if and only if both the following conditions aresatisfied: The two nodes either have the same name or are both nameless,that is fn:deep-equal(node-name($i1),node-name($i2)). The string value of $i1 is equal to the stringvalue of $i2 when compared using the Unicode codepointcollation. If the two nodes are both text nodes or comment nodes, then theyare deep-equal if and only if their string-values are equal. Error Conditions A type error is raised [err:FOTY0015] if either input sequencecontains a function item. Notes The two nodes are not required to have the same type annotation,and they are not required to have the same in-scope namespaces.They may also differ in their parent, their base URI, and thevalues returned by the is-id andis-idrefs accessors (see Section 5.5is-id Accessor DM30 and Section 5.6is-idrefs Accessor DM30). The orderof children is significant, but the order of attributes isinsignificant. The contents of comments and processing instructions aresignificant only if these nodes appear directly as items in the twosequences being compared. The content of a comment or processinginstruction that appears as a descendant of an item in one of thesequences being compared does not affect the result. However, thepresence of a comment or processing instruction, if it causes atext node to be split into two text nodes, may affect theresult. The result of fn:deep-equal(1, current-dateTime())is false; it does not raise an error. Examples let $at := <attendees> <name last='Parker'            first='Peter'/> <name last='Barker' first='Bob'/> <name last='Parker'            first='Peter'/> </attendees> The expression fn:deep-equal($at, $at/*) returnsfalse(). The expression fn:deep-equal($at/name[1],$at/name[2]) returns false(). The expression fn:deep-equal($at/name[1],$at/name[3]) returns true(). The expression fn:deep-equal($at/name[1], 'PeterParker') returns false(). 14.3 Functions that test thecardinality of sequences The following functions test the cardinality of their sequencearguments. Function Meaning fn:zero-or-one Returns $arg if it contains zero or one items.Otherwise, raises an error. fn:one-or-more Returns $arg if it contains one or more items.Otherwise, raises an error. fn:exactly-one Returns $arg if it contains exactly one item.Otherwise, raises an error. The functions fn:zero-or-one, fn:one-or-more, and fn:exactly-one defined in thissection, check that the cardinality of a sequence is in theexpected range. They are particularly useful with regard to statictyping. For example, the function call fn:remove($seq, fn:index-of($seq2,'abc')) requires the result of the call on fn:index-of to be a singletoninteger, but the static type system cannot infer this; writing theexpression as fn:remove($seq,fn:exactly-one(fn:index-of($seq2, 'abc'))) will providea suitable static type at query analysis time, and ensures that thelength of the sequence is correct with a dynamic check at queryexecution time. The type signatures for these functions deliberately declare theargument type as item()*, permitting a sequence of anylength. A more restrictive signature would defeat the purpose ofthe function, which is to defer cardinality checking until queryexecution time. 14.3.1fn:zero-or-one Summary Returns $arg if it contains zero or one items.Otherwise, raises an error. Signature fn:zero-or-one($arg as item()*) as item()? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules Except in error cases, the function returns $argunchanged. Error Conditions A dynamic error is raised [err:FORG0003] if $argcontains more than one item. 14.3.2fn:one-or-more Summary Returns $arg if it contains one or more items.Otherwise, raises an error. Signature fn:one-or-more($arg as item()*) as item()+ Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules Except in error cases, the function returns $argunchanged. Error Conditions A dynamic error is raised [err:FORG0004] if $arg is anempty sequence. 14.3.3fn:exactly-one Summary Returns $arg if it contains exactly one item.Otherwise, raises an error. Signature fn:exactly-one($arg as item()*) as item() Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules Except in error cases, the function returns $argunchanged. Error Conditions A dynamic error is raised [err:FORG0005] if $arg is anempty sequence or a sequence containing more than one item. 14.4 Union, intersection anddifference Function Meaning op:union Constructs a sequence containing every node that occurs in thevalues of either $arg1 or $arg2,eliminating duplicates and sorting the result in documentorder. op:intersect Constructs a sequence containing every node that occurs in thevalues of both $arg1 and $arg2,eliminating duplicates and sorting the result in documentorder. op:except Constructs a sequence containing every node that occurs in thevalue of $arg1 but not in the value of$arg2, eliminating duplicates and sorting the resultin document order. As in the previous sections, for the illustrative examplesbelow, assume an XQuery or transformation operating on a PurchaseOrder document containing a number of line-item elements. Thevariables $item1, $item2, etc. are boundto individual line-item nodes in the sequence. We use sequences ofthese nodes in some of the examples below. 14.4.1 op:union Summary Constructs a sequence containing every node that occurs in thevalues of either $arg1 or $arg2,eliminating duplicates and sorting the result in documentorder. Operator Mapping Defines the semantics of the "union" or "|" operator whenapplied to two sequences of nodes. Signature op:union($arg1 as node()*,$arg2 as node()*) as node()* Rules The function returns a sequence containing every node thatoccurs in the values of either $arg1 or$arg2, eliminating duplicate nodes. Nodes are returnedin document order. Two nodes $n1 and $n2 are duplicatesif they satisfy op:is-same-node($n1,$n2). Notes If either operand is the empty sequence, the result is asequence containing the nodes in the other operand in documentorder after eliminating duplicates. Examples let $seq1 := ($item1, $item2) let $seq2 := ($item2, $item2,$item1) let $seq3 := ($item2, $item3) The expression op:union($seq1, $seq1) returns($item1, $item2). The expression op:union($seq2, $seq3) returns($item1, $item2, $item3). The expression op:union($seq2, ()) returns($item1, $item2). 14.4.2op:intersect Summary Constructs a sequence containing every node that occurs in thevalues of both $arg1 and $arg2,eliminating duplicates and sorting the result in documentorder. Operator Mapping Defines the semantics of the "intersect" operator when appliedto two sequences of nodes. Signature op:intersect($arg1 as node()*,$arg2 as node()*) as node()* Rules The function returns a sequence containing every node thatoccurs in the values of both $arg1 and$arg2, eliminating duplicate nodes. Nodes are returnedin document order. Two nodes $n1 and $n2 are duplicatesif they satisfy op:is-same-node($n1,$n2). Notes If either operand is the empty sequence, the function returnsthe empty sequence. Examples let $seq1 := ($item1, $item2) let $seq2 := ($item2, $item2,$item1) let $seq3 := ($item2, $item3) The expression op:intersect($seq1, $seq1) returns($item1, $item2). The expression op:intersect($seq2, $seq3) returns($item2). The expression op:intersect($seq2, ()) returns(). The expression op:intersect($item1, $item3) returns(). 14.4.3op:except Summary Constructs a sequence containing every node that occurs in thevalue of $arg1 but not in the value of$arg2, eliminating duplicates and sorting the resultin document order. Operator Mapping Defines the semantics of the "except" operator when applied totwo sequences of nodes. Signature op:except($arg1 as node()*,$arg2 as node()*) as node()* Rules The function returns a sequence containing every node thatoccurs in the value of $arg1 provided that it does notoccur in the value of $arg2. Duplicate nodes areeliminated, and nodes are returned in document order. Two nodes $n1 and $n2 are duplicatesif they satisfy op:is-same-node($n1,$n2). Notes If $arg1 is the empty sequence, the empty sequenceis returned. If $arg2 is the empty sequence, a sequence isreturned containing the nodes in $arg1 in documentorder after eliminating duplicates. Examples let $seq1 := ($item1, $item2) let $seq2 := ($item2, $item2,$item1) let $seq3 := ($item2, $item3) The expression op:except($seq1, $seq1) returns(). The expression op:except($seq2, $seq1) returns(). The expression op:except($seq2, $seq3) returns($item1). The expression op:except($seq2, ()) returns($item1, $item2). The expression op:except($seq3, $seq2) returns($item3). 14.5Aggregate functions Aggregate functions take a sequence as argument and return asingle value computed from values in the sequence. Except forfn:count, the sequence mustconsist of values of a single type or one if its subtypes, or theymust be numeric. xs:untypedAtomic values are permittedin the input sequence and handled by special conversion rules. Thetype of the items in the sequence must also support certainoperations. Function Meaning fn:count Returns the number of items in a sequence. fn:avg Returns the average of the values in the input sequence$arg, that is, the sum of the values divided by thenumber of values. fn:max Returns a value that is equal to the highest value appearing inthe input sequence. fn:min Returns a value that is equal to the lowest value appearing inthe input sequence. fn:sum Returns a value obtained by adding together the values in$arg. 14.5.1 fn:count Summary Returns the number of items in a sequence. Signature fn:count($arg as item()*) as xs:integer Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns the number of items in the value of$arg. Notes Returns 0 if $arg is the empty sequence. Examples let $seq1 := ($item1, $item2) let $seq2 := (98.5, 98.3, 98.9) let $seq3 := () The expression fn:count($seq1) returns2. The expression fn:count($seq3) returns0. The expression fn:count($seq2) returns3. The expression fn:count($seq2[. > 100]) returns0. 14.5.2 fn:avg Summary Returns the average of the values in the input sequence$arg, that is, the sum of the values divided by thenumber of values. Signature fn:avg($arg as xs:anyAtomicType*) as xs:anyAtomicType? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $arg is the empty sequence, the empty sequenceis returned. If $arg contains values of typexs:untypedAtomic they are cast toxs:double. Duration values must either all bexs:yearMonthDuration values or must all bexs:dayTimeDuration values. For numeric values, thenumeric promotion rules defined in 4.2Arithmetic operators on numeric values are used to promoteall values to a single common type. After these operations,$arg must contain items of a single type, which mustbe one of the four numeric types, xs:yearMonthDurationor xs:dayTimeDuration or one if its subtypes. The function returns the average of the values assum($arg) div count($arg); but the implementation mayuse an otherwise equivalent algorithm that avoids arithmeticoverflow. Error Conditions A type error is raised [err:FORG0006] if the input sequence containsitems of incompatible types, as described above. Examples let $d1 :=xs:yearMonthDuration("P20Y") let $d2 :=xs:yearMonthDuration("P10M") let $seq3 := (3, 4, 5) The expression fn:avg($seq3) returns4.0. (The result is of typexs:decimal.). The expression fn:avg(($d1, $d2)) returnsxs:yearMonthDuration("P10Y5M"). fn:avg(($d1, $seq3)) raises a type error [err:FORG0006]. The expression fn:avg(()) returns(). The expression fn:avg((xs:float('INF'),xs:float('-INF'))) returns xs:float('NaN'). The expression fn:avg(($seq3, xs:float('NaN')))returns xs:float('NaN'). 14.5.3 fn:max Summary Returns a value that is equal to the highest value appearing inthe input sequence. Signatures fn:max($arg as xs:anyAtomicType*) as xs:anyAtomicType? fn:max($arg as xs:anyAtomicType*, $collation as xs:string) as xs:anyAtomicType? Properties The zero-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations, and implicit timezone. The one-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations, and static base uri, and implicittimezone. Rules The following rules are applied to the input sequence$arg: Values of type xs:untypedAtomic in$arg are cast to xs:double. Numeric and xs:anyURI values are converted to theleast common type reachable by a combination of type promotion andsubtype substitution. See Section B.1 TypePromotion XP30 and Section B.2 OperatorMapping XP30. The items in the resulting sequence may be reordered in anarbitrary order. The resulting sequence is referred to below as theconverted sequence. The function returns an item from the convertedsequence rather than the input sequence. If the converted sequence is empty, the function returns theempty sequence. All items in the converted sequence must be derivedfrom a single base type for which the le operator isdefined. In addition, the values in the sequence must have a totalorder. If date/time values do not have a timezone, they areconsidered to have the implicit timezone provided by the dynamiccontext for the purpose of comparison. Duration values must eitherall be xs:yearMonthDuration values or must all bexs:dayTimeDuration values. If the converted sequence contains the value NaN,the value NaN is returned. If the items in the converted sequence are of typexs:string or types derived by restriction fromxs:string, then the determination of the item with thesmallest value is made according to the collation that is used. Ifthe type of the items in the converted sequence is notxs:string and $collation is specified,the collation is ignored. The collation used by this function is determined according tothe rules in 5.3.3 Choosing acollation. The function returns the result of the expression:    if (every $v in $c satisfies $c[1] ge $v)   then $c[1]    else fn:max(fn:subsequence($c, 2)) evaluated with $collation as the default collationif specified, and with $c as the convertedsequence. Error Conditions A type error is raised [err:FORG0006] if the input sequence containsitems of incompatible types, as described above. Notes Because the rules allow the sequence to be reordered, if thereare two or items that are "equal highest", the specific item whosevalue is returned is Â·implementation dependentÂ·. This can arise for example if two differentstrings compare equal under the selected collation, or if twodifferent xs:dateTime values compare equal despitebeing in different timezones. If the converted sequence contains exactly one value then thatvalue is returned. The default type when the fn:max function isapplied to xs:untypedAtomic values isxs:double. This differs from the default type foroperators such as gt, and for sorting in XQuery andXSLT, which is xs:string. Examples The expression fn:max((3,4,5)) returns5. The expression fn:max((xs:integer(5), xs:float(5.0),xs:double(0))) returns xs:double(5.0e0). fn:max((3,4,"Zero")) raises a type error [err:FORG0006]. The expression fn:max((fn:current-date(),xs:date("2100-01-01"))) returnsxs:date("2100-01-01"). (Assuming that the currentdate is during the 21st century.). The expression fn:max(("a", "b", "c")) returns"c". (Assuming a typical defaultcollation.). 14.5.4 fn:min Summary Returns a value that is equal to the lowest value appearing inthe input sequence. Signatures fn:min($arg as xs:anyAtomicType*) as xs:anyAtomicType? fn:min($arg as xs:anyAtomicType*, $collation as xs:string) as xs:anyAtomicType? Properties The zero-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations, and implicit timezone. The one-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations, and static base uri, and implicittimezone. Rules The following rules are applied to the input sequence: Values of type xs:untypedAtomic in$arg are cast to xs:double. Numeric and xs:anyURI values are converted to theleast common type reachable by a combination of type promotion andsubtype substitution. See Section B.1 TypePromotion XP30 and Section B.2 OperatorMapping XP30. The items in the resulting sequence may be reordered in anarbitrary order. The resulting sequence is referred to below as theconverted sequence. The function returns an item from the convertedsequence rather than the input sequence. If the converted sequence is empty, the empty sequence isreturned. All items in the converted sequence must be derivedfrom a single base type for which the le operator isdefined. In addition, the values in the sequence must have a totalorder. If date/time values do not have a timezone, they areconsidered to have the implicit timezone provided by the dynamiccontext for the purpose of comparison. Duration values must eitherall be xs:yearMonthDuration values or must all bexs:dayTimeDuration values. If the converted sequence contains the value NaN,the value NaN is returned. If the items in the converted sequence are of typexs:string or types derived by restriction fromxs:string, then the determination of the item with thesmallest value is made according to the collation that is used. Ifthe type of the items in the converted sequence is notxs:string and $collation is specified,the collation is ignored. The collation used by this function is determined according tothe rules in 5.3.3 Choosing acollation. The function returns the result of the expression:    if (every $v in $c satisfies $c[1] le $v)    then $c[1]    else fn:min(fn:subsequence($c, 2)) evaluated with $collation as the default collationif specified, and with $c as the convertedsequence. Error Conditions A type error is raised [err:FORG0006] if the input sequence containsitems of incompatible types, as described above. Notes Because the rules allow the sequence to be reordered, if thereare two or items that are "equal lowest", the specific item whosevalue is returned is Â·implementation dependentÂ·. This can arise for example if two differentstrings compare equal under the selected collation, or if twodifferent xs:dateTime values compare equal despitebeing in different timezones. If the converted sequence contains exactly one value then thatvalue is returned. The default type when the fn:min function isapplied to xs:untypedAtomic values isxs:double. This differs from the default type foroperators such as lt, and for sorting in XQuery andXSLT, which is xs:string. Examples The expression fn:min((3,4,5)) returns3. The expression fn:min((xs:integer(5), xs:float(5),xs:double(10))) returns xs:double(5.0e0). fn:min((3,4,"Zero")) raises a type error [err:FORG0006]. fn:min((xs:float(0.0E0), xs:float(-0.0E0))) canreturn either positive or negative zero. The two items areequal, so it is Â·implementation dependentÂ· which is returned. The expression fn:min((fn:current-date(),xs:date("1900-01-01"))) returnsxs:date("1900-01-01"). (Assuming that the currentdate is set to a reasonable value.). The expression fn:min(("a", "b", "c")) returns"a". (Assuming a typical defaultcollation.). 14.5.5 fn:sum Summary Returns a value obtained by adding together the values in$arg. Signatures fn:sum($arg as xs:anyAtomicType*) as xs:anyAtomicType fn:sum( $arg as xs:anyAtomicType*, $zero as xs:anyAtomicType?) as xs:anyAtomicType? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules Any values of type xs:untypedAtomic in$arg are cast to xs:double. The items inthe resulting sequence may be reordered in an arbitrary order. Theresulting sequence is referred to below as the convertedsequence. If the converted sequence is empty, then the single-argumentform of the function returns the xs:integer value0; the two-argument form returns the value of theargument $zero. If the converted sequence contains the value NaN,NaN is returned. All items in $arg must be numeric or derived from asingle base type. In addition, the type must support addition.Duration values must either all bexs:yearMonthDuration values or must all bexs:dayTimeDuration values. For numeric values, thenumeric promotion rules defined in 4.2Arithmetic operators on numeric values are used to promoteall values to a single common type. The sum of a sequence ofintegers will therefore be an integer, while the sum of a numericsequence that includes at least one xs:double will bean xs:double. The result of the function, using the second signature, is theresult of the expression: if (fn:count($c) eq 0) then    $zeroelse if (fn:count($c) eq 1) then    $c[1]else    $c[1] + fn:sum(subsequence($c, 2)) where $c is the converted sequence. The result of the function, using the first signature, is theresult of the expression: fn:sum($arg, 0). Error Conditions A type error is raised [err:FORG0006] if the input sequence containsitems of incompatible types, as described above. Notes The second argument allows an appropriate value to be defined torepresent the sum of an empty sequence. For example, when summing asequence of durations it would be appropriate to return azero-length duration of the appropriate type. This argument isnecessary because a system that does dynamic typing cannotdistinguish "an empty sequence of integers", for example, from "anempty sequence of durations". If the converted sequence contains exactly one value then thatvalue is returned. Examples let $d1 :=xs:yearMonthDuration("P20Y") let $d2 :=xs:yearMonthDuration("P10M") let $seq1 := ($d1, $d2) let $seq3 := (3, 4, 5) The expression fn:sum(($d1, $d2)) returnsxs:yearMonthDuration("P20Y10M"). The expression fn:sum($seq1[. ltxs:yearMonthDuration('P3M')], xs:yearMonthDuration('P0M'))returns xs:yearMonthDuration("P0M"). The expression fn:sum($seq3) returns12. The expression fn:sum(()) returns0. The expression fn:sum((),()) returns(). The expression fn:sum((1 to 100)[. lt 0], 0)returns 0. fn:sum(($d1, 9E1)) raises a type error[err:FORG0006]. The expression fn:sum(($d1, $d2), "ein Augenblick")returns xs:yearMonthDuration("P20Y10M"). (There isno requirement that the $zero value should be the sametype as the items in $arg, or even that it shouldbelong to a type that supports addition.). 14.6 Functions and operators thatgenerate sequences Function Meaning op:to Returns a sequence of consecutive integers in a givenrange. 14.6.1 op:to Summary Returns a sequence of consecutive integers in a given range. Operator Mapping Defines the semantics of the "to" operator when applied to twointeger arguments. Signature op:to($firstval as xs:integer,$lastval as xs:integer) as xs:integer* Rules The function returns the sequence containing everyxs:integer whose value is between the value of$firstval (inclusive) and the value of$lastval (inclusive), in monotonic increasingorder. If the value of the first operand is greater than the value ofthe second, the function returns the empty sequence. If the values of the two operands are equal, the functionreturns a sequence containing a single xs:integerequal to that value. Examples The expression 1 to 3 returns (1, 2,3). The expression 3 to 1 returns (). The expression 5 to 5 returns 5. 14.7Functions on node identifiers 14.7.1 fn:id Summary Returns the sequence of element nodes that have anID value matching the value of one or more of theIDREF values supplied in $arg. Signatures fn:id($arg as xs:string*) as element()* fn:id($arg as xs:string*, $node as node()) as element()* Properties The one-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The two-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns a sequence, in document order withduplicates eliminated, containing every element node Ethat satisfies all the following conditions: E is in the target document. The target document isthe document containing $node, or the documentcontaining the context item (.) if the second argumentis omitted. The behavior of the function if $node isomitted is exactly the same as if the context item had been passedas $node. E has an ID value equal to one of thecandidate IDREF values, where: An element has an ID value equal to Vif either or both of the following conditions are true: The is-id property (See Section 5.5is-id Accessor DM30.) of the elementnode is true, and the typed value of the element node is equal toV under the rules of the eq operatorusing the Unicode codepoint collation(http://www.w3.org/2005/xpath-functions/collation/codepoint). The element has an attribute node whose is-idproperty (See Section 5.5is-id Accessor DM30.) is true andwhose typed value is equal to V under the rules of theeq operator using the Unicode code point collation(http://www.w3.org/2005/xpath-functions/collation/codepoint). Each xs:string in $arg is parsed as ifit were of type IDREFS, that is, eachxs:string in $arg is treated as awhitespace-separated sequence of tokens, each acting as anIDREF. These tokens are then included in the list ofcandidate IDREFs. If any of the tokens is not alexically valid IDREF (that is, if it is not lexicallyan xs:NCName), it is ignored. Formally, the candidateIDREF values are the strings in the sequence given bythe expression: for $s in $arg return     fn:tokenize(fn:normalize-space($s), ' ')[. castable as xs:IDREF] If several elements have the same ID value, thenE is the one that is first in document order. Error Conditions A dynamic error is raised [err:FODC0001] if $node, orthe context item if the second argument is absent, is a node in atree whose root is not a document node. The following errors may be raised when $node isomitted: If the context item is absentDM30,dynamic error [err:XPDY0002]XP30 If the context item is not a node, type error[err:XPTY0004]XP30. Notes The effect of this function is anomalous in respect of elementnodes with the is-id property. For legacy reasons,this function returns the element that has the is-idproperty, whereas it would be more appropriate to return itsparent, that being the element that is uniquely identified by theID. A new function element-with-id is being introducedwith the desired behavior. If the data model is constructed from an Infoset, an attributewill have the is-id property if the correspondingattribute in the Infoset had an attribute type of ID:typically this means the attribute was declared as anID in a DTD. If the data model is constructed from a PSVI, an element orattribute will have the is-id property if its typedvalue is a single atomic value of type xs:ID or a typederived by restriction from xs:ID. No error is raised in respect of a candidate IDREFvalue that does not match the ID of any element in thedocument. If no candidate IDREF value matches theID value of any element, the function returns theempty sequence. It is not necessary that the supplied argument should have typexs:IDREF or xs:IDREFS, or that it shouldbe derived from a node with the is-idrefsproperty. An element may have more than one ID value. Thiscan occur with synthetic data models or with data modelsconstructed from a PSVI where the element and one of its attributesare both typed as xs:ID. If the source document is well-formed but not valid, it ispossible for two or more elements to have the same IDvalue. In this situation, the function will select the first suchelement. It is also possible in a well-formed but invalid document tohave an element or attribute that has the is-idproperty but whose value does not conform to the lexical rules forthe xs:ID type. Such a node will never be selected bythis function. Examples let $emp :=             <employee xml:id="ID21256">               <empnr>E21256</empnr>               <first>John</first>               <last>Brown</last>            </employee>         The expression id('ID21256')/name() returnsemployee. (The xml:id attribute hasthe is-id property, so the employee element isselected.). The expression id('E21256')/name() returnsempnr. (Assuming the empnr element isgiven the type xs:ID as a result of schema validation,the element will have the is-id property and istherefore selected. Note the difference from the behavior offn:element-with-id.). 14.7.2 fn:element-with-id Summary Returns the sequence of element nodes that have anID value matching the value of one or more of theIDREF values supplied in $arg. Signatures fn:element-with-id($arg as xs:string*) as element()* fn:element-with-id($arg as xs:string*, $node as node()) as element()* Properties The one-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The two-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules Note: The effect of this function is identical to fn:idin respect of elements that have an attribute with theis-id property. However, it behaves differently inrespect of element nodes with the is-id property.Whereas the fn:id, for legacyreasons, returns the element that has the is-idproperty, this parent returns the element identified by the ID,which is the parent of the element having the is-idproperty. The function returns a sequence, in document order withduplicates eliminated, containing every element node Ethat satisfies all the following conditions: E is in the target document. The target document isthe document containing $node, or the documentcontaining the context item (.) if the second argumentis omitted. The behavior of the function if $node isomitted is exactly the same as if the context item had been passedas $node. E has an ID value equal to one of thecandidate IDREF values, where: An element has an ID value equal to Vif either or both of the following conditions are true: The element has an child element node whose is-idproperty (See Section 5.5is-id Accessor DM30.) is true andwhose typed value is equal to V under the rules of theeq operator using the Unicode code point collation(http://www.w3.org/2005/xpath-functions/collation/codepoint). The element has an attribute node whose is-idproperty (See Section 5.5is-id Accessor DM30.) is true andwhose typed value is equal to V under the rules of theeq operator using the Unicode code point collation(http://www.w3.org/2005/xpath-functions/collation/codepoint). Each xs:string in $arg is parsed as ifit were of type IDREFS, that is, eachxs:string in $arg is treated as awhitespace-separated sequence of tokens, each acting as anIDREF. These tokens are then included in the list ofcandidate IDREFs. If any of the tokens is not alexically valid IDREF (that is, if it is not lexicallyan xs:NCName), it is ignored. Formally, the candidateIDREF values are the strings in the sequence given bythe expression: for $s in $arg return    fn:tokenize(fn:normalize-space($s), ' ')[. castable as xs:IDREF] If several elements have the same ID value, thenE is the one that is first in document order. Error Conditions A dynamic error is raised [err:FODC0001] if $node, orthe context item if the second argument is omitted, is a node in atree whose root is not a document node. The following errors may be raised when $node isomitted: If the context item is absentDM30,dynamic error [err:XPDY0002]XP30 If the context item is not a node, type error[err:XPTY0004]XP30. Notes This function is equivalent to the fn:id function except when dealing withID-valued element nodes. Whereas the fn:id function selects the elementcontaining the identifier, this function selects its parent. If the data model is constructed from an Infoset, an attributewill have the is-id property if the correspondingattribute in the Infoset had an attribute type of ID:typically this means the attribute was declared as anID in a DTD. If the data model is constructed from a PSVI, an element orattribute will have the is-id property if its typedvalue is a single atomic value of type xs:ID or a typederived by restriction from xs:ID. No error is raised in respect of a candidate IDREFvalue that does not match the ID of any element in thedocument. If no candidate IDREF value matches theID value of any element, the function returns theempty sequence. It is not necessary that the supplied argument should have typexs:IDREF or xs:IDREFS, or that it shouldbe derived from a node with the is-idrefsproperty. An element may have more than one ID value. Thiscan occur with synthetic data models or with data modelsconstructed from a PSVI where the element and one of its attributesare both typed as xs:ID. If the source document is well-formed but not valid, it ispossible for two or more elements to have the same IDvalue. In this situation, the function will select the first suchelement. It is also possible in a well-formed but invalid document tohave an element or attribute that has the is-idproperty but whose value does not conform to the lexical rules forthe xs:ID type. Such a node will never be selected bythis function. Examples let $emp :=             <employee xml:id="ID21256">               <empnr>E21256</empnr>               <first>John</first>               <last>Brown</last>            </employee>         The expression id('ID21256')/name() returns"employee". (The xml:id attribute hasthe is-id property, so the employee element isselected.). The expression id('E21256')/name() returns"employee". (Assuming the empnrelement is given the type xs:ID as a result of schemavalidation, the element will have the is-id propertyand is therefore its parent is selected. Note the difference fromthe behavior of fn:id.). 14.7.3 fn:idref Summary Returns the sequence of element or attribute nodes with anIDREF value matching the value of one or more of theID values supplied in $arg. Signatures fn:idref($arg as xs:string*) as node()* fn:idref($arg as xs:string*, $node as node()) as node()* Properties The one-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The two-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The function returns a sequence, in document order withduplicates eliminated, containing every element or attribute node$N that satisfies all the following conditions: $N is in the target document. The target documentis the document containing $node or the documentcontaining the context item (.) if the second argumentis omitted. The behavior of the function if $node isomitted is exactly the same as if the context item had been passedas $node. $N has an IDREF value equal to one ofthe candidate ID values, where: A node $N has an IDREF value equal toV if both of the following conditions are true: The is-idrefs property (see Section 5.6is-idrefs Accessor DM30) of$N is true. The sequence fn:tokenize(fn:normalize-space(fn:string($N)), ' ') contains a string that is equal to V under the rulesof the eq operator using the Unicode code pointcollation(http://www.w3.org/2005/xpath-functions/collation/codepoint). Each xs:string in $arg is parsed as ifit were of lexically of type xs:ID. Thesexs:strings are then included in the list of candidatexs:IDs. If any of the strings in $arg isnot a lexically valid xs:ID (that is, if it is notlexically an xs:NCName), it is ignored. More formally,the candidate ID values are the strings in thesequence: $arg[. castable as xs:NCName] Error Conditions A dynamic error is raised [err:FODC0001] if $node, orthe context item if the second argument is omitted, is a node in atree whose root is not a document node. The following errors may be raised when $node isomitted: If the context item is absentDM30,dynamic error [err:XPDY0002]XP30 If the context item is not a node, type error[err:XPTY0004]XP30. Notes An element or attribute typically acquires theis-idrefs property by being validated against theschema type xs:IDREF or xs:IDREFS, or(for attributes only) by being described as of typeIDREF or IDREFS in a DTD. No error is raised in respect of a candidate IDvalue that does not match the IDREF value of anyelement or attribute in the document. If no candidateID value matches the IDREF value of anyelement or attribute, the function returns the empty sequence. It is possible for two or more nodes to have anIDREF value that matches a given candidateID value. In this situation, the function will returnall such nodes. However, each matching node will be returned atmost once, regardless how many candidate ID values itmatches. It is possible in a well-formed but invalid document to have anode whose is-idrefs property is true but that doesnot conform to the lexical rules for the xs:IDREFtype. The effect of the above rules is that ill-formed candidateID values and ill-formed IDREF values areignored. If the data model is constructed from a PSVI, the typed value ofa node that has the is-idrefs property will contain atleast one atomic value of type xs:IDREF (or a typederived by restriction from xs:IDREF). It may alsocontain atomic values of other types. These atomic values aretreated as candidate ID values if their lexical formis valid as an xs:NCName, and they are ignoredotherwise. 14.7.4fn:generate-id Summary This function returns a string that uniquely identifies a givennode. Signatures fn:generate-id() as xs:string fn:generate-id($arg as node()?) as xs:string Properties The zero-argument form of this function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. The one-argument form of this function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If the argument is omitted, it defaults to the context item(.). The behavior of the function if the argument isomitted is exactly the same as if the context item had been passedas the argument. If the argument is the empty sequence, the result is thezero-length string. In other cases, the function returns a string that uniquelyidentifies a given node. The returned identifier must consist of ASCIIalphanumeric characters and must start with analphabetic character. Thus, the string is syntactically an XMLname. An implementation is free to generate an identifier in anyconvenient way provided that it always generates the sameidentifier for the same node and that different identifiers arealways generated from different nodes. An implementation is underno obligation to generate the same identifiers each time a documentis transformed or queried. Error Conditions The following errors may be raised when $arg isomitted: If the context item is absentDM30,dynamic error [err:XPDY0002]XP30 If the context item is not a node, type error[err:XPTY0004]XP30. Notes There is no guarantee that a generated unique identifier will bedistinct from any unique IDs specified in the source document. There is no inverse to this function; it is not directlypossible to find the node with a given generated ID. Of course, itis possible to search a given sequence of nodes using an expressionsuch as $nodes[generate-id()=$id]. It is advisable, but not required, for implementations togenerate IDs that are distinct even when compared using acase-blind collation. Examples The primary use case for this function is to generatehyperlinks. For example, when generating HTML, an anchor for agiven section $sect can be generated by writing (ineither XSLT or XQuery): <a name="{generate-id($sect)}"/> and a link to that section can then be produced with code suchas: see <ahref="#{generate-id($sect)}">here</a> Note that anchors generated in this way will not necessarily bethe same each time a document is republished. 14.8 Functionsgiving access to external information 14.8.1 fn:doc Summary Retrieves a document using a URI supplied as anxs:string, and returns the corresponding documentnode. Signature fn:doc($uri as xs:string?) as document-node()? Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on available documents, and static base uri. Rules If $uri is the empty sequence, the result is anempty sequence. If $uri is a relative URI reference, it is resolvedrelative to the value of the Static Base URI property fromthe static context. The resulting absolute URI is promotedto an xs:string. If the Available documents described in Section 2.1.2 DynamicContext XP30 provides a mapping fromthis string to a document node, the function returns that documentnode. The URI may include a fragment identifier. By default, this function is Â·deterministicÂ·. Two calls on this function return the samedocument node if the same URI Reference (after resolution to anabsolute URI Reference) is supplied to both calls. Thus, thefollowing expression (if it does not raise an error) will always betrue: doc("foo.xml") is doc("foo.xml") However, for performance reasons, implementations may provide auser option to evaluate the function without a guarantee ofdeterminism. The manner in which any such option is provided isimplementation-defined. If the user has not selected such anoption, a call of the function must either return a deterministicresult or must raise a dynamic error [err:FODC0003]. Note: If $uri is read from a source document, it isgenerally appropriate to resolve it relative to the base URIproperty of the relevant node in the source document. This can beachieved by calling the fn:resolve-uri function, andpassing the resulting absolute URI as an argument to thefn:doc function. If two calls to this function supply different absolute URIReferences as arguments, the same document node may be returned ifthe implementation can determine that the two arguments refer tothe same resource. By defining the semantics of this function in terms of astring-to-document-node mapping in the dynamic context, thespecification is acknowledging that the results of this functionare outside the purview of the language specification itself, anddepend entirely on the run-time environment in which the expressionis evaluated. This run-time environment includes not only anunpredictable collection of resources ("the web"), but configurablemachinery for locating resources and turning their contents intodocument nodes within the XPath data model. Both the set ofresources that are reachable, and the mechanisms by which thoseresources are parsed and validated, are Â·implementation dependentÂ·. One possible processing model for this function is as follows.The resource identified by the URI Reference is retrieved. If theresource cannot be retrieved, a dynamic error israised [err:FODC0002]. The data resulting from theretrieval action is then parsed as an XML document and a tree isconstructed in accordance with the [XQuery and XPath Data Model (XDM) 3.0].If the top-level media type is known and is "text", the content isparsed in the same way as if the media type were text/xml;otherwise, it is parsed in the same way as if the media type wereapplication/xml. If the contents cannot be parsed successfully, adynamic error is raised [err:FODC0002]. Otherwise, the result of thefunction is the document node at the root of the resulting tree.This tree is then optionally validated against a schema. Various aspects of this processing are Â·implementation-definedÂ·. Implementations may provide externalconfiguration options that allow any aspect of the processing to becontrolled by the user. In particular: The set of URI schemes that the implementation recognizes isimplementation-defined. Implementations may allow the mapping ofURIs to resources to be configured by the user, using mechanismssuch as catalogs or user-written URI handlers. The handling of non-XML media types is implementation-defined.Implementations may allow instances of the data model to beconstructed from non-XML resources, under user control. It is Â·implementation-definedÂ· whether DTD validation and/or schemavalidation is applied to the source document. Implementations may provide user-defined error handling optionsthat allow processing to continue following an error in retrievinga resource, or in parsing and validating its content. When errorshave been handled in this way, the function may return either anempty sequence, or a fallback document provided by the errorhandler. Implementations may provide user options that relax therequirement for the function to return deterministic results. Error Conditions A dynamic error may be raised[err:FODC0005] if$uri is not a valid URI. A dynamic error is raised [err:FODC0002] if the availabledocuments provides no mapping for the absolutized URI. A dynamic error is raised [err:FODC0002] if the resource cannot beretrieved or cannot be parsed successfully as XML. A dynamic error is raised [err:FODC0003] if the implementation is notable to guarantee that the result of the function will bedeterministic, and the user has not indicated that an unstableresult is acceptable. 14.8.2fn:doc-available Summary The function returns true if and only if the function callfn:doc($uri) would return adocument node. Signature fn:doc-available($uri as xs:string?) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on available documents, and static base uri. Rules If $uri is an empty sequence, this function returnsfalse. If a call on fn:doc($uri)would return a document node, this function returnstrue. A dynamic error is raised [err:FODC0005] if $uri is nota valid URI according to the rules applied by the implementation offn:doc. Otherwise, this function returns false. If this function returns true, then callingfn:doc($uri) within the sameÂ·executionscopeÂ· must return a document node.However, if nondeterministic processing has been selected for thefn:doc function, thisguarantee is lost. 14.8.3fn:collection Summary Returns a sequence of nodes representing a collection ofdocuments indentified by a collection URI; or a default collectionif no URI is supplied. Signatures fn:collection() as node()* fn:collection($arg as xs:string?) as node()* Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on available node collections, and static base uri. Rules This function takes an xs:string as argument andreturns a sequence of nodes obtained by interpreting$arg as an xs:anyURI and resolving itaccording to the mapping specified in Available nodecollections described in Section C.2 Dynamic Context ComponentsXP30. If Available node collections provides a mapping fromthis string to a sequence of nodes, the function returns thatsequence. If Available node collections maps the string toan empty sequence, then the function returns an empty sequence. If $arg is not specified, the function returns thesequence of the nodes in the default node collection in the dynamiccontext. See Section C.2 Dynamic Context ComponentsXP30. If the value of $arg is a relativexs:anyURI, it is resolved against the value of thebase-URI property from the static context. If $arg is the empty sequence, the function behavesas if it had been called without an argument. See above. By default, this function is Â·deterministicÂ·. This means that repeated calls on thefunction with the same argument will return the same result.However, for performance reasons, implementations may provide auser option to evaluate the function without a guarantee ofdeterminism. The manner in which any such option is provided isÂ·implementation-definedÂ·. If the user has not selected such an option,a call to this function must either return a deterministic resultor must raise a dynamic error [err:FODC0003]. There is no requirement that the returned nodes should be indocument order, nor is there a requirement that the result shouldcontain no duplicates. Error Conditions A dynamic error is raised [err:FODC0002] if no URI is supplied andthe value of the default collection is absentDM30. A dynamic error is raised [err:FODC0002] if available nodecollections provides no mapping for the absolutized URI. A dynamic error is raised [err:FODC0004] if $arg is nota valid xs:anyURI. Notes This function provides a facility for users to work with acollection of documents which may be contained in a directory, orin the rows of a relational table, or in some otherimplementation-specific construct. An implementation may also useexternal variables to identify external resources, butfn:collection provides functionality not provided byexternal variables. Specifying resources using URIs is usefulbecause URIs are dynamic, can be parameterized, and do not rely onan external environment. 14.8.4 fn:uri-collection Summary Returns a sequence of xs:anyURI values representingthe URIs in a resource collection. Signatures fn:uri-collection() as xs:anyURI* fn:uri-collection($arg as xs:string?) as xs:anyURI* Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on available resource collections, and static baseuri. Rules The zero-argument form of the function returns the URIs in theDefault resource collection described in Section C.2 Dynamic Context ComponentsXP30. If the value of $arg is a relativexs:anyURI, it is resolved against the value of thebase-URI property from the static context. If $arg is the empty sequence, the function behavesas if it had been called without an argument. See above. The single-argument form of the function returns the sequence ofURIs corresponding to the supplied URI in the Available resourcecollections described in Section C.2 Dynamic Context ComponentsXP30. Error Conditions A dynamic error is raised [err:FODC0002] if no URI is supplied (thatis, if the the function is called with no arguments, or with asingle argument that evaluates to an empty sequence), and the valueof the default resource collection is absentDM30. A dynamic error is raised [err:FODC0002] if available resourcecollections provides no mapping for the absolutized URI. A dynamic error is raised [err:FODC0004] if $arg is nota valid xs:anyURI. Notes There are several reasons why it might be appropriate to usethis function in preference to the fn:collection function: It allows resources to be retrieved that are not well-formed XMLdocuments: for example, the returned URIs might be referenced usingthe fn:unparsed-textfunction rather than the fn:doc function. In XSLT 3.0 it allows the documents to be processed in streamingmode using the xsl:stream instruction. It allows recovery from failures to read, parse, or validateindividual documents, by calling the fn:doc function within the scope oftry/catch. It allows selection of which documents to read based on theirURI, for example they can be filtered to select those whose URIsend in .xml, or those that use the httpsscheme. An application might choose to limit the number of URIsprocessed in a single run, for example it might process only thefirst 50 URIs in the collection; or it might present the URIs tothe user and allow the user to select which of them need to befurther processed. It allows the URIs to be modified before they are dereferenced,for example by adding or removing query parameters, or byredirecting the request to a local cache or to a mirror site. For some of these use cases, this assumes that the cost ofcalling fn:collectionmight be significant (for example, it might involving retrievingall the documents in the collection over the network and parsingthem). This will not necessarily be true of allimplementations. Some implementations might ensure that callingfn:uri-collection and then applying fn:doc to each of the returned URIsdelivers the same result as calling fn:collection with the sameargument; however, this is not guaranteed. There is no requirement that the URIs returned by this functionshould all be distinct, and no assumptions can be made about theorder of URIs in the sequence, unless the implementation definesotherwise. 14.8.5fn:unparsed-text Summary The fn:unparsed-text function reads an externalresource (for example, a file) and returns a stringrepresentation of the resource. Signatures fn:unparsed-text($href as xs:string?) as xs:string? fn:unparsed-text($href as xs:string?,$encoding as xs:string) as xs:string? Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on static base uri. Rules The $href argument must be astring in the form of a URI reference, which mustcontain no fragment identifier, and must identifya resource for which a string representation isavailable. If the URI is a relative URI reference, then itis resolved relative to the Static Base URI property from thestatic context. The mapping of URIs to the string representation of a resourceis the mapping defined in the availabletext resourcesXP30 component of thedynamic context. If the value of the $href argument is an emptysequence, the function returns an empty sequence. The $encoding argument, if present, is the name ofan encoding. The values for this attribute follow the same rules asfor the encoding attribute in an XML declaration. Theonly values which every Â·implementationÂ· is required to recognize areutf-8 and utf-16. The encoding of the external resource is determined asfollows: external encoding information is used if available,otherwise if the media type of the resource is text/xml orapplication/xml (see [RFC2376]), or if it matches the conventionstext/*+xml or application/*+xml (see[RFC 3023] and/or its successors), then theencoding is recognized as specified in [ExtensibleMarkup Language (XML) 1.0 (Fifth Edition)], otherwise the value of the $encoding argument is used ifpresent, otherwise the processor may use Â·implementation-definedÂ· heuristics to determine the likely encoding,otherwise UTF-8 is assumed. The result of the function is a string containing thestring representation of the resource retrieved usingthe URI. Error Conditions A dynamic error is raised [err:FOUT1170] if $hrefcontains a fragment identifier, or if it cannot be used to retrievethe string representation of a resource. A dynamic error is raised [err:FOUT1190] if the value of the$encoding argument is not a valid encodingname, if the Â·processorÂ· does not support the specified encoding, ifthe string representation of the retrieved resourcecontains octets that cannot be decoded into Unicode Â·charactersÂ· usingthe specified encoding, or if the resulting characters are notpermitted XML characters. A dynamic error is raised [err:FOUT1200] if $encoding isabsent and the Â·processorÂ· cannotinfer the encoding using external information and the encoding isnot UTF-8. Notes If it is appropriate to use a base URI other than thedynamic base URI (for example, when resolving arelative URI reference read from a source document) then it isadvisable to resolve the relative URI reference using the fn:resolve-uri function beforepassing it to the fn:unparsed-text function. There is no essential relationship between the sets of URIsaccepted by the two functions fn:unparsed-text andfn:doc (a URI accepted by onemay or may not be accepted by the other), and if a URI is acceptedby both there is no essential relationship between the results(different resource representations are permitted by thearchitecture of the web). There are no constraints on the MIME type of the resource. The fact that the resolution of URIs is defined by a mapping inthe dynamic context means that in effect, various aspects of thebehavior of this function are Â·implementation-definedÂ·. Implementations may provide externalconfiguration options that allow any aspect of the processing to becontrolled by the user. In particular: The set of URI schemes that the implementation recognizes isimplementation-defined. Implementations may allow the mapping ofURIs to resources to be configured by the user, using mechanismssuch as catalogs or user-written URI handlers. The handling of media types is implementation-defined. Implementations may provide user-defined error handling optionsthat allow processing to continue following an error in retrievinga resource, or in reading its content. When errors have beenhandled in this way, the function may return a fallback documentprovided by the error handler. Implementations may provide user options that relax therequirement for the function to return deterministic results. The rules for determining the encoding are chosen forconsistency with [XML Inclusions (XInclude)Version 1.0 (Second Edition)]. Files with an XML media type aretreated specially because there are use cases for this functionwhere the retrieved text is to be included as unparsed XML within aCDATA section of a containing document, and because processors arelikely to be able to reuse the code that performs encodingdetection for XML external entities. If the text file contains characters such as <and &, these will typically be output as&lt; and &amp; if the string isserialized as XML or HTML. If these characters actually representmarkup (for example, if the text file contains HTML), then an XSLTstylesheet can attempt to write them as markup to the output fileusing the disable-output-escaping attribute of thexsl:value-of instruction. Note, however, that XSLTimplementations are not required to support this feature. Examples This XSLT example attempts to read a file containing'boilerplate' HTML and copy it directly to the serialized outputfile: <xsl:output method="html"/><xsl:template match="/">  <xsl:value-of select="unparsed-text('header.html', 'iso-8859-1')"                disable-output-escaping="yes"/>  <xsl:apply-templates/>  <xsl:value-of select="unparsed-text('footer.html', 'iso-8859-1')"                disable-output-escaping="yes"/></xsl:template> 14.8.6 fn:unparsed-text-lines Summary The fn:unparsed-text-lines function reads anexternal resource (for example, a file) and returns its contents asa sequence of strings, one for each line of text in thestring representation of the resource. Signatures fn:unparsed-text-lines($href as xs:string?) as xs:string* fn:unparsed-text-lines( $href as xs:string?, $encoding as xs:string) as xs:string* Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on static base uri. Rules The unparsed-text-lines function reads an externalresource (for example, a file) and returns its stringrepresentation as a sequence of strings, separated atnewline boundaries. The result of the single-argument function is the same as theresult of the expression fn:tokenize(fn:unparsed-text($href),'\r\n|\r|\n')[not(position()=last() and .='')]. Theresult of the two-argument function is the same as the result ofthe expression fn:tokenize(fn:unparsed-text($href,$encoding), '\r\n|\r|\n')[not(position()=last() and.='')]. The result is thus a sequence of strings containing the text ofthe resource retrieved using the URI, each string representing oneline of text. Lines are separated by one of the sequences x0A, x0D,or x0Dx0A. The characters representing the newline are not includedin the returned strings. If there are two adjacent newlinesequences, a zero-length string will be returned to represent theempty line; but if the external resource ends with thesequence x0A, x0D, or x0Dx0A, the result will be as if this finalline ending were not present. Error Conditions Error conditions are the same as for the fn:unparsed-textfunction. Notes See the notes for fn:unparsed-text. 14.8.7fn:unparsed-text-available Summary Because errors in evaluating the fn:unparsed-textfunction are non-recoverable, these two functions are provided toallow an application to determine whether a call with particulararguments would succeed. Signatures fn:unparsed-text-available($href as xs:string?) as xs:boolean fn:unparsed-text-available( $href as xs:string?, $encoding as xs:string) as xs:boolean Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on static base uri. Rules The fn:unparsed-text-available function determineswhether a call on the fn:unparsed-text function withidentical arguments would return a string. If the first argument is an empty sequence, the function returnsfalse. In other cases, the function returns true if a call onfn:unparsed-text with the same arguments wouldsucceed, and false if a call on fn:unparsed-text withthe same arguments would fail with a non-recoverable dynamicerror. The functions fn:unparsed-text andfn:unparsed-text-available have the same requirementfor Â·determinismÂ· as thefunctions fn:doc and fn:doc-available. This meansthat unless the user has explicitly stated a requirement for areduced level of determinism, either of these functions if calledtwice with the same arguments during the course of a transformationmust return the same results each time; moreover,the results of a call on fn:unparsed-text-availablemust be consistent with the results of asubsequent call on unparsed-text with the samearguments. Notes This requires that the unparsed-text-availablefunction should actually attempt to read the resource identified bythe URI, and check that it is correctly encoded and contains nocharacters that are invalid in XML. Implementations may avoid thecost of repeating these checks for example by caching the validatedcontents of the resource, to anticipate a subsequent call on theunparsed-text orunparsed-text-lines function. Alternatively,implementations may be able to rewrite an expression such asif (unparsed-text-available(A)) then unparsed-text(A) else... to generate a single call internally. Since the function unparsed-text-lines succeeds orfails under exactly the same circumstances asunparsed-text, the unparsed-text-availablfunction may equally be used to test whether a call onunparsed-text-lines would succeed. 14.8.8 fn:environment-variable Summary Returns the value of a system environment variable, if itexists. Signature fn:environment-variable($name as xs:string) as xs:string? Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on environment variables. Rules The set of available environmentvariablesXP30 is a set of (name,value) pairs forming part of the dynamic context, in which the nameis unique within the set of pairs. The name and value are arbitrarystrings. If the $name argument matches the name of one ofthese pairs, the function returns the corresponding value. If there is no environment variable with a matching name, thefunction returns the empty sequence. The collation used for matching names is Â·implementation-definedÂ·, but must be the same as the collation used toensure that the names of all environment variables are unique. The function is Â·deterministicÂ·,which means that if it is called several times within the sameÂ·execution scopeÂ·,with the same arguments, it must return the same result. Notes On many platforms, the term "environment variable" has a naturalmeaning in terms of facilities provided by the operating system.This interpretation of the concept does not exclude otherinterpretations, such as a mapping to a set of configurationparameters in a database system. Environment variable names are usually case sensitive. Names areusually of the form (letter|_) (letter|_|digit)*, butthis varies by platform. On some platforms, there may sometimes be multiple environmentvariables with the same name; in this case, it isimplementation-dependent as to which is returned; see for example[POSIX.1-2008] (Chapter 8, EnvironmentVariables). Implementations may use prefixes orother naming conventions to disambiguate the names. The requirement to ensure that the function is deterministicmeans in practice that the implementation must make a snapshot ofthe environment variables at some time during execution, and returnvalues obtained from this snapshot, rather than using live valuesthat are subject to change at any time. Operating system environment variables may be associated with aparticular process, while queries and stylesheets may executeacross multiple processes (or multiple machines). In suchcircumstances implementations may choose toprovide access to the environment variables associated with theprocess in which the query or stylesheet processing wasinitiated. Security advice: Queries from untrusted sources should not bepermitted unrestricted access to environment variables. Forexample, the name of the account under which the query is runningmay be useful information to a would-be intruder. An implementationmay therefore choose to restrict access to the environment, or mayprovide a facility to make fn:environment-variablealways return the empty sequence. 14.8.9fn:available-environment-variables Summary Returns a list of environment variable names that are suitablefor passing to fn:environment-variable,as a (possibly empty) sequence of strings. Signature fn:available-environment-variables() as xs:string* Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on environment variables. Rules The function returns a sequence of strings, being the names ofthe environment variables in the dynamic context in some Â·implementation-dependentÂ· order. The function is Â·deterministicÂ·: thatis, the set of available environment variables does not vary duringevaluation. Notes The function returns a list of strings, containing noduplicates. It is intended that the strings in this list should be suitablefor passing to fn:environment-variable. See also the note on security under the definition of thefn:environment-variablefunction. If access to environment variables has been disabled,fn:available-environment-variables always returns theempty sequence. 14.9 Parsing and serializing 14.9.1fn:parse-xml Summary This function takes as input an XML document represented as astring, and returns the document node at the root of an XDM treerepresenting the parsed document. Signature fn:parse-xml($arg as xs:string?) as document-node(element(*))? Properties This function is Â·nondeterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on static base uri. Rules If $arg is the empty sequence, the function returnsthe empty sequence. The precise process used to construct the XDM instance isÂ·implementation-definedÂ·. In particular, it is implementation-definedwhether DTD and/or schema validation is invoked, and it isimplementation-defined whether an XML 1.0 or XML 1.1 parser isused. The Static Base URI property from the static context of thefn:parse-xml function call is used both as the baseURI used by the XML parser to resolve relative entity referenceswithin the document, and as the base URI of the document node thatis returned. The document URI of the returned node is Â·absentÂ·. The function is not Â·deterministicÂ·: that is, if the function is called twice withthe same arguments, it is Â·implementation-dependentÂ· whether the same node is returned on bothoccasions. Error Conditions A dynamic error is raised [err:FODC0006] if the content of$arg is not a well-formed and namespace-well-formedXML document. A dynamic error is raised [err:FODC0006] if DTD-based validation iscarried out and the content of $arg is not validagainst its DTD. Notes Since the XML document is presented to the parser as a string,rather than as a sequence of octets, the encoding specified withinthe XML declaration has no meaning. If the XML parser accepts inputonly in the form of a sequence of octets, then the processor mustensure that the string is encoded as octets in a way that isconsistent with rules used by the XML parser to detect theencoding. The primary use case for this function is to handle inputdocuments that contain nested XML documents embedded within CDATAsections. Since the content of the CDATA section are exposed astext, the receiving query or stylesheet may pass this text to thefn:parse-xml function to create a tree representationof the nested document. Similarly, nested XML within comments is sometimes encountered,and lexical XML is sometimes returned by extension functions, forexample, functions that access web services or read fromdatabases. A use case arises in XSLT where there is a need to preprocess aninput document before parsing. For example, an application mightwish to edit the document to remove its DOCTYPE declaration. Thiscan be done by reading the raw text using the fn:unparsed-text function,editing the resulting string, and then passing it to thefn:parse-xml function. Examples The expressionfn:parse-xml("<alpha>abcd</alpha>")returns a newly created document node, having an alphaelement as its only child; the alpha element in turnis the parent of a text node whose string value is"abcd". 14.9.2 fn:parse-xml-fragment Summary This function takes as input an XML external entity representedas a string, and returns the document node at the root of an XDMtree representing the parsed document fragment. Signature fn:parse-xml-fragment($arg as xs:string?) as document-node()? Properties This function is Â·nondeterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on static base uri. Rules If $arg is the empty sequence, the function returnsthe empty sequence. The input must be a namespace-well-formed external generalparsed entity. More specifically, it must be a string conforming tothe production rule extParsedEntxmlin [Extensible Markup Language (XML) 1.0 (FifthEdition)], it must contain no entity references other thanreferences to predefined entities, and it must satisfy all therules of [Namespaces in XML] fornamespace-well-formed documents with the exception that the rulerequiring it to be a well-formed document is replaced by the rulerequiring it to be a well-formed external general parsedentity. The string is parsed to form a sequence of nodes which becomechildren of the new document node, in the same way as the contentof any element is converted into a sequence of children for theresulting element node. Schema validation is not invoked, which means that thenodes in the returned document will all be untyped. The precise process used to construct the XDM instance isÂ·implementation-definedÂ·. In particular, it is implementation-definedwhether an XML 1.0 or XML 1.1 parser is used. The Static Base URI from the static context of thefn:parse-xml-fragment function call is used as thebase URI of the document node that is returned. The document URI of the returned node is Â·absentÂ·. The function is not Â·deterministicÂ·: that is, if the function is called twice withthe same arguments, it is Â·implementation-dependentÂ· whether the same node is returned on bothoccasions. Error Conditions A dynamic error is raised [err:FODC0006] if the content of$arg is not a well-formed external general parsedentity, if it contains entity references other than references topredefined entities, or if a document that incorporates thiswell-formed parsed entity would not be namespace-well-formed. Notes See also the notes for the fn:parse-xml function. The main differences between fn:parse-xml andfn:parse-xml-fragment are that for fn:parse-xml, the children ofthe resulting document node must contain exactly one element nodeand no text nodes, wheras for fn:parse-xml-fragment,the resulting document node can have any number (including zero) ofelement and text nodes among its children. An additional differenceis that the text declaration at the start of an externalentity has slightly different syntax from the XMLdeclaration at the start of a well-formed document. Note that all whitespace outside the text declarationis significant, including whitespace that precedes the firstelement node. One use case for this function is to handle XML fragments storedin databases, which frequently allow zero-or-more top level elementnodes. Another use case is to parse the contents of aCDATA section embedded within another XMLdocument. Examples The expressionfn:parse-xml-fragment("<alpha>abcd</alpha><beta>abcd</beta>")returns a newly created document node, having two elements namedalpha and beta as its children; each ofthese elements in turn is the parent of a text node. The expression fn:parse-xml-fragment("He was<i>so</i> kind") returns a newly createddocument node having three children: a text node whose string valueis "He was ", an element node named ihaving a child text node with string value "so", and atext node whose string value is " kind". The expression fn:parse-xml-fragment("") returns adocument node having no children. The expression fn:parse-xml-fragment(" ") returns adocument node whose children comprise a single text node whosestring value is a single space. The expression fn:parse-xml-fragment('<xmlversion="1.0" encoding="utf8"standalone="yes"?></a>") results in adynamic error [err:FODC0006] because the "standalone" keywordis not permitted in the text declaration that appears at the startof an external general parsed entity. (Thus, it is not the casethat any input accepted by the fn:parse-xml function will alsobe accepted by fn:parse-xml-fragment.) 14.9.3fn:serialize Summary This function serializes the supplied inputsequence $arg as described in [XSLT and XQuery Serialization3.0], returning the serialized representation of thesequence as a string. Signatures fn:serialize($arg as item()*) as xs:string fn:serialize( $arg as item()*, $params as element(output:serialization-parameters)?) as xs:string Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The value of $arg acts as the input sequence to theserialization process, which starts with sequencenormalization. The single-argument version of this function has the same effectas the two-argument version called with $params set toan empty sequence. This in turn is the same as the effect ofpassing an output:serialization-parameters elementwith no child elements. The $params argument is used to identify a set ofserialization parameters. These are supplied in the form of anoutput:serialization-parameters element, having theformat described in Section 3.1 Setting Serialization Parameters by Means of a DataModel Instance SER30. The final stage of serialization, that is, encoding, is skipped.If the serializer does not allow this phase to be skipped, then thesequence of octets returned by the serializer is decoded into astring by reversing the character encoding performed in the finalstage. Error Conditions If the host language makes serialization an optional feature andthe implementation does not support serialization, then a dynamicerror [err:FODC0010] is raised. The serialization process will raise an error if$arg is an attribute or namespace node. If any serialization error occurs, including the detection of aninvalid value for a serialization parameter, this results in thefn:serialize call failing with a dynamic error. Notes One use case for this function arises when there is a need toconstruct an XML document containing nested XML documents within aCDATA section (or on occasions within a comment). See fn:parse-xml for furtherdetails. Another use case arises when there is a need to call anextension function that expects a lexical XML document asinput. There are also use cases where the application wants topost-process the output of a query or transformation, for exampleby adding an internal DTD subset, or by inserting proprietarymarkup delimiters such as the <% ... %> used bysome templating languages. Examples Given the output parameters: let $params := <output:serialization-parameters xmlns:output="http://www.w3.org/2010/xslt-xquery-serialization">  <output:omit-xml-declaration value="yes"/></output:serialization-parameters>         let $data := <a b='3'/>         The following call might produce the output shown: The expression fn:serialize($data, $params) returns'<a b="3"/>'. 15 Context functions The following functions are defined to obtain information fromthe static or dynamic context. Function Meaning fn:position Returns the context position from the dynamic context. fn:last Returns the context size from the dynamic context. fn:current-dateTime Returns the current date and time (with timezone). fn:current-date Returns the current date. fn:current-time Returns the current time. fn:implicit-timezone Returns the value of the implicit timezone property from thedynamic context. fn:default-collation Returns the value of the default collation property from thestatic context. fn:static-base-uri This function returns the value of the Static Base URI propertyfrom the static context. 15.1fn:position Summary Returns the context position from the dynamic context. Signature fn:position() as xs:integer Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. Rules Returns the context position from the dynamic context. (SeeSection C.2 Dynamic Context ComponentsXP30.) Error Conditions A dynamic error is raised [err:XPDY0002]XP30 ifthe context item is absentDM30. 15.2 fn:last Summary Returns the context size from the dynamic context. Signature fn:last() as xs:integer Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. Rules Returns the context size from the dynamic context. (See Section C.2 Dynamic Context ComponentsXP30.) Error Conditions A dynamic error is raised [err:XPDY0002]XP30 ifthe context item is absentDM30. Examples The expression (1 to 20)[fn:last() - 1] returns19. 15.3 fn:current-dateTime Summary Returns the current date and time (with timezone). Signature fn:current-dateTime() as xs:dateTimeStamp Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules Returns the current dateTime (with timezone) from the dynamiccontext. (See Section C.2 Dynamic Context ComponentsXP30.) This is anxs:dateTime that is current at some time during theevaluation of a query or transformation in whichfn:current-dateTime is executed. This function is Â·deterministicÂ·. Theprecise instant during the query or transformation represented bythe value of fn:current-dateTime() is Â·implementation dependentÂ·. If the implementation supports data types from XSD 1.1 then thereturned value will be an instance ofxs:dateTimeStamp. Otherwise, the only guarantees arethat it will be an instance of xs:dateTime and willhave a timezone component. Notes The returned xs:dateTime will always have anassociated timezone, which will always be the same as the implicittimezone in the dynamic context Examples fn:current-dateTime() returns anxs:dateTimeStamp corresponding to the current date andtime. For example, a call of fn:current-dateTime()might return 2004-05-12T18:17:15.125Z corresponding tothe current time on May 12, 2004 in timezone Z. 15.4fn:current-date Summary Returns the current date. Signature fn:current-date() as xs:date Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules Returns xs:date(fn:current-dateTime()). This is anxs:date (with timezone) that is current at some timeduring the evaluation of a query or transformation in whichfn:current-date is executed. This function is Â·deterministicÂ·. Theprecise instant during the query or transformation represented bythe value of fn:current-date is Â·implementation dependentÂ·. Notes The returned date will always have an associated timezone, whichwill always be the same as the implicit timezone in the dynamiccontext Examples fn:current-date() returns an xs:datecorresponding to the current date. For example, a call offn:current-date() might return2004-05-12+01:00. 15.5fn:current-time Summary Returns the current time. Signature fn:current-time() as xs:time Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules Returns xs:time(fn:current-dateTime()). This is anxs:time (with timezone) that is current at some timeduring the evaluation of a query or transformation in whichfn:current-time is executed. This function is Â·deterministicÂ·. Theprecise instant during the query or transformation represented bythe value of fn:current-time() is Â·implementation dependentÂ·. Notes The returned time will always have an associated timezone, whichwill always be the same as the implicit timezone in the dynamiccontext Examples fn:current-time() returns an xs:timecorresponding to the current time. For example, a call offn:current-time() might return23:17:00.000-05:00. 15.6 fn:implicit-timezone Summary Returns the value of the implicit timezone property from thedynamic context. Signature fn:implicit-timezone() as xs:dayTimeDuration Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on implicit timezone. Rules Returns the value of the implicit timezone property from thedynamic context. Components of the dynamic context are discussed inSection C.2 Dynamic Context ComponentsXP30. 15.7 fn:default-collation Summary Returns the value of the default collation property from thestatic context. Signature fn:default-collation() as xs:string Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on collations. Rules Returns the value of the default collation property from thestatic context. Components of the static context are discussed inSectionC.1 Static Context ComponentsXP30. Notes The default collation property can never be absent. If it is notexplicitly defined, a system defined default can be invoked. Ifthis is not provided, the Unicode codepoint collation(http://www.w3.org/2005/xpath-functions/collation/codepoint)is used. 15.8 fn:static-base-uri Summary This function returns the value of the Static Base URI propertyfrom the static context. Signature fn:static-base-uri() as xs:anyURI? Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-independentÂ·.It depends on static base uri. Rules The function returns the value of the Static Base URI propertyfrom the static context. If the property is absent, the emptysequence is returned. Components of the static context are discussed in Section 2.1.1Static Context XP30 . Notes XQuery 3.0 and XSLT 3.0 give an implementation freedom to usedifferent base URIs during the static analysis phase and thedynamic evaluation phase, that is, for compile-time and run-timeresources respectively. In this situation, thefn:static-base-uri function should return a URIsuitable for locating resources needed during dynamicevaluation. 16 Higher-order functions 16.1 Functions on functions The following functions operate on function items, that is,values referring to a function. Function Meaning fn:function-lookup Returns the function having a given name and arity, if there isone. fn:function-name Returns the name of the function identified by a functionitem. fn:function-arity Returns the arity of the function identified by a functionitem. 16.1.1 fn:function-lookup Summary Returns the function having a given name and arity, if there isone. Signature fn:function-lookup($name as xs:QName,$arity as xs:integer) as function(*)? Properties This function is Â·deterministicÂ·,Â·context-dependentÂ·,and Â·focus-dependentÂ·. Rules A call to fn:function-lookup returns the functionobtained by looking up the expanded QName supplied as$name and the arity supplied as $arity inthe named functions component of the dynamic context (specifically,the dynamic context of the call tofn:function-lookup). Furthermore, if that function has an implementation-dependentimplementation (see note below), then the implementation of thefunction returned by fn:function-lookup is associatedwith the static and dynamic context of the call tofn:function-lookup. Note: The above rule deliberately uses the same wording as thecorresponding rule for Named Function References. The term "afunction [with] an implementation-dependent implementation"essentially means a function whose implementation is provided bythe language processor rather than by the stylesheet or queryauthor. This rule is therefore relevant to built-in functions andvendor-supplied extension functions whose result depends on thecontext of the function call. Otherwise (if no known function can be identified by name andarity), an empty sequence is returned. If the arguments to fn:function-lookup identify afunction that is present in the static context of the functioncall, the function will always return the same function that astatic reference to this function would bind to. If there is nosuch function in the static context, then the results depend onwhat is present in the dynamic context, which is Â·implementation-definedÂ·. Notes This function can be useful where there is a need to make adynamic decision on which of several statically-known functions tocall. It can thus be used as a substitute for polymorphism, in thecase where the application has been designed so several functionsimplement the same interface. The function can also be useful in cases where a query orstylesheet module is written to work with alternative versions of alibrary module. In such cases the author of the main module mightwish to test whether an imported library module contains or doesnot contain a particular function, and to call a function in thatmodule only if it is available in the version that was imported. Astatic call would cause a static error if the function is notavailable, whereas getting the function usingfn:function-lookup allows the caller to take fallbackaction in this situation. If the function that is retrieved byfn:function-lookup is Â·context-dependentÂ·,that is, if it has dependencies on the static or dynamic context ofits caller, the context that applies is the static and/or dynamiccontext of the call to the fn:function-lookup functionitself. The context thus effectively forms part of the closure ofthe returned function. In practice this applies only where thetarget of fn:function-lookup is a built-in function,because user-defined functions never depend on the static ordynamic context of the function call. The rule applies recursively,since fn:function-lookup is itself a context-dependentbuilt-in function. These specifications do not define any circumstances in whichthe dynamic context will contain functions that are not present inthe static context, but neither do they rule this out. For examplean API may provide the ability to add functions tothe dynamic context. Equally, these specifications do not defineany mechanism for creating context-dependent functions other thanthe built-in context-depedendent functions, but neither do theyrule out the existence of such functions. Examples The expressionfn:function-lookup(xs:QName('fn:substring'), 2)('abcd',2) returns 'bcd'. The expression(fn:function-lookup(xs:QName('xs:dateTimeStamp'), 1),xs:dateTime#1)[1] ('2011-11-11T11:11:11Z') returns anxs:dateTime value set to the specified date, time, andtimezone; if the implementation supports XSD 1.1 then the resultwill be an instance of the derived typexs:dateTimeStamp. The query is written to ensure thatno failure occurs when the implementation does not recognize thetype xs:dateTimeStamp. The expression (let $f :=fn:function-lookup(xs:QName('zip:binary-entry', 2) return if(exists($f)) then $f($href, $entry) else () returns theresult of calling zip:binary-entry($href, $entry) ifthe function is available, or an empty sequence otherwise. 16.1.2fn:function-name Summary Returns the name of the function identified by a functionitem. Signature fn:function-name($func as function(*)) as xs:QName? Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules If $func refers to a named function,fn:function-name($func) returns the name of thatfunction. Otherwise ($func refers to an anonymous function),fn:function-name($func) returns an empty sequence. The prefix part of the returned QName is Â·implementation dependentÂ·. Examples The expression fn:function-name(fn:substring#2)returns fn:QName("http://www.w3.org/2005/xpath-functions","fn:substring"). (The namespace prefix of thereturned QName is not predictable.). The expressionfn:function-name(function($node){count($node/*)})returns (). 16.1.3 fn:function-arity Summary Returns the arity of the function identified by a functionitem. Signature fn:function-arity($func as function(*)) as xs:integer Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The fn:function-arity function returns the arity(number of arguments) of the function identified by$func. Examples The expression fn:function-arity(fn:substring#2)returns 2. The expressionfn:function-arity(function($node){name($node)})returns 1. The expression let $initial := fn:substring(?, 1, 1)return fn:function-arity($initial) returns1. 16.2 Basichigher-order functions The following functions take function items as an argument. Function Meaning fn:for-each Applies the function item $f to every item from thesequence $seq in turn, returning the concatenation ofthe resulting sequences in order. fn:filter Returns those items from the sequence $seq for whichthe supplied function $f returns true. fn:fold-left Processes the supplied sequence from left to right, applyingthe supplied function repeatedly to each item in turn, togetherwith an accumulated result value. fn:fold-right Processes the supplied sequence from right to left, applyingthe supplied function repeatedly to each item in turn, togetherwith an accumulated result value. fn:for-each-pair Applies the function item $f to successive pairs ofitems taken one from $seq1 and one from$seq2, returning the concatenation of the resultingsequences in order. 16.2.1fn:for-each Summary Applies the function item $f to every item from thesequence $seq in turn, returning the concatenation ofthe resulting sequences in order. Signature fn:for-each($seq as item()*, $f as function(item()) asitem()*) as item()* Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The effect of the function is equivalent to the followingimplementation in XQuery: declare function fn:for-each($seq, $f) {  if (fn:empty($seq))  then ()  else ($f(fn:head($seq)), fn:for-each(fn:tail($seq), $f))}; or its equivalent in XSLT: <xsl:function name="fn:for-each">  <xsl:param name="seq"/>  <xsl:param name="f"/>  <xsl:if test="fn:exists($seq)">    <xsl:sequence select="$f(fn:head($seq)), fn:for-each(fn:tail($seq), $f)"/>  </xsl:if></xsl:function>         Notes The function call fn:for-each($SEQ, $F) isequivalent to the expression for $i in $SEQ return$F($i), assuming that ordering mode isordered. Examples The expression fn:for-each(1 to 5, function($a) { $a * $a}) returns (1, 4, 9, 16, 25). The expression fn:for-each(("john", "jane"),fn:string-to-codepoints#1) returns (106, 111, 104,110, 106, 97, 110, 101). The expression fn:for-each(("23", "29"), xs:int#1)returns (23, 29). 16.2.2fn:filter Summary Returns those items from the sequence $seq for whichthe supplied function $f returns true. Signature fn:filter($seq as item()*, $f as function(item()) asxs:boolean) as item()* Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The effect of the function is equivalent to the followingimplementation in XQuery: declare function fn:filter(        $seq as item()*,        $f as function(item()) as xs:boolean)        as item()* {  if (fn:empty($seq))  then ()  else ( fn:head($seq)[$f(.) eq fn:true()],          fn:filter(fn:tail($seq), $f)       )}; or its equivalent in XSLT: <xsl:function name="fn:filter" as="item()*">  <xsl:param name="seq" as="item()*"/>  <xsl:param name="f" as="function(item()) as xs:boolean"/>  <xsl:if test="fn:exists($seq)">    <xsl:sequence select="fn:head($seq)[$f(.) eq fn:true()], fn:filter(fn:tail($seq), $f)"/>  </xsl:if></xsl:function>         Error Conditions As a consequence of the function signature and the functioncalling rules, a type error occurs if the supplied function$f returns anything other than a singlexs:boolean item; there is no conversion to aneffective boolean value. Notes The function call fn:filter($SEQ, $F) has a verysimilar effect to the expression $SEQ[$F(.)]. Thereare some differences, however. In the case offn:filter, the function $F is required toreturn a boolean; there is no special treatment for numericpredicate values, and no conversion to an effective boolean value.Also, with a filter expression $SEQ[$F(.)], the focuswithin the predicate is different from that outside; this meansthat the use of a context-sensitive function such as fn:lang#1 will give different resultsin the two cases. Examples The expression fn:filter(1 to 10, function($a) {$a mod 2 =0}) returns (2, 4, 6, 8, 10). 16.2.3fn:fold-left Summary Processes the supplied sequence from left to right, applying thesupplied function repeatedly to each item in turn, together with anaccumulated result value. Signature fn:fold-left( $seq as item()*, $zero as item()*, $f as function(item()*,item()) as item()*) as item()* Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The effect of the function is equivalent to the followingimplementation in XQuery: declare function fn:fold-left(        $seq as item()*        $zero as item()*,        $f as function(item()*, item()) as item()*)         as item()* {  if (fn:empty($seq))  then $zero  else fn:fold-left(fn:tail($seq), $f($zero, fn:head($seq)), $f)}; or its equivalent in XSLT: <xsl:function name="fn:fold-left" as="item()*">  <xsl:param name="seq" as="item()*"/>  <xsl:param name="zero" as="item()*"/>  <xsl:param name="f" as="function(item()*, item()) as item()*"/>  <xsl:choose>    <xsl:when test="fn:empty($seq)">      <xsl:sequence select="$zero"/>    </xsl:when>    <xsl:otherwise>      <xsl:sequence select="fn:fold-left(fn:tail($seq), $f($zero, fn:head($seq)), $f)"/>    </xsl:otherwise>  </xsl:choose></xsl:function>         Error Conditions As a consequence of the function signature and the functioncalling rules, a type error occurs if the supplied function$f cannot be applied to two arguments, where the firstargument is either the value of $zero or the result of aprevious application of $f, and the second is$seq or any trailing subsequence of $seq. Notes This operation is often referred to in the functionalprogramming literature as "folding" or "reducing" a sequence. Ittakes a function that operates on a pair of values, and applies itrepeatedly, with an accumulated result as the first argument, andthe next item in the sequence as the second argument. Theaccumulated result is initially set to the value of the$zero argument, which is conventionally a value (such aszero in the case of addition, one in the case of multiplication, ora zero-length string in the case of string concatenation) thatcauses the function to return the value of the other argumentunchanged. Examples The expression fn:fold-left(1 to 5, 0, function($a, $b) {$a + $b }) returns 15. (This returns thesum of the items in the sequence). The expression fn:fold-left((2,3,5,7), 1, function($a, $b){ $a * $b }) returns 210. (This returns theproduct of the items in the sequence). The expression fn:fold-left((true(), false(), false()),false(), function($a, $b) { $a or $b }) returnstrue(). (This returns true if any item in thesequence has an effective boolean value of true). The expression fn:fold-left((true(), false(), false()),false(), function($a, $b) { $a and $b }) returnsfalse(). (This returns true only if every item inthe sequence has an effective boolean value of true). The expression fn:fold-left(1 to 5, (), function($a, $b){($b, $a)}) returns (5,4,3,2,1). (Thisreverses the order of the items in a sequence). The expression fn:fold-left(1 to 5, "", fn:concat(?, ".",?)) returns ".1.2.3.4.5". The expression fn:fold-left(1 to 5, "$zero",fn:concat("$f(", ?, ", ", ?, ")") returns"$f($f($f($f($f($zero, 1), 2), 3), 4), 5)". 16.2.4fn:fold-right Summary Processes the supplied sequence from right to left, applying thesupplied function repeatedly to each item in turn, together with anaccumulated result value. Signature fn:fold-right( $seq as item()*, $zero as item()*, $f as function(item()*,item()) as item()*) as item()* Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The effect of the function is equivalent to the followingimplementation in XQuery: declare function fn:fold-right(        $seq as item()*,         $zero as item()*,         $f as function(item(), item()*) as item()*)         as item()* {  if (fn:empty($seq))  then $zero  else $f(fn:head($seq), fn:fold-right(fn:tail($seq), $zero, $f))}; or its equivalent in XSLT: <xsl:function name="fn:fold-right" as="item()*">  <xsl:param name="seq" as="item()*"/>  <xsl:param name="zero" as="item()*"/>  <xsl:param name="f" as="function(item(), item()*) as item()*"/>  <xsl:choose>    <xsl:when test="fn:empty($seq)">      <xsl:sequence select="$zero"/>    </xsl:when>    <xsl:otherwise>      <xsl:sequence select="$f(fn:head($seq), fn:fold-right(fn:tail($seq), $zero, $f))"/>    </xsl:otherwise>  </xsl:choose></xsl:function>         Error Conditions As a consequence of the function signature and the functioncalling rules, a type error occurs if the supplied function$f cannot be applied to two arguments, where the firstargument is any item in the sequence $seq, and thesecond is either the value of $zero or the result of aprevious application of $f. Notes This operation is often referred to in the functionalprogramming literature as "folding" or "reducing" a sequence. Ittakes a function that operates on a pair of values, and applies itrepeatedly, with the next item in the sequence as the firstargument, and the result of processing the remainder of thesequence as the second argument. The accumulated result isinitially set to the value of the $zero argument, whichis conventionally a value (such as zero in the case of addition,one in the case of multiplication, or a zero-length string in thecase of string concatenation) that causes the function to returnthe value of the other argument unchanged. In cases where the function performs an associative operation onits two arguments (such as addition or multiplication),fn:fold-right produces the same result as fn:fold-left. Examples The expression fn:fold-right(1 to 5, 0, function($a, $b) {$a + $b }) returns 15. (This returns thesum of the items in the sequence). The expression fn:fold-right(1 to 5, "", fn:concat(?, ".",?)) returns "1.2.3.4.5.". The expression fn:fold-right(1 to 5, "$zero",concat("$f(", ?, ", ", ?, ")")) returns "$f(1, $f(2,$f(3, $f(4, $f(5, $zero)))))". 16.2.5fn:for-each-pair Summary Applies the function item $f to successive pairs ofitems taken one from $seq1 and one from$seq2, returning the concatenation of the resultingsequences in order. Signature fn:for-each-pair( $seq1 as item()*, $seq2 as item()*, $f as function(item(),item()) as item()*) as item()* Properties This function is Â·deterministicÂ·,Â·context-independentÂ·, and Â·focus-independentÂ·. Rules The effect of the function is equivalent to the followingimplementation in XQuery: declare function fn:for-each-pair($seq1, $seq2, $f){   if(fn:exists($seq1) and fn:exists($seq2))    then (     $f(fn:head($seq1), fn:head($seq2)),     fn:for-each-pair(fn:tail($seq1), fn:tail($seq2), $f)   )   else ()}; or its equivalent in XSLT: <xsl:function name="fn:for-each-pair">  <xsl:param name="seq1/>  <xsl:param name="seq2/>  <xsl:param name="f"/>  <xsl:if test="fn:exists($seq1) and fn:exists($seq2)">    <xsl:sequence select="$f(fn:head($seq1), fn:head($seq2))"/>    <xsl:sequence select="fn:for-each-pair(fn:tail($seq1), fn:tail($seq2), $f)"/>  </xsl:if></xsl:function>         Examples The expression fn:for-each-pair(("a", "b", "c"), ("x","y", "z"), concat#2) returns ("ax", "by","cz"). The expression fn:for-each-pair(1 to 5, 1 to 5,function($a, $b){10*$a + $b} returns (11, 22, 33, 44,55). 17 Constructor functions 17.1 Constructorfunctions for XML Schema built-in atomic types Every built-in atomic type that is defined in [XML Schema Part 2: Datatypes Second Edition],except xs:anyAtomicType and xs:NOTATION,has an associated constructor function. The typexs:untypedAtomic, defined in Section 2.7 SchemaInformation DM30 and the two derivedtypes xs:yearMonthDuration andxs:dayTimeDuration defined in Section 2.7 SchemaInformation DM30 also have associatedconstructor functions. Implementations mayadditionally provide a constructor functions for the new data typexs:dateTimeStamp introduced in [Schema 1.1 Part 2]. A constructor function is not defined forxs:anyAtomicType as there are no atomic values withtype annotation xs:anyAtomicType at runtime, althoughthis can be a statically inferred type. A constructor function isnot defined for xs:NOTATION since it is defined as anabstract type in [XML Schema Part 2:Datatypes Second Edition]. If the static context (See Section 2.1.1Static Context XP30) contains a typederived from xs:NOTATION then a constructor functionis defined for it. See 17.5 Constructorfunctions for user-defined types. The form of the constructor function for an atomictype eg:TYPE is: eg:TYPE($arg as xs:anyAtomicType?) as eg:TYPE? If $arg is the empty sequence, the empty sequenceis returned. For example, the signature of the constructor functioncorresponding to the xs:unsignedInt type defined in[XML Schema Part 2: Datatypes SecondEdition] is: xs:unsignedInt($arg as xs:anyAtomicType?) as xs:unsignedInt? Calling the constructor function xs:unsignedInt(12)returns the xs:unsignedInt value 12. Another call ofthat constructor function that returns the samexs:unsignedInt value isxs:unsignedInt("12"). The same result would also bereturned if the constructor function were to be called with a nodethat had a typed value equal to the xs:unsignedInt 12.The standard features described in Section 2.4.2Atomization XP30 would atomize thenode to extract its typed value and then call the constructor withthat value. If the value passed to a constructor is not in thelexical space of the datatype to be constructed, and cannot beconverted to a value in the value space of the datatype under therules in this specification, then an dynamic error israised [err:FORG0001]. The semantics of the constructor function "xs:TYPE(arg) " are identical to the semantics of "arg cast as xs:TYPE? ". See 18 Casting. If the argument to a constructor function is a literal, theresult of the function may be evaluatedstatically; if an error is found during such evaluation, it may bereported as a static error. Special rules apply to constructor functions forxs:QName and types derived from xs:QNameand xs:NOTATION. See 17.2 Constructor functions forxs:QName and xs:NOTATION. The following constructor functions for the built-inatomic types are supported: xs:string($arg as xs:anyAtomicType?) as xs:string? xs:boolean($arg as xs:anyAtomicType?) as xs:boolean? xs:decimal($arg as xs:anyAtomicType?) as xs:decimal? xs:float($arg as xs:anyAtomicType?) as xs:float? Implementations should return negative zero forxs:float("-0.0E0"). But because [XML Schema Part 2: Datatypes Second Edition]does not distinguish between the values positive zero and negativezero. implementations Â·mayÂ· return positive zero in this case. xs:double($arg as xs:anyAtomicType?) as xs:double? Implementations should return negative zero forxs:double("-0.0E0"). But because [XML Schema Part 2: Datatypes Second Edition]does not distinguish between the values positive zero and negativezero. implementations Â·mayÂ· return positive zero in this case. xs:duration($arg as xs:anyAtomicType?) as xs:duration? xs:dateTime($arg as xs:anyAtomicType?) as xs:dateTime? xs:time($arg as xs:anyAtomicType?) as xs:time? xs:date($arg as xs:anyAtomicType?) as xs:date? xs:gYearMonth($arg as xs:anyAtomicType?) as xs:gYearMonth? xs:gYear($arg as xs:anyAtomicType?) as xs:gYear? xs:gMonthDay($arg as xs:anyAtomicType?) as xs:gMonthDay? xs:gDay($arg as xs:anyAtomicType?) as xs:gDay? xs:gMonth($arg as xs:anyAtomicType?) as xs:gMonth? xs:hexBinary($arg as xs:anyAtomicType?) as xs:hexBinary? xs:base64Binary($arg as xs:anyAtomicType?) as xs:base64Binary? xs:anyURI($arg as xs:anyAtomicType?) as xs:anyURI? xs:QName($arg as xs:anyAtomicType?) as xs:QName? See 17.2 Constructorfunctions for xs:QName and xs:NOTATION for specialrules. xs:normalizedString($arg as xs:anyAtomicType?) as xs:normalizedString? xs:token($arg as xs:anyAtomicType?) as xs:token? xs:language($arg as xs:anyAtomicType?) as xs:language? xs:NMTOKEN($arg as xs:anyAtomicType?) as xs:NMTOKEN? xs:Name($arg as xs:anyAtomicType?) as xs:Name? xs:NCName($arg as xs:anyAtomicType?) as xs:NCName? xs:ID($arg as xs:anyAtomicType?) as xs:ID? xs:IDREF($arg as xs:anyAtomicType?) as xs:IDREF? xs:ENTITY($arg as xs:anyAtomicType?) as xs:ENTITY? See 18.1.9 Casting toxs:ENTITY for rules related to constructing values of typexs:ENTITY and types derived from it. xs:integer($arg as xs:anyAtomicType?) as xs:integer? xs:nonPositiveInteger($arg as xs:anyAtomicType?) as xs:nonPositiveInteger? xs:negativeInteger($arg as xs:anyAtomicType?) as xs:negativeInteger? xs:long($arg as xs:anyAtomicType?) as xs:long? xs:int($arg as xs:anyAtomicType?) as xs:int? xs:short($arg as xs:anyAtomicType?) as xs:short? xs:byte($arg as xs:anyAtomicType?) as xs:byte? xs:nonNegativeInteger($arg as xs:anyAtomicType?) as xs:nonNegativeInteger? xs:unsignedLong($arg as xs:anyAtomicType?) as xs:unsignedLong? xs:unsignedInt($arg as xs:anyAtomicType?) as xs:unsignedInt? xs:unsignedShort($arg as xs:anyAtomicType?) as xs:unsignedShort? xs:unsignedByte($arg as xs:anyAtomicType?) as xs:unsignedByte? xs:positiveInteger($arg as xs:anyAtomicType?) as xs:positiveInteger? xs:yearMonthDuration($arg as xs:anyAtomicType?) as xs:yearMonthDuration? xs:dayTimeDuration($arg as xs:anyAtomicType?) as xs:dayTimeDuration? xs:untypedAtomic($arg as xs:anyAtomicType?) as xs:untypedAtomic? xs:dateTimeStamp($arg as xs:anyAtomicType?) as xs:dateTimeStamp? Available only if the implementation supports XSD1.1. 17.2 Constructor functions forxs:QName and xs:NOTATION Special rules apply to constructor functions for the typesxs:QName and xs:NOTATION, for tworeasons: Values cannot belong directly to the typexs:NOTATION, only to its subtypes. The lexical representation of these types uses namespaceprefixes, whose meaning is context-dependent. These constraints result in the following rules: There is no constructor function for xs:NOTATION.Constructors are defined, however, for xs:QName, fortypes derived or constructed fromxs:QName, and for types derived orconstructed from xs:NOTATION. When converting from an xs:string, the prefixwithin the lexical xs:QName supplied as the argumentis resolved to a namespace URI using the statically knownnamespaces from the static context. If the lexicalxs:QName has no prefix, the namespace URI of theresulting expanded-QName is the default element/type namespace fromthe static context. Components of the static context are defined inSection2.1.1 Static Context XP30. Adynamic error is raised [err:FONS0004] if the prefix is not bound in thestatic context. As described in Section 2.1Terminology DM30, the supplied prefixis retained as part of the expanded-QName value. When a constructor function for a namespace-sensitive type isused as a literal function item or in a partial functionapplication (for example, fn:QName#1 or fn:QName(?)) the namespace bindingsthat are relevant are those from the static context of the literalfunction item or partial function application. When a constructorfunction for a namespace-sensitive type is obtained by means of thefn:function-lookupfunction, the relevant namespace bindings are those from the staticcontext of the call on fn:function-lookup. Note: When the supplied argument to the xs:QNameconstructor function is a node, the node is atomized in the usualway, and if the result is xs:untypedAtomic it is thenconverted as if a string had been supplied. The effect might not bewhat is desired. For example, given the attributexsi:type="my:type", the expressionxs:QName(@xsi:type) might fail on the grounds that theprefix my is undeclared. This is because the namespacebindings are taken from the static context (that is, from the queryor stylesheet), and not from the source document containing the@xsi:type attribute. The solution to this problem isto use the function call resolve-QName(@xsi:type, .)instead. 17.3 Constructorfunctions for XML Schema built-in list types Each of the three built-in list types defined in [XML Schema Part 2: Datatypes Second Edition],namely xs:NMTOKENS, xs:ENTITIES, andxs:IDREFS, has an associated constructor function. The function signatures are as follows: xs:NMTOKENS($arg as xs:anyAtomicType?) as xs:NMTOKEN* xs:ENTITIES($arg as xs:anyAtomicType?) as xs:ENTITY* xs:IDREFS($arg as xs:anyAtomicType?) as xs:IDREF* The semantics are equivalent to casting to the correspondingtypes from xs:string. All three of these types have the facet minLength =1 meaning that there must always be at least one item in thelist. The return type, however, allows for the fact that when theargument to the function is an empty sequence, the result is anempty sequence. Note: In the case of atomic types, it is possible to use an expressionsuch as xs:date(@date-of-birth) to convert anattribute value to an instance of xs:date, knowingthat this will work both in the case where the attribute is alreadyannotated as xs:date, and also in the case where it isxs:untypedAtomic. This approach does not work withlist types, because it is not permitted to use a value of typexs:NMTOKEN* as input to the constructor functionxs:NMTOKENS. Instead, it is necessary to useconditional logic that performs the conversion only in the casewhere the input is untyped: if (@x instance of attribute(*,xs:untypedAtomic)) then xs:NMTOKENS(@x) else data(@x) 17.4 Constructorfunctions for XML Schema built-in union types In the case of an implementation that supports XSD 1.1, there isa constructor function associated with the built-in union typexs:error. The function signature is as follows: xs:error($arg as xs:anyAtomicType?) as xs:error? The semantics are equivalent to casting to the correspondingunion type (see 18.3.5 Casting tounion types). Note: Because xs:error has no member types, and thereforehas an empty value space, casting will always fail with a dynamicerror except in the case where the supplied argument is an emptysequence, in which case the result is also an empty sequence. 17.5 Constructorfunctions for user-defined types For every user-defined simple type in the static context(See Section 2.1.1Static Context XP30), there isa constructor function whose name is the same as the name of thetype and whose effect is to create a value of that type from thesupplied argument. The rules for constructing user-defined typesare defined in the same way as the rules for constructing built-inderived types defined in 17.1 Constructorfunctions for XML Schema built-in atomic types. Special rules apply to constructor functions fornamespace-sensitive types, that is, atomic types derived fromxs:QName and xs:NOTATION, list types thathave a namespace-sensitive item type, and union types that have anamespace-sensitive member type. See 17.2 Constructor functions forxs:QName and xs:NOTATION. Consider a situation where the static context contains anatomic type called hatSize defined in aschema whose target namespace is bound to the prefixeg. In such a case the following constructor functionis available to users: eg:hatSize($arg as xs:anyAtomicType?) as my:hatSize? In the case of an atomic type A, the return type ofthe function is A?, reflecting the fact that theresult will be an empty sequence if the input is an empty sequence.For a union or list type, the return type of the function isspecified only as xs:anyAtomicType*. Implementationsperforming static type checking will often be able to compute amore specific result type. For example, if the target type is alist type whose item type is the atomic type A, theresult will always be an instance of A*; if the targettype is a pure union type U then the result will alwaysbe an instance of U?. In general, however, applicationsneeding interoperable behavior on implementations that do strictstatic type checking will need to use a treat asexpression to assert the specific type of the result. To construct an instance of a user-defined typethat is not in a namespace, it is necessary to use a castexpression or undeclare the default function namespace. Forexample, if the user-defined type apple is derivedfrom xs:integer but is not in a namespace, an instanceof this type can be constructed as follows using a cast expression(this requires that the default element/type namespace is nonamespace): 17 cast as apple The following shows the use of the constructor function: declare default function namespace ""; apple(17) 18 Casting Constructor functions and cast expressions accept an expressionand return a value of a given type. They both convert a sourcevalue, SV, of a source type, ST, to a targetvalue, TV, of the given target type, TT, withidentical semantics and different syntax. The name of theconstructor function is the same as the name of the built-in[XML Schema Part 2: Datatypes SecondEdition] datatype or the datatype defined in Section 2.7 SchemaInformation DM30 of [XQuery and XPath Data Model (XDM) 3.0](see 17.1Constructor functions for XML Schema built-in atomic types)or the user-derived datatype (see 17.5 Constructorfunctions for user-defined types) that is the target forthe conversion, and the semantics are exactly the same as for acast expression; for example," xs:date("2003-01-01") "means exactly the same as " "2003-01-01" cast asxs:date? ". The cast expression takes a type name to indicate the targettype of the conversion. See Section 3.13.2 CastXP30. If the type name allows the emptysequence and the expression to be cast is the empty sequence, theempty sequence is returned. If the type name does not allow theempty sequence and the expression to be cast is the empty sequence,a type error is raised [err:XPTY0004]XP30. Where the argument to a cast is a literal, the result of thefunction may be evaluated statically; if an erroris encountered during such evaluation, it may bereported as a static error. The general rules for casting from primitive types to primitivetypes are defined in 18.1 Casting fromprimitive types to primitive types, and subsectionsdescribe the rules for specific target types. The general rules forcasting from xs:string (andxs:untypedAtomic) follow in 18.2 Casting from xs:string andxs:untypedAtomic. Casting to non-primitive types, includingatomic types derived by resctriction, union types, and list types,is described in 18.3Casting involving non-primitive types. Casting from derivedtypes is defined in 18.3.2 Casting from derivedtypes to parent types, 18.3.3 Casting within a branch of thetype hierarchy and 18.3.4 Casting across the typehierarchy. When casting from xs:string orxs:untypedAtomic the semantics in 18.2 Casting from xs:string andxs:untypedAtomic apply, regardless of target type. 18.1 Casting fromprimitive types to primitive types This section defines casting between the 19 primitive typesdefined in [XML Schema Part 2: DatatypesSecond Edition] as well as xs:untypedAtomic,xs:integer and the two derived types ofxs:duration (xs:yearMonthDuration andxs:dayTimeDuration). These four types are notprimitive types but they are treated as primitive types in thissection. The type conversions that are supported between primitiveatomic types are indicated in the table below; casts between other(non-primitive) types are defined in terms of these primitives. In this table, there is a row for each primitive type acting asthe source of the conversion and there is a column for eachprimitive type acting as the target of the conversion. Theintersections of rows and columns contain one of three characters:"Y" indicates that a conversion from values of the type to whichthe row applies to the type to which the column applies issupported; "N" indicates that there are no supported conversionsfrom values of the type to which the row applies to the type towhich the column applies; and "M" indicates that a conversion fromvalues of the type to which the row applies to the type to whichthe column applies may succeed for some values in the value spaceand fail for others. [XML Schema Part 2: Datatypes SecondEdition] defines xs:NOTATION as an abstract type.Thus, casting to xs:NOTATION from any other typeincluding xs:NOTATION is not permitted and raises astatic error [err:XPST0080]XP30.However, casting from one subtype of xs:NOTATION toanother subtype of xs:NOTATION is permitted. Casting is not supported to or fromxs:anySimpleType. Thus, there is no row or column forthis type in the table below. For any node that has not beenvalidated or has been validated as xs:anySimpleType,the typed value of the node is an atomic value of typexs:untypedAtomic. There are no atomic values with thetype annotation xs:anySimpleType at runtime.Casting to xs:anySimpleType is not permitted andraises a static error: [err:XPST0080]XP30. Similarly, casting is not supported to or fromxs:anyAtomicType and will raise a staticerror: [err:XPST0080]XP30.There are no atomic values with the type annotationxs:anyAtomicType at runtime, although this can be astatically inferred type. If casting is attempted from an ST to a TT forwhich casting is not supported, as defined in the table below, atype error is raised [err:XPTY0004]XP30. In the following table, the columns and rows are identified byshort codes that identify simple types as follows: uA = xs:untypedAtomic aURI = xs:anyURI b64 = xs:base64Binary bool = xs:boolean dat = xs:date gDay = xs:gDay dbl = xs:double dec = xs:decimal dT = xs:dateTime dTD = xs:dayTimeDuration dur = xs:duration flt = xs:float hxB = xs:hexBinary gMD = xs:gMonthDay gMon = xs:gMonth int = xs:integer NOT = xs:NOTATION QN = xs:QName str = xs:string tim = xs:time gYM = xs:gYearMonth yMD = xs:yearMonthDuration gYr = xs:gYear In the following table, the notation "S\T" indicates that thesource ("S") of the conversion is indicated in the column below thenotation and that the target ("T") is indicated in the row to theright of the notation. S\T uA str flt dbl dec int dur yMD dTD dT tim dat gYM gYr gMD gDay gMon bool b64 hxB aURI QN NOT uA Y Y M M M M M M M M M M M M M M M M M M M M M str Y Y M M M M M M M M M M M M M M M M M M M M M flt Y Y Y Y M M N N N N N N N N N N N Y N N N N N dbl Y Y Y Y M M N N N N N N N N N N N Y N N N N N dec Y Y Y Y Y Y N N N N N N N N N N N Y N N N N N int Y Y Y Y Y Y N N N N N N N N N N N Y N N N N N dur Y Y N N N N Y Y Y N N N N N N N N N N N N N N yMD Y Y N N N N Y Y Y N N N N N N N N N N N N N N dTD Y Y N N N N Y Y Y N N N N N N N N N N N N N N dT Y Y N N N N N N N Y Y Y Y Y Y Y Y N N N N N N tim Y Y N N N N N N N N Y N N N N N N N N N N N N dat Y Y N N N N N N N Y N Y Y Y Y Y Y N N N N N N gYM Y Y N N N N N N N N N N Y N N N N N N N N N N gYr Y Y N N N N N N N N N N N Y N N N N N N N N N gMD Y Y N N N N N N N N N N N N Y N N N N N N N N gDay Y Y N N N N N N N N N N N N N Y N N N N N N N gMon Y Y N N N N N N N N N N N N N N Y N N N N N N bool Y Y Y Y Y Y N N N N N N N N N N N Y N N N N N b64 Y Y N N N N N N N N N N N N N N N N Y Y N N N hxB Y Y N N N N N N N N N N N N N N N N Y Y N N N aURI Y Y N N N N N N N N N N N N N N N N N N Y N N QN Y Y N N N N N N N N N N N N N N N N N N N Y M NOT Y Y N N N N N N N N N N N N N N N N N N N Y M 18.1.1Casting to xs:string and xs:untypedAtomic Casting is permitted from any primitive type to the primitivetypes xs:string and xs:untypedAtomic. When a value of any simple type is cast asxs:string, the derivation of thexs:string value TV depends on the STand on the SV, as follows. If ST is xs:string or a type derived fromxs:string, TV is SV. If ST is xs:anyURI, the type conversion isperformed without escaping any characters. If ST is xs:QName orxs:NOTATION: if the qualified name has a prefix, then TV is theconcatenation of the prefix of SV, a single colon (:), andthe local name of SV. otherwise TV is the local-name. If ST is a numeric type, the following rules apply: If ST is xs:integer, TV is thecanonical lexical representation of SV as defined in[XML Schema Part 2: Datatypes SecondEdition]. There is no decimal point. If ST is xs:decimal, then: If SV is in the value space of xs:integer,that is, if there are no significant digits after the decimalpoint, then the value is converted from an xs:decimalto an xs:integer and the resultingxs:integer is converted to an xs:stringusing the rule above. Otherwise, the canonical lexical representation of SVis returned, as defined in [XML Schema Part2: Datatypes Second Edition]. If ST is xs:float orxs:double, then: TV will be an xs:string in the lexicalspace of xs:double or xs:float that whenconverted to an xs:double or xs:floatunder the rules of 18.2 Castingfrom xs:string and xs:untypedAtomic produces a value thatis equal to SV, or is "NaN" if SV isNaN. In addition, TV must satisfy theconstraints in the following sub-bullets. If SV has an absolute value that is greater than orequal to 0.000001 (one millionth) and less than 1000000 (onemillion), then the value is converted to an xs:decimaland the resulting xs:decimal is converted to anxs:string according to the rules above, as thoughusing an implementation of xs:decimal that imposes nolimits on the totalDigits orfractionDigits facets. If SV has the value positive or negative zero,TV is "0" or "-0" respectively. If SV is positive or negative infinity, TV isthe string "INF" or "-INF"respectively. In other cases, the result consists of a mantissa, which has thelexical form of an xs:decimal, followed by the letter"E", followed by an exponent which has the lexical form of anxs:integer. Leading zeroes and "+" signs areprohibited in the exponent. For the mantissa, there must be adecimal point, and there must be exactly one digit before thedecimal point, which must be non-zero. The "+" sign is prohibited.There must be at least one digit after the decimal point. Apartfrom this mandatory digit, trailing zero digits are prohibited. Note: The above rules allow more than one representation of the samevalue. For example, the xs:float value whose exactdecimal representation is 1.26743223E15 might be represented by anyof the strings "1.26743223E15", "1.26743222E15" or "1.26743224E15"(inter alia). It is implementation-dependent which of theserepresentations is chosen. If ST is xs:dateTime, xs:dateor xs:time, TV is the local value. Thecomponents of TV are individually cast toxs:string using the functions described in [casting-to-datetimes] and the resultsare concatenated together. The year component is castto xs:string usingeg:convertYearToString. The month,day, hour and minutecomponents are cast to xs:string usingeg:convertTo2CharString. The secondcomponent is cast to xs:string usingeg:convertSecondsToString. The timezone component, ifpresent, is cast to xs:string usingeg:convertTZtoString. Note that the hours component of the resulting string will neverbe "24". Midnight is always represented as"00:00:00". If ST is xs:yearMonthDuration orxs:dayTimeDuration, TV is the canonicalrepresentation of SV as defined in 8.1.1 xs:yearMonthDuration or8.1.2 xs:dayTimeDuration,respectively. If ST is xs:duration then let SYMbe SV cast asxs:yearMonthDuration, and let SDT beSV cast as xs:dayTimeDuration;Now, let the next intermediate value, TYM, beSYM cast asTT , and let TDT beSDT cast asTT . If TYM is "P0M", thenTV is TDT. Otherwise, TYM andTDT are merged according to the following rules: If TDT is "PT0S", then TV is TYM. Otherwise, TV is the concatenation of all thecharacters in TYM and all the characters except the first"P" and the optional negative sign in TDT. In all other cases, TV is the [XML Schema Part 2: Datatypes Second Edition]canonical representation of SV. For datatypes that do nothave a canonical lexical representation defined an Â·implementation dependentÂ· canonical representation may be used. To cast as xs:untypedAtomic the value is cast asxs:string, as described above, and the type annotationchanged to xs:untypedAtomic. Note: The string representations of numeric values are backwardscompatible with XPath 1.0 except for the special values positiveand negative infinity, negative zero and values outside the range1.0e-6 to 1.0e+6. 18.1.2 Casting to numeric types 18.1.2.1Casting to xs:float When a value of any simple type is cast asxs:float, the xs:float TV isderived from the ST and the SV as follows: If ST is xs:float, then TV isSV and the conversion is complete. If ST is xs:double, then TV isobtained as follows: if SV is the xs:double valueINF, -INF, NaN, positivezero, or negative zero, then TV is thexs:float value INF, -INF,NaN, positive zero, or negative zero respectively. otherwise, SV can be expressed in the form m Ã—2^e where the mantissa m and exponente are signed xs:integers whose valuerange is defined in [XML Schema Part 2:Datatypes Second Edition], and the following rules apply: if m (the mantissa of SV) is outside thepermitted range for the mantissa of an xs:float value(-2^24-1 to +2^24-1), then it is divided by2^N where N is the lowest positivexs:integer that brings the result of the divisionwithin the permitted range, and the exponent e isincreased by N. This is integer division (in effect,the binary value of the mantissa is truncated on the right). LetM be the mantissa and E the exponentafter this adjustment. if E exceeds 104 (the maximum exponentvalue in the value space of xs:float) then TVis the xs:float value INF or-INF depending on the sign of M. if E is less than -149 (the minimumexponent value in the value space of xs:float) thenTV is the xs:float value positive or negativezero depending on the sign of M otherwise, TV is the xs:float valueM Ã— 2^E. If ST is xs:decimal, orxs:integer, then TV is xs:float(SV cast as xs:string) and the conversion iscomplete. If ST is xs:boolean, SV isconverted to 1.0E0 if SV is trueand to 0.0E0 if SV is false andthe conversion is complete. If ST is xs:untypedAtomic orxs:string, see 18.2Casting from xs:string and xs:untypedAtomic. Note: XSD 1.1 adds the value +INF to the lexical space,as an alternative to INF. XSD 1.1 also adds negativezero to the value space. Note: Implementations should return negative zero forxs:float("-0.0E0"). But because [XML Schema Part 2: Datatypes Second Edition]does not distinguish between the values positive zero and negativezero. implementations Â·mayÂ· return positive zero in this case. 18.1.2.2Casting to xs:double When a value of any simple type is cast asxs:double, the xs:double valueTV is derived from the ST and the SV asfollows: If ST is xs:double, then TV isSV and the conversion is complete. If ST is xs:float or a type derived fromxs:float, then TV is obtained as follows: if SV is the xs:float valueINF, -INF, NaN, positivezero, or negative zero, then TV is thexs:double value INF, -INF,NaN, positive zero, or negative zero respectively. otherwise, SV can be expressed in the form m Ã—2^e where the mantissa m and exponente are signed xs:integer values whosevalue range is defined in [XML Schema Part2: Datatypes Second Edition], and TV is thexs:double value m Ã— 2^e. If ST is xs:decimal orxs:integer, then TV isxs:double( SV cast as xs:string)and the conversion is complete. If ST is xs:boolean, SV isconverted to 1.0E0 if SV is trueand to 0.0E0 if SV is false andthe conversion is complete. If ST is xs:untypedAtomic orxs:string, see 18.2Casting from xs:string and xs:untypedAtomic. Note: XSD 1.1 adds the value +INF to the lexical space,as an alternative to INF. XSD 1.1 also adds negativezero to the value space. Note: Implementations should return negative zero forxs:double("-0.0E0"). But because [XML Schema Part 2: Datatypes Second Edition]does not distinguish between the values positive zero and negativezero. implementations Â·mayÂ· return positive zero in this case. 18.1.2.3 Casting to xs:decimal When a value of any simple type is cast asxs:decimal, the xs:decimal valueTV is derived from ST and SV asfollows: If ST is xs:decimal,xs:integer or a type derived from them, thenTV is SV, converted to an xs:decimalvalue if need be, and the conversion is complete. If ST is xs:float orxs:double, then TV is thexs:decimal value, within the set ofxs:decimal values that the implementation is capableof representing, that is numerically closest to SV. If twovalues are equally close, then the one that is closest to zero ischosen. If SV is too large to be accommodated as anxs:decimal, (see [XML SchemaPart 2: Datatypes Second Edition] for Â·implementation-definedÂ· limits on numeric values) adynamic error is raised [err:FOCA0001]. If SV is one of thespecial xs:float or xs:double valuesNaN, INF, or -INF, adynamic error is raised [err:FOCA0002]. If ST is xs:boolean, SV isconverted to 1.0 if SV is 1 ortrue and to 0.0 if SV is0 or false and the conversion iscomplete. If ST is xs:untypedAtomic orxs:string, see 18.2Casting from xs:string and xs:untypedAtomic. 18.1.2.4 Casting to xs:integer When a value of any simple type is cast asxs:integer, the xs:integer valueTV is derived from ST and SV asfollows: If ST is xs:integer, or a type derivedfrom xs:integer, then TV is SV,converted to an xs:integer value if need be, and theconversion is complete. If ST is xs:decimal, xs:floator xs:double, then TV is SV with thefractional part discarded and the value converted toxs:integer. Thus, casting 3.1456 returns3 and -17.89 returns -17.Casting 3.124E1 returns 31. IfSV is too large to be accommodated as an integer, (see[XML Schema Part 2: Datatypes SecondEdition] for Â·implementation-definedÂ· limits on numeric values) adynamic error is raised [err:FOCA0003]. If SV is one of thespecial xs:float or xs:double valuesNaN, INF, or -INF, adynamic error is raised [err:FOCA0002]. If ST is xs:boolean, SV isconverted to 1 if SV is 1 ortrue and to 0 if SV is0 or false and the conversion iscomplete. If ST is xs:untypedAtomic orxs:string, see 18.2Casting from xs:string and xs:untypedAtomic. 18.1.3 Casting to duration types When a value of type xs:untypedAtomic,xs:string, a type derived from xs:string,xs:yearMonthDuration orxs:dayTimeDuration is cast asxs:duration, xs:yearMonthDuration orxs:dayTimeDuration, TV is derived fromST and SV as follows: If ST is the same as TT, then TV isSV. If ST is xs:duration, or a type derivedfrom xs:duration, but notxs:dayTimeDuration or a type derived fromxs:dayTimeDuration, and TT isxs:yearMonthDuration, then TV is derived fromSV by removing the day, hour, minute and second componentsfrom SV. If ST is xs:duration, or a type derivedfrom duration, but notxs:yearMonthDuration or a type derived fromxs:yearMonthDuration, and TT isxs:dayTimeDuration, then TV is derived fromSV by removing the year and month components fromSV. If ST is xs:yearMonthDuration orxs:dayTimeDuration, and TT isxs:duration, then TV is derived fromSV as defined in 18.3.2 Casting from derivedtypes to parent types. If ST is xs:yearMonthDuration andTT is xs:dayTimeDuration, the cast ispermitted and returns a xs:dayTimeDuration with value0.0 seconds. If ST is xs:dayTimeDuration andTT is xs:yearMonthDuration, the cast ispermitted and returns a xs:yearMonthDuration withvalue 0 months. If ST is xs:untypedAtomic orxs:string, see 18.2Casting from xs:string and xs:untypedAtomic. Note that casting from xs:duration toxs:yearMonthDuration orxs:dayTimeDuration loses information. To avoid this,users can cast the xs:duration value to both anxs:yearMonthDuration and anxs:dayTimeDuration and work with both values. 18.1.4 Casting to date and timetypes In several situations, casting to date and time types requiresthe extraction of a component from SV or from the resultof fn:current-dateTime andconverting it to an xs:string. These conversions mustfollow certain rules. For example, converting anxs:integer year value requires converting to anxs:string with four or more characters, preceded by aminus sign if the value is negative. This document defines four functions to perform theseconversions. These functions are for illustrative purposes only andmake no recommendations as to style or efficiency. References tothese functions from the following text are not normative. The arguments to these functions come from functions defined inthis document. Thus, the functions below assume that they arecorrect and do no range checking on them. declare function eg:convertYearToString($year as xs:integer) as xs:string{   let $plusMinus := if ($year >= 0) then "" else "-"   let $yearString := fn:abs($year) cast as xs:string   let $length := fn:string-length($yearString)   return     if ($length = 1)  then fn:concat($plusMinus, "000", $yearString)     else     if ($length = 2)  then fn:concat($plusMinus, "00", $yearString)       else       if ($length = 3)  then fn:concat($plusMinus, "0", $yearString)       else fn:concat($plusMinus, $yearString)}                    declare function eg:convertTo2CharString($value as xs:integer) as xs:string{   let $string := $value cast as xs:string   return      if (fn:string-length($string) = 1) then fn:concat("0", $string)     else $string}                    declare function eg:convertSecondsToString($seconds as xs:decimal) as xs:string{   let $string := $seconds cast as xs:string   let $intLength := fn:string-length(($seconds cast as xs:integer) cast as xs:string)   return      if ($intLength = 1) then fn:concat("0", $string)     else $string}                    declare function eg:convertTZtoString($tz as xs:dayTimeDuration?) as xs:string{   if (empty($tz))      then ""   else if ($tz eq xs:dayTimeDuration('PT0S'))     then "Z"   else      let $tzh := fn:hours-from-duration($tz)     let $tzm := fn:minutes-from-duration($tz)     let $plusMinus := if ($tzh >= 0) then "+" else "-"     let $tzhString := eg:convertTo2CharString(fn:abs($tzh))     let $tzmString := eg:convertTo2CharString(fn:abs($tzm))     return fn:concat($plusMinus, $tzhString, ":", $tzmString)}                    Conversion from primitive types to date and time types followsthe rules below. When a value of any primitive type is cast asxs:dateTime, the xs:dateTime valueTV is derived from ST and SV asfollows: If ST is xs:dateTime, then TV isSV. If ST is xs:date, then let SYR beeg:convertYearToString( fn:year-from-date( SV)), let SMO be eg:convertTo2CharString(fn:month-from-date( SV )), letSDA be eg:convertTo2CharString(fn:day-from-date( SV )) and letSTZ be eg:convertTZtoString(fn:timezone-from-date( SV ));TV is xs:dateTime( fn:concat( SYR, '-', SMO , '-', SDA, 'T00:00:00 ', STZ ) ). If ST is xs:untypedAtomic orxs:string, see 18.2Casting from xs:string and xs:untypedAtomic. When a value of any primitive type is cast asxs:time, the xs:time value TV isderived from ST and SV as follows: If ST is xs:time, then TV isSV. If ST is xs:dateTime, then TV isxs:time( fn:concat( eg:convertTo2CharString(fn:hours-from-dateTime( SV )), ':',eg:convertTo2CharString( fn:minutes-from-dateTime(SV )), ':', eg:convertSecondsToString(fn:seconds-from-dateTime( SV )),eg:convertTZtoString( fn:timezone-from-dateTime( SV)) )). If ST is xs:untypedAtomic orxs:string, see 18.2Casting from xs:string and xs:untypedAtomic. When a value of any primitive type is cast asxs:date, the xs:date value TV isderived from ST and SV as follows: If ST is xs:date, then TV isSV. If ST is xs:dateTime, then letSYR be eg:convertYearToString(fn:year-from-dateTime( SV )), letSMO be eg:convertTo2CharString(fn:month-from-dateTime( SV )), letSDA be eg:convertTo2CharString(fn:day-from-dateTime( SV )) and letSTZ beeg:convertTZtoString(fn:timezone-from-dateTime(SV )); TV is xs:date(fn:concat( SYR , '-', SMO, '-', SDA, STZ )). If ST is xs:untypedAtomic orxs:string, see 18.2Casting from xs:string and xs:untypedAtomic. When a value of any primitive type is cast asxs:gYearMonth, the xs:gYearMonth valueTV is derived from ST and SV asfollows: If ST is xs:gYearMonth, then TVis SV. If ST is xs:dateTime, then letSYR be eg:convertYearToString(fn:year-from-dateTime( SV )), letSMO be eg:convertTo2CharString(fn:month-from-dateTime( SV )) and letSTZ be eg:convertTZtoString(fn:timezone-from-dateTime( SV ));TV is xs:gYearMonth( fn:concat( SYR, '-', SMO, STZ )). If ST is xs:date, then let SYR beeg:convertYearToString( fn:year-from-date( SV)), let SMO be eg:convertTo2CharString(fn:month-from-date( SV )) and letSTZ be eg:convertTZtoString(fn:timezone-from-date( SV ));TV is xs:gYearMonth( fn:concat( SYR, '-', SMO, STZ )). If ST is xs:untypedAtomic orxs:string, see 18.2Casting from xs:string and xs:untypedAtomic. When a value of any primitive type is cast asxs:gYear, the xs:gYear value TVis derived from ST and SV as follows: If ST is xs:gYear, then TV isSV. If ST is xs:dateTime, let SYR beeg:convertYearToString( fn:year-from-dateTime(SV )) and let STZ beeg:convertTZtoString( fn:timezone-from-dateTime(SV )); TV isxs:gYear(fn:concat( SYR, STZ)). If ST is xs:date, let SYR beeg:convertYearToString( fn:year-from-date( SV)); and let STZ beeg:convertTZtoString( fn:timezone-from-date(SV )); TV isxs:gYear(fn:concat( SYR, STZ)). If ST is xs:untypedAtomic orxs:string, see 18.2Casting from xs:string and xs:untypedAtomic. When a value of any primitive type is cast asxs:gMonthDay, the xs:gMonthDay valueTV is derived from ST and SV asfollows: If ST is xs:gMonthDay, then TV isSV. If ST is xs:dateTime, then letSMO be eg:convertTo2CharString(fn:month-from-dateTime( SV )), letSDA be eg:convertTo2CharString(fn:day-from-dateTime( SV )) and letSTZ be eg:convertTZtoString(fn:timezone-from-dateTime( SV ));TV is xs:gYearMonth( fn:concat('--', SMO '-', SDA,STZ ) ). If ST is xs:date, then let SMO beeg:convertTo2CharString( fn:month-from-date(SV )), let SDA beeg:convertTo2CharString( fn:day-from-date( SV)) and let STZ be eg:convertTZtoString(fn:timezone-from-date( SV ));TV is xs:gYearMonth( fn:concat('--', SMO , '-', SDA,STZ ) ). If ST is xs:untypedAtomic orxs:string, see 18.2Casting from xs:string and xs:untypedAtomic. When a value of any primitive type is cast asxs:gDay, the xs:gDay value TV isderived from ST and SV as follows: If ST is xs:gDay, then TV isSV. If ST is xs:dateTime, then letSDA be eg:convertTo2CharString(fn:day-from-dateTime( SV )) and letSTZ be eg:convertTZtoString(fn:timezone-from-dateTime( SV ));TV is xs:gDay( fn:concat( '---',SDA, STZ )). If ST is xs:date, then let SDA beeg:convertTo2CharString( fn:day-from-date( SV)) and let STZ be eg:convertTZtoString(fn:timezone-from-date( SV ));TV is xs:gDay( fn:concat( '---',SDA, STZ )). If ST is xs:untypedAtomic orxs:string, see 18.2Casting from xs:string and xs:untypedAtomic. When a value of any primitive type is cast asxs:gMonth, the xs:gMonth valueTV is derived from ST and SV asfollows: If ST is xs:gMonth, then TV isSV. If ST is xs:dateTime, then letSMO be eg:convertTo2CharString(fn:month-from-dateTime( SV )) and letSTZ be eg:convertTZtoString(fn:timezone-from-dateTime( SV ));TV is xs:gMonth( fn:concat( '--' ,SMO, STZ )). If ST is xs:date, then let SMO beeg:convertTo2CharString( fn:month-from-date(SV )) and let STZ beeg:convertTZtoString( fn:timezone-from-date(SV )); TV is xs:gMonth(fn:concat( '--', SMO, STZ)). If ST is xs:untypedAtomic orxs:string, see 18.2Casting from xs:string and xs:untypedAtomic. 18.1.5Casting to xs:boolean When a value of any primitive type is cast asxs:boolean, the xs:boolean valueTV is derived from ST and SV asfollows: If ST is xs:boolean, then TV isSV. If ST is xs:float, xs:double,xs:decimal or xs:integer and SVis 0, +0, -0,0.0, 0.0E0 or NaN, thenTV is false. If ST is xs:float, xs:double,xs:decimal or xs:integer and SVis not one of the above values, then TV istrue. If ST is xs:untypedAtomic orxs:string, see 18.2Casting from xs:string and xs:untypedAtomic. 18.1.6Casting to xs:base64Binary and xs:hexBinary Values of type xs:base64Binary can be cast asxs:hexBinary and vice versa, since the two types havethe same value space. Casting to xs:base64Binary andxs:hexBinary is also supported from the same type andfrom xs:untypedAtomic, xs:string andsubtypes of xs:string using [XML Schema Part 2: Datatypes Second Edition]semantics. 18.1.7Casting to xs:anyURI Casting to xs:anyURI is supported only from thesame type, xs:untypedAtomic orxs:string. When a value of any primitive type is cast asxs:anyURI, the xs:anyURI valueTV is derived from the ST and SV asfollows: If ST is xs:untypedAtomic orxs:string see 18.2Casting from xs:string and xs:untypedAtomic. 18.1.8 Casting to xs:QName andxs:NOTATION Casting from xs:string orxs:untypedAtomic to xs:QName orxs:NOTATION is described in 18.2 Casting from xs:string andxs:untypedAtomic. It is also possible to cast from xs:NOTATION toxs:QName, or from xs:QName to any typederived by restriction from xs:NOTATION. (Casting toxs:NOTATION itself is not allowed, becausexs:NOTATION is an abstract type.) The resultingxs:QName or xs:NOTATION has the sameprefix, local name, and namespace URI parts as the suppliedvalue. Note: See 17.2 Constructorfunctions for xs:QName and xs:NOTATION for a discussion ofhow the combination of atomization and casting might not producethe desired effect. 18.1.9Casting to xs:ENTITY [XML Schema Part 2: Datatypes SecondEdition] says that "The value space of ENTITY is the set of allstrings that match the NCName production ... and have been declaredas an unparsed entity in a document type definition." However,[XSL Transformations (XSLT) Version 3.0] and[XQuery 3.0: An XML Query Language] do notcheck that constructed values of type xs:ENTITY matchdeclared unparsed entities. Thus, this rule is relaxed in thisspecification and, in casting to xs:ENTITY and typesderived from it, no check is made that the values correspond todeclared unparsed entities. 18.2 Casting from xs:string andxs:untypedAtomic This section applies when the supplied value SV is aninstance of xs:string orxs:untypedAtomic, including types derived from theseby restriction. If the value is xs:untypedAtomic, itis treated in exactly the same way as a string containing the samesequence of characters. The supplied string is mapped to a typed value of the targettype as defined in [XML Schema Part 2:Datatypes Second Edition]. Whitespace normalization is appliedas indicated by the whiteSpace facet for the datatype.The resulting whitespace-normalized string must be a valid lexicalform for the datatype. The semantics of casting follow the rules ofXML Schema validation. For example, "13" cast asxs:unsignedInt returns the xs:unsignedInt typedvalue 13. This could also be writtenxs:unsignedInt("13"). The target type can be any simple type other than an abstracttype. Specifically, it can be a type whose variety is atomic,union, or list. In each case the effect of casting to the targettype is the same as constructing an element with the supplied valueas its content, validating the element using the target type as thegoverning type, and atomizing the element to obtain its typedvalue. When the target type is a derived type that is restricted by apattern facet, the lexical form is first checked against thepattern before further casting is attempted (See 18.3.1 Casting to derivedtypes). If the lexical form does not conform to thepattern, a dynamic error [err:FORG0001] is raised. For example, consider a user-defined typemy:boolean which is derived by restriction fromxs:boolean and specifies the pattern facetvalue="0|1". The expression "true" cast asmy:boolean would fail with a dynamic error[err:FORG0001]. Facets other than pattern are checkedafter the conversion. For example if there is auser-defined datatype called my:height defined as arestriction of xs:integer with the facet<maxInclusive value="84"/>, then the expression"100" cast as my:height would fail with adynamic error [err:FORG0001]. Casting to the types xs:NOTATION,xs:anySimpleType, or xs:anyAtomicType isnot permitted because these types are abstract (they have noimmediate instances). Special rules apply when casting to namespace-sensitive types.The types xs:QName and xs:NOTATION arenamespace-sensitive. Any type derived by restriction from anamespace-sensitive type is itself namespace-sensitive, as is anyunion type having a namespace-sensitive type among its members, andany list type having a namespace-sensitive type as its item type.For details, see 17.2Constructor functions for xs:QName and xs:NOTATION. Note: This version of the specification allows casting betweenxs:QName and xs:NOTATION in eitherdirection; this was not permitted in the previous Recommendation.This version also removes the rule that only a string literal(rather than a dynamic string) may be cast to anxs:QName When casting to a numeric type: If the value is too large or too small to be accuratelyrepresented by the implementation, it is handled as an overflow orunderflow as defined in 4.2 Arithmeticoperators on numeric values. If the target type is xs:float orxs:double, the string -0 (and equivalentssuch as -0.0 or -000)should be converted to the value negative zero.However, if the implementation is reliant on an implementation ofXML Schema 1.0 in which negative zero is not part of the valuespace for these types, these lexical forms may beconverted to positive zero. In casting to xs:decimal or to a type derived fromxs:decimal, if the value is not too large or too smallbut nevertheless cannot be represented accurately with the numberof decimal digits available to the implementation, theimplementation may round to the nearest representable value or mayraise a dynamic error [err:FOCA0006]. The choice of rounding algorithmand the choice between rounding and error behavior and is Â·implementation-definedÂ·. In casting to xs:date, xs:dateTime,xs:gYear, or xs:gYearMonth (or typesderived from these), if the value is too large or too small to berepresented by the implementation, a dynamic error[err:FODT0001] israised. In casting to a duration value, if the value is too large or toosmall to be represented by the implementation, adynamic error [err:FODT0002] is raised. For xs:anyURI, the extent to which animplementation validates the lexical form of xs:anyURIis Â·implementation dependentÂ·. If the cast fails for any other reason, a dynamicerror [err:FORG0001] is raised. 18.3 Casting involvingnon-primitive types Casting from xs:string andxs:untypedAtomic to any other type (primitive ornon-primitive) has been described in 18.2 Casting from xs:string andxs:untypedAtomic. This section defines how other casts tonon-primitive types operate, including casting to types derived byrestriction, to union types, and to list types. 18.3.1 Casting to derived types Casting a value to a derived type can be separated into fourcases. Note that xs:untypedAtomic,xs:integer and the two derived types ofxs:duration:xs:yearMonthDuration andxs:dayTimeDuration are treated as primitive types. When SV is an instance of a type that is derived byrestriction from TT. This is described in section 18.3.2 Casting from derivedtypes to parent types. When SV is an instance of a type derived by restrictionfrom the same primitive type as TT. This is described in18.3.3 Casting within a branchof the type hierarchy. When the derived type is derived, directly or indirectly, from adifferent primitive type than the primitive type of ST.This is described in 18.3.4Casting across the type hierarchy. When SV is an immediate instance of TT, thecast always succeeds, returning SV unchanged. 18.3.2 Casting from derivedtypes to parent types It is always possible to cast an atomic value A to atype T if the relation A instance of T istrue, provided that T is not an abstract type. For example, it is possible to cast anxs:unsignedShort to an xs:unsignedInt, toan xs:integer, to an xs:decimal, or to aunion type whose member types are xs:integer andxs:double. Since the value space of the original type is a subset of thevalue space of the target type, such a cast is alwayssuccessful. For the expression A instance of T to be true,T must be either an atomic type, or a union type thathas no constraining facets. It cannot be a list type, nor a uniontype derived by restriction from another union type, nor a uniontype that has a list type among its member types. The result will have the same value as the original, but willhave a new type annotation: If T is an atomic type, then the type annotation ofthe result is T. If T is a union type, then the type of the result isan atomic type M such that M is one of theatomic types in the transitive membership of the union typeT and A instance of M is true; if there ismore than one type M that satisfies these conditions(which could happen, for example, if T is the union oftwo overlapping types such as xs:int andxs:positiveInteger) then the first one is used, takingthe member types in the order in which they appear within thedefinition of the union type. 18.3.3 Casting within a branch of thetype hierarchy It is possible to cast an SV to a TT if thetype of the SV and the TT type are both derivedby restriction (directly or indirectly) from the same primitivetype, provided that the supplied value conforms to the constraintsimplied by the facets of the target type. This includes the casewhere the target type is derived from the type of the suppliedvalue, as well as the case where the type of the supplied value isderived from the target type. For example, an instance ofxs:byte can be cast as xs:unsignedShort,provided the value is not negative. If the value does not conform to the facets defined for thetarget type, then a dynamic error is raised [err:FORG0001]. See [XML Schema Part 2: Datatypes Second Edition].In the case of the pattern facet (which applies to the lexicalspace rather than the value space), the pattern is tested againstthe canonical lexical representation of the value, as defined forthe source type (or the result of casting the value to anxs:string, in the case of types that have no canonicallexical representation defined for them). Note that this will cause casts to fail if the pattern excludesthe canonical lexical representation of the source type. Forexample, if the type my:distance is defined as arestriction of xs:decimal with a pattern that requirestwo digits after the decimal point, casting of anxs:integer to my:distance will alwaysfail, because the canonical representation of anxs:integer does not conform to this pattern. In some cases, casting from a parent type to a derived typerequires special rules. See 18.1.3 Casting to duration typesfor rules regarding casting to xs:yearMonthDurationand xs:dayTimeDuration. See 18.1.9 Casting to xs:ENTITY, below,for casting to xs:ENTITY and types derived fromit. 18.3.4 Casting across the typehierarchy When the ST and the TT are derived, directlyor indirectly, from different primitive types, this is calledcasting across the type hierarchy. Casting across the typehierarchy is logically equivalent to three separate steps performedin order. Errors can occur in either of the latter two steps. Cast the SV, up the hierarchy, to the primitive type ofthe source, as described in 18.3.2 Casting from derivedtypes to parent types. If SV is an instance of xs:string orxs:untypedAtomic, check its value against the patternfacet of TT, and raise a dynamic error[err:FORG0001] ifthe check fails. Cast the value to the primitive type of TT, asdescribed in 18.1Casting from primitive types to primitive types. If TT is derived from xs:NOTATION, assumefor the purposes of this rule that casting toxs:NOTATION succeeds. Cast the value down to the TT, as described in 18.3.3 Casting within a branch of thetype hierarchy 18.3.5Casting to union types If the target type of a cast expression (or a constructorfunction) is a type with variety union, the supplied value must beone of the following: A value of type xs:string orxs:untypedAtomic. This case follows the general rulesfor casting from strings, and has already been described in18.2 Casting from xs:string andxs:untypedAtomic. If the union type has a pattern facet, the pattern is testedagainst the supplied value after whitespace normalization, usingthe whiteSpace normalization rules of the memberdatatype against which validation succeeds. A value that is an instance of one of the atomic types in thetransitive membership of the union type, and of the union typeitself. This case has already been described in 18.3.2 Casting from derivedtypes to parent types This situation only applies when the value is an instance of theunion type, which means it will never apply when the union isderived by facet-based restriction from another union type. A value that is castable to one or more of the atomic types inthe transitive membership of the union type (in the sense that thecastable as operator returns true). In this case the supplied value is cast to each atomic type inthe transitive membership of the union type in turn (in the orderin which the member types appear in the declaration) until one ofthese casts is successful; if none of them is successful, a dynamicerror occurs [err:FORG0001]. If the union type hasconstraining facets then the resulting value must satisfy thesefacets, otherwise a dynamic error occurs [err:FORG0001]. If the union type has a pattern facet, the pattern is testedagainst the canonical representation of the result value. Only the atomic types in the transitive membership of the uniontype are considered. The union type may have list types in itstransitive membership, but (unless the supplied value is of typexs:string or xs:untypedAtomic, in whichcase the rules in 18.2 Castingfrom xs:string and xs:untypedAtomic apply), any list typesin the membership are effectively ignored. If more than one of these conditions applies, then the castingis done according to the rules for the first condition thatapplies. If none of these conditions applies, the cast fails with adynamic error [err:FORG0001]. Example: consider a type U whose member types arexs:integer and xs:date. The expression "123" cast as U returns thexs:integer value 123. The expression current-date() cast as U returns thecurrent date as an instance of xs:date. The expression 23.1 cast as U returns thexs:integer value 23. Example: consider a type V whose member types arexs:short and xs:negativeInteger. The expression "-123" cast as V returns thexs:short value -123. The expression "-100000" cast as V returns thexs:negativeInteger value -100000. The expression 93.7 cast as V returns thexs:short value 93. The expression "93.7" cast as V raises adynamic error [err:FORG0001] on the grounds that the string"93.7" is not in the lexical space of the uniontype. Example: consider a type W that is derived from theabove type V by restriction, with a pattern facet of-?\d\d. The expression "12" cast as V returns thexs:short value 12. The expression "123" cast as V raises andynamic error [err:FORG0001] on the grounds that the string"123" does not match the pattern facet. 18.3.6Casting to list types If the target type of a cast expression (or a constructorfunction) is a type with variety list, the suppliedvalue must be of type xs:string orxs:untypedAtomic. The rules follow the generalprinciple for all casts from xs:string outlined in18.2 Casting from xs:string andxs:untypedAtomic. The semantics of the operation are consistent with validation:that is, the effect of casting a string S to a list typeL is the same as constructing an element or attributenode whose string value is S, validating it usingL as the governing type, and atomizing the resultingnode. The result will always be either failure, or a sequence ofzero or more atomic values each of which is an instance of the itemtype of L (or if the item type of L is aunion type, an instance of one of the atomic types in itstransitive membership). If the item type of the list type is namespace-sensitive, thenthe namespace bindings in the static context will be used toresolve any namespace prefix, in the same way as when the targettype is xs:QName. If the list type has a pattern facet, the patternmust match the supplied value after collapsing whitespace (anoperation equivalent to the use of the fn:normalize-spacefunction). For example, the expression cast "A B C D" asxs:NMTOKENS produces a sequence of fourxs:NMTOKEN values, ("A", "B", "C","D"). For example, given a user-defined typemy:coordinates defined as a list ofxs:integer with the facet <xs:lengthvalue="3"/>, the expression my:coordinates("2-1") will return a sequence of two xs:integer values(2, -1), while the expression my:coordinates("12 3") will result in a dynamic error because the length ofthe list does not conform to the length facet. Theexpression my:coordinates("1.0 3.0") will also failbecause the strings 1.0 and 3.0 are notin the lexical space of xs:integer. A References A.1Normative references Character Model for the World Wide Web 1.0:Fundamentals Character Model for the World Wide Web 1.0: Fundamentals.Available at: http://www.w3.org/TR/2005/REC-charmod-20050215/ IEEE 754-2008 IEEE. IEEE Standard for Floating-PointArithmetic. ISO3166-1 ISO (International Organization for Standardization) Codesfor the representation of names of countries and their subdivisions- Part 1: Country codes ISO 3166-1:2013. ISO10967 ISO (International Organization for Standardization).Information technologyâ€”Language Independent Arithmeticâ€”Part 1:Integer and floating point arithmetic ISO/IEC10967-1:2012. Locale DataMarkup Language Unicode Technical Standard #35, Locale Data Markup Language.Available at: http://www.unicode.org/reports/tr35/ Legacyextended IRIs for XML resource identification Legacy extended IRIs for XML resource identification.Henry S. Thomson, Richard Tobin, and Norman Walsh (eds), World WideWeb Consortium. 3 November 2008. Available at http://www.w3.org/TR/leiri/ RFC2376 IETF. RFC 2376: XML Media Types. Available at:http://www.ietf.org/rfc/rfc2376.txt RFC3023 IETF. RFC 2376: XML Media Types. Available at:http://www.ietf.org/rfc/rfc3023.txt RFC3986 IETF. RFC 3986: Uniform Resource Identifiers (URI):Generic Syntax. Available at: http://www.ietf.org/rfc/rfc3986.txt RFC3987 IETF. RFC 3987: Internationalized Resource Identifiers(IRIs). Available at: http://www.ietf.org/rfc/rfc3987.txt OlsonTimezone Database The tz timezone database, available at http://www.twinsun.com/tz/tz-link.htm.It is Â·implementation-definedÂ· which version of the database is used. TheUnicode Standard The Unicode Consortium, Reading, MA, Addison-Wesley, 2003.The Unicode Standard as updated from time to time by thepublication of new versions. See http://www.unicode.org/standard/versions/for the latest version and additional information on versions ofthe standard and of the Unicode Character Database. The version ofUnicode to be used is Â·implementation-definedÂ·, but implementations are recommended to usethe latest Unicode version; currently, Version 6.0.0. Unicode Collation Algorithm Unicode Technical Standard #10, Unicode Collation Algorithm.Available at: http://www.unicode.org/reports/tr10/ Unicode Normalization Forms Unicode Standard Annex #15, Unicode Normalization Forms.Available at: http://www.unicode.org/reports/tr15/.As with [The Unicode Standard], the versionto be used is Â·implementation-definedÂ·. Unicode Regular Expressions Unicode Technical Standard #18, Unicode Regular Expressions.Available at: http://www.unicode.org/reports/tr18/ ExtensibleMarkup Language (XML) 1.0 (Fifth Edition) Extensible MarkupLanguage (XML) 1.0 (Fifth Edition), Tim Bray, JeanPaoli, Michael Sperberg-McQueen, et. al., Editors. WorldWide Web Consortium, 26 Nov 2008. This version ishttp://www.w3.org/TR/2008/REC-xml-20081126/. The latest version is available athttp://www.w3.org/TR/xml. ExtensibleMarkup Language (XML) 1.1 Recommendation Extensible MarkupLanguage (XML) 1.1 (Second Edition), Tim Bray, JeanPaoli, Michael Sperberg-McQueen, et. al., Editors. WorldWide Web Consortium, 16 Aug 2006. This version ishttp://www.w3.org/TR/2006/REC-xml11-20060816. The latest version is available athttp://www.w3.org/TR/xml11/. XML PathLanguage (XPath) Version 1.0 XML Path Language(XPath) Version 1.0, James Clark and Steven DeRose,Editors. World Wide Web Consortium, 16 Nov 1999. Thisversion is http://www.w3.org/TR/1999/REC-xpath-19991116. Thelatest version isavailable at http://www.w3.org/TR/xpath. XML PathLanguage (XPath) 2.0 XML PathLanguage (XPath) 2.0 (Second Edition), Don Chamberlin,Anders Berglund, Scott Boag, et. al., Editors. World WideWeb Consortium, 14 December 2010. This version ishttp://www.w3.org/TR/2010/REC-xpath20-20101214/. The latest version is available athttp://www.w3.org/TR/xpath20/. XMLPath Language (XPath) 3.0 XML PathLanguage (XPath) 3.0, Jonathan Robie, Don Chamberlin,Michael Dyck, John Snelson, Editors. World Wide Web Consortium, 08April 2014. This version ishttp://www.w3.org/TR/2014/REC-xpath-30-20140408/. The latest version is available athttp://www.w3.org/TR/xpath-30/. XQuery 1.0 and XPath 2.0 Functions andOperators XQuery1.0 and XPath 2.0 Functions and Operators (SecondEdition), Ashok Malhotra, Jim Melton, and Norman Walsh,Editors. World Wide Web Consortium, 14 December 2010. This versionis http://www.w3.org/TR/2010/REC-xpath-functions-20101214/. Thelatest versionis available at http://www.w3.org/TR/xpath-functions/. XSLTransformations (XSLT) Version 2.0 XSLTransformations (XSLT) Version 2.0 (Second Edition),Michael Kay, Editor. World Wide Web Consortium, 23 January 2007.This version is http://www.w3.org/TR/2007/REC-xslt20-20070123/. Thelatest version isavailable at http://www.w3.org/TR/xslt20/. XQuery and XPath Data Model (XDM)3.0 XQuery and XPathData Model (XDM) 3.0, Norman Walsh, Anders Berglund,John Snelson, Editors. World Wide Web Consortium, 08 April 2014.This version ishttp://www.w3.org/TR/2014/REC-xpath-datamodel-30-20140408/. Thelatestversion is available athttp://www.w3.org/TR/xpath-datamodel-30/. XSLT and XQuery Serialization3.0 XSLT andXQuery Serialization 3.0, Henry Zongaro, Andrew Coleman,Michael Sperberg-McQueen, Editors. World Wide Web Consortium, 08April 2014. This version ishttp://www.w3.org/TR/2014/REC-xslt-xquery-serialization-30-20140408/.The latestversion is available athttp://www.w3.org/TR/xslt-xquery-serialization-30/. XQuery 1.0 and XPath 2.0 FormalSemantics XQuery1.0 and XPath 2.0 Formal Semantics (Second Edition),JÃ©rÃ´me SimÃ©on, Denise Draper, Peter Frankhauser, et. al.,Editors. World Wide Web Consortium, 14 December 2010. This versionis http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/. Thelatest versionis available at http://www.w3.org/TR/xquery-semantics/. XQuery1.0: An XML Query Language XQuery 1.0: AnXML Query Language (Second Edition), Don Chamberlin,Anders Berglund, Scott Boag, et. al., Editors. World WideWeb Consortium, 14 December 2010. This version ishttp://www.w3.org/TR/2010/REC-xquery-20101214/. The latest version is available athttp://www.w3.org/TR/xquery/. XQuery 3.0: An XML Query Language XQuery 3.0: AnXML Query Language, Jonathan Robie, Don Chamberlin,Michael Dyck, John Snelson, Editors. World Wide Web Consortium, 08April 2014. This version ishttp://www.w3.org/TR/2014/REC-xquery-30-20140408/. The latest version is availableat http://www.w3.org/TR/xquery-30/. XMLInclusions (XInclude) Version 1.0 (Second Edition) XML Inclusions(XInclude) Version 1.0 (Second Edition), Jonathan Marsh,David Orchard, and Daniel Veillard, Editors. World Wide WebConsortium, 15 Nov 2006. This version ishttp://www.w3.org/TR/2006/REC-xinclude-20061115/. The latest version is available athttp://www.w3.org/TR/xinclude/. XML Schema Part 2: Datatypes SecondEdition XML Schema Part 2: Datatypes Second Edition, Oct. 28 2004.Available at: http://www.w3.org/TR/xmlschema-2/ Schema 1.1 Part 2 W3C XMLSchema Definition Language (XSD) 1.1 Part 2: Datatypes,David Peterson, Sandy Gao, Ashok Malhotra, et. al.,Editors. World Wide Web Consortium, 05 Apr 2012. Thisversion is http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/.The latestversion is available athttp://www.w3.org/TR/xmlschema11-2/. Namespaces in XML Namespaces inXML 1.0 (Third Edition), Tim Bray, Dave Hollander,Andrew Layman, et. al., Editors. World Wide WebConsortium, 08 Dec 2009. This version ishttp://www.w3.org/TR/2009/REC-xml-names-20091208/. The latest version is available athttp://www.w3.org/TR/xml-names. A.2 Non-normative references XSLTransformations (XSLT) Version 3.0 XSLTransformations (XSLT) Version 3.0, Michael Kay, Editor.World Wide Web Consortium, 12 December 2013. This version ishttp://www.w3.org/TR/2013/WD-xslt-30-20131212/. The latest version is available athttp://www.w3.org/TR/xslt-30/. Calendrical Calculations Edward M. Reingold and Nachum Dershowitz. CalendricalCalculations Millennium edition (2nd Edition). CambridgeUniversity Press, ISBN 0 521 77752 6 Character Model for the World Wide Web1.0: Normalization Character Model for the World Wide Web 1.0: Normalization,Last Call Working Draft. Available at: http://www.w3.org/TR/2004/WD-charmod-norm-20040225/ HTML4.0 HTML 4.01 Recommendation, 24 December 1999. Available at:http://www.w3.org/TR/REC-html40/ ISO8601 ISO (International Organization for Standardization).Representations of dates and times, 2000-08-03. Availablefrom: http://www.iso.org/" POSIX.1-2008 The Open Group Base Specifications Isuse 7 (IEEE Std1003.1-2008). Available at: http://pubs.opengroup.org/onlinepubs/9699919799/ Working With Timezones World Wide Web Consortium Working Group Note. Working WithTimezones, October 13, 2005. Available at: http://www.w3.org/TR/2005/NOTE-timezone-20051013/ B Errorsummary The error text provided with these errors is non-normative. err:FOAR0001,Division by zero. This error is raised whenever an attempt is made to divide byzero. err:FOAR0002,Numeric operation overflow/underflow. This error is raised whenever numeric operations result in anoverflow or underflow. err:FOCA0001, Inputvalue too large for decimal. Raised when casting to xs:decimal if the suppliedvalue exceeds the implementation-defined limits for the datatype. err:FOCA0002,Invalid lexical value. Raised by fn:resolve-QName andfn:QName when a suppliedvalue does not have the lexical form of a QName or URIrespectively; and when casting to decimal, if the supplied value isNaN or Infinity. err:FOCA0003, Inputvalue too large for integer. Raised when casting to xs:integer if the suppliedvalue exceeds the implementation-defined limits for the datatype. err:FOCA0005, NaNsupplied as float/double value. Raised when multiplying or dividing a duration by a number, ifthe number supplied is NaN. err:FOCA0006, Stringto be cast to decimal has too many digits of precision. Raised when casting a string to xs:decimal if thestring has more digits of precision than the implementation canrepresent (the implementation also has the option of rounding). err:FOCH0001,Codepoint not valid. Raised by fn:codepoints-to-stringif the input contains an integer that is not the codepoint of avalid XML character. err:FOCH0002,Unsupported collation. Raised by any function that uses a collation if the requestedcollation is not recognized. err:FOCH0003,Unsupported normalization form. Raised by fn:normalize-unicode ifthe requested normalization form is not supported by theimplementation. err:FOCH0004,Collation does not support collation units. Raised by functions such as fn:contains if the requestedcollation does not operate on a character-by-character basis. err:FODC0001, Nocontext document. Raised by fn:id, fn:idref, and fn:element-with-id if thenode that identifies the tree to be searched is a node in a treewhose root is not a document node. err:FODC0002, Errorretrieving resource. Raised by fn:doc, fn:collection, and fn:uri-collection toindicate that either the supplied URI cannot be dereferenced toobtain a resource, or the resource that is returned is notparseable as XML. err:FODC0003,Function not defined as deterministic. Raised by fn:doc, fn:collection to indicate thatit is not possible to return a result that is guaranteeddeterministic. err:FODC0004,Invalid argument to fn:collection. Raised by fn:collection if the argumentis not a valid xs:anyURI. err:FODC0005,Invalid argument to fn:doc or fn:doc-available. Raised (optionally) by fn:doc and fn:doc-available if theargument is not a valid xs:anyURI. err:FODC0006, Stringpassed to fn:parse-xml is not a well-formed XML document. Raised by fn:parse-xml if the suppliedstring is not a well-formed and namespace-well-formed XML document;or if DTD validation is requested and the document is not validagainst its DTD. err:FODC0010, Theprocessor does not support serialization. Raised when fn:serialize is called and theprocessor does not support serialization, in cases where the hostlanguage makes serialization an optional feature. err:FODF1280,Invalid decimal format name. This error is raised if the decimal format name supplied tofn:format-number isnot a valid QName, or if the prefix in the QName is undeclared, orif there is no decimal format in the static context with a matchingname. err:FODF1310,Invalid decimal format picture string. This error is raised if the picture string supplied to fn:format-number has invalidsyntax. err:FODT0001,Overflow/underflow in date/time operation. Raised when casting to date/time data types, or performingarithmetic with date/time values, if arithmetic overflow orunderflow occurs. err:FODT0002,Overflow/underflow in duration operation. Raised when casting to duration data types, or performingarithmetic with duration values, if arithmetic overflow orunderflow occurs. err:FODT0003,Invalid timezone value. Raised by adjust-date-to-timezone and relatedfunctions if the supplied timezone is invalid. err:FOER0000,Unidentified error. Error code used by fn:error when no other error code isprovided. err:FOFD1340,Invalid date/time formatting parameters. This error is raised if the picture string orcalendar supplied to fn:format-date, fn:format-time, or fn:format-dateTime hasinvalid syntax. err:FOFD1350,Invalid date/time formatting component. This error is raised if the picture string supplied to fn:format-date selects acomponent that is not present in a date, or if the picture stringsupplied to fn:format-time selects acomponent that is not present in a time. err:FONS0004, Nonamespace found for prefix. Raised by fn:resolve-QName andanalagous functions if a supplied QName has a prefix that has nobinding to a namespace. err:FONS0005,Base-uri not defined in the static context. Raised by fn:resolve-uri if no base URIis available for resolving a relative URI. err:FORG0001,Invalid value for cast/constructor. A general-purpose error raised when casting, if a cast betweentwo data types is allowed in principle, but the supplied valuecannot be converted: for example when attempting to cast the string"nine" to an integer. err:FORG0002,Invalid argument to fn:resolve-uri(). Raised when either argument to fn:resolve-uri is not a validURI/IRI. err:FORG0003,fn:zero-or-one called with a sequence containing more than oneitem. Raised by fn:zero-or-one if the suppliedvalue contains more than one item. err:FORG0004,fn:one-or-more called with a sequence containing no items. Raised by fn:one-or-more if the suppliedvalue is an empty sequence. err:FORG0005,fn:exactly-one called with a sequence containing zero or more thanone item. Raised by fn:exactly-one if the suppliedvalue is not a singleton sequence. err:FORG0006,Invalid argument type. Raised by functions such as fn:max, fn:min, fn:avg, fn:sum if the supplied sequencecontains values inappropriate to this function. err:FORG0008, Thetwo arguments to fn:dateTime have inconsistent timezones. Raised by fn:dateTimeif the two arguments both have timezones and the timezones aredifferent. err:FORG0009, Errorin resolving a relative URI against a base URI infn:resolve-uri. A catch-all error for fn:resolve-uri, recognizingthat the implementation can choose between a variety of algorithmsand that some of these may fail for a variety of reasons. err:FORX0001,Invalid regular expression flags. Raised by regular expression functions such as fn:matches and fn:replace if the regularexpression flags contain a character other thanimsx err:FORX0002,Invalid regular expression. Raised by regular expression functions such as fn:matches and fn:replace if the regularexpression is syntactically invalid. err:FORX0003,Regular expression matches zero-length string. For functions such as fn:replace and fn:tokenize, raises an error ifthe supplied regular expression is capable of matching a zerolength string. err:FORX0004,Invalid replacement string. Raised by fn:replace toreport errors in the replacement string. err:FOTY0012,Argument to fn:data() contains a node that does not have a typedvalue. Raised by fn:data, or byimplicit atomization, if applied to a node with no typed value, themain example being an element validated against a complex type thatdefines it to have element-only content. err:FOTY0013, Theargument to fn:data() contains a function item. Raised by fn:data, or byimplicit atomization, if the sequence to be atomized contains afunction item. err:FOTY0014, Theargument to fn:string() is a function item. Raised by fn:string, orby implicit string conversion, if the input sequence contains afunction item. err:FOTY0015, Anargument to fn:deep-equal() contains a function item. Raised by fn:deep-equal if either inputsequence contains a function item. err:FOUT1170,Invalid $href argument to fn:unparsed-text() (etc.) A dynamic error is raised if the $hrefargument contains a fragment identifier, or if it cannot be used toretrieve a resource containing text. err:FOUT1190, Cannotdecode resource retrieved by fn:unparsed-text() (etc.) A dynamic error is raised if the retrieved resourcecontains octets that cannot be decoded into Unicode Â·charactersÂ· usingthe specified encoding, or if the resulting characters are notpermitted XML characters. This includes the case where theprocessor does not support the requested encoding. err:FOUT1200, Cannotinfer encoding of resource retrieved by fn:unparsed-text()(etc.) A dynamic error is raised if $encodingis absent and the processor cannot infer the encoding usingexternal information and the encoding is not UTF-8. C Illustrativeuser-written functions (Non-Normative) Certain functions that were proposed for inclusion in thisfunction library have been excluded on the basis that it isstraightforward for users to implement these functions themselvesusing XSLT 2.0 or XQuery 1.0. This Appendix provides sample implementations of some of thesefunctions. To emphasize that these functions are examples of functions thatvendors may write, their names carry the prefix 'eg'. Vendors arefree to define such functions in any namespace. A group of vendorsmay also choose to create a collection of such useful functions andput them in a common namespace. C.1eg:if-empty and eg:if-absent In some situations, users may want to provide default values formissing information that may be signaled by elements that areomitted, have no value or have the empty sequence as their value.For example, a missing middle initial may be indicated by omittingthe element or a non-existent bonus signaled with an emptysequence. This section includes examples of functions that providesuch defaults. These functions returnxs:anyAtomicType*. Users may want to write functionsthat return more specific types. C.1.1 eg:if-empty eg:if-empty($node as node()?,$value as xs:anyAtomicType) as xs:anyAtomicType* If the first argument is the empty sequence or an elementwithout simple or complex content, eg:if-empty()returns the second argument; otherwise, it returns the content ofthe first argument. XSLT implementation <xsl:function name="eg:if-empty" as="xs:anyAtomicType*">  <xsl:param name="node" as="node()?"/>  <xsl:param name="value" as="xs:anyAtomicType"/>  <xsl:sequence select="($node[child::node()], $value)[1]"/></xsl:function> XQuery implementation declare function eg:if-empty (  $node as node()?,  $value as xs:anyAtomicType) as xs:anyAtomicType* {  ($node[child::node()], $value)[1]}                    C.1.2 eg:if-absent eg:if-absent($node as node()?,$value as xs:anyAtomicType) as xs:anyAtomicType* If the first argument is the empty sequence,eg:if-absent() returns the second argument; otherwise,it returns the content of the first argument. XSLT implementation <xsl:function name="eg:if-absent" as="xs:anyAtomicType*">  <xsl:param name="node" as="node()?"/>  <xsl:param name="value" as="xs:anyAtomicType"/>  <xsl:sequence select="($node, $value)[1]"/></xsl:function> XQuery implementation declare function eg:if-absent (  $node as node()?,  $value as xs:anyAtomicType) as xs:anyAtomicType* {  ($node, $value)[1]}                    C.2 Union, intersection anddifference on sequences of values C.2.1eg:value-union eg:value-union( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* This function returns a sequence containing all the distinctitems in $arg1 and $arg2, in an arbitrary order. XSLT implementation <xsl:function name="eg:value-union" as="xs:anyAtomicType*">  <xsl:param name="arg1" as="xs:anyAtomicType*"/>  <xsl:param name="arg2" as="xs:anyAtomicType*"/>  <xsl:sequence     select="fn:distinct-values(($arg1, $arg2))"/> </xsl:function> XQuery implementation declare function eg:value-union (  $arg1 as xs:anyAtomicType*,  $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* {  fn:distinct-values(($arg1, $arg2))}                    C.2.2eg:value-intersect eg:value-intersect( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* This function returns a sequence containing all the distinctitems that appear in both $arg1 and $arg2, in an arbitraryorder. XSLT implementation> <xsl:function name="eg:value-intersect" as="xs:anyAtomicType*">  <xsl:param name="arg1" as="xs:anyAtomicType*"/>  <xsl:param name="arg2" as="xs:anyAtomicType*"/>  <xsl:sequence      select="fn:distinct-values($arg1[.=$arg2])"/></xsl:function> XQuery implementation declare function eg:value-intersect (  $arg1 as xs:anyAtomicType*,  $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* {  fn:distinct-values($arg1[.=$arg2])}                    C.2.3eg:value-except eg:value-except( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* This function returns a sequence containing all the distinctitems that appear in $arg1 but not in $arg2, in an arbitraryorder. XSLT implementation <xsl:function name="eg:value-except" as="xs:anyAtomicType*">  <xsl:param name="arg1" as="xs:anyAtomicType*"/>  <xsl:param name="arg2" as="xs:anyAtomicType*"/>  <xsl:sequence     select="fn:distinct-values($arg1[not(.=$arg2)])"/></xsl:function> XQuery implementation declare function eg:value-except (  $arg1 as xs:anyAtomicType*,  $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* {  fn:distinct-values($arg1[not(.=$arg2)])} C.3eg:index-of-node eg:index-of-node($seq as node()*, $search as node()) as xs:integer* This function returns a sequence of positive integers giving thepositions within the sequence $seq of nodes that areidentical to $search. The nodes in the sequence $seq are compared with$search under the rules for the isoperator. If a node compares identical, then the position of thatnode in the sequence $seq is included in theresult. If the value of $seq is the empty sequence, or ifno node in $seq matches $search, then theempty sequence is returned. The index is 1-based, not 0-based. The result sequence is in ascending numeric order. XSLT implementation <xsl:function name="eg:index-of-node" as="xs:integer*">  <xsl:param name="seq" as="node()*"/>  <xsl:param name="search" as="node()"/>  <xsl:sequence select="filter(      function($i as xs:integer) as xs:boolean {$seq[$i] is $search},       1 to count($seq)    )  "/></xsl:function> XQuery implementation declare function eg:index-of-node($seq as node()*, $search as node()) as xs:integer* {    fn:filter(      function($i as xs:integer) as xs:boolean {$seq[$i] is $search},       1 to fn:count($seq)    )} An alternative implementation, which might be faster in systemswhere indexing into a sequence is slow, is: declare function eg:index-of-node($seq as node()*, $search as node()) as xs:integer* {  fn:for-each-pair(function($node, $index) {     if($node is $search) then $index else ()   }, $seq, 1 to fn:count($seq))} C.4 eg:string-pad eg:string-pad($padString as xs:string?,$padCount as xs:integer) as xs:string Returns a xs:string consisting of a given number ofcopies of an xs:string argument concatenatedtogether. XSLT implementation <xsl:function name="eg:string-pad" as="xs:string">  <xsl:param name="padString" as="xs:string?"/>  <xsl:param name="padCount" as="xs:integer"/>  <xsl:sequence select="     fn:string-join(for $i in 1 to $padCount return $padString)"/> </xsl:function>                XQuery implementation declare function eg:string-pad (  $padString as xs:string?,  $padCount as xs:integer) as xs:string {   fn:string-join(for $i in 1 to $padCount return $padString)}                This returns the zero-length string if $padStringis the empty sequence, which is consistent with the generalprinciple that if an xs:string argument is the emptysequence it is treated as if it were the zero-length string. C.5 eg:distinct-nodes-stable eg:distinct-nodes-stable($arg as node()*) as node()* This function illustrates one possible implementation of adistinct-nodes function. It removes duplicate nodes by identity,preserving the first occurrence of each node. XPath $arg[empty(subsequence($arg, 1, position()-1) intersect .)]                XSLT implementation <xsl:function name="eg:distinct-nodes-stable" as="node()*">  <xsl:param name="arg" as="node()*"/>  <xsl:sequence select=""    fn:fold-left(      function($foundSoFar as node()*, $this as node()) as node()* {        if ($foundSoFar intersect $this)        then $foundSoFar        else ($foundSoFar, $this)      }, (), $seq)  "/> </xsl:function>                XQuery implementation declare function distinct-nodes-stable ($arg as node()*) as node()* {   fn:fold-left(      function($foundSoFar as node()*, $this as node()) as node()* {        if ($foundSoFar intersect $this)        then $foundSoFar        else ($foundSoFar, $this)      }, (), $seq)}; C.6 Findingminima and maxima The fn:min and fn:max functions allow one todetermine the smallest and largest values in a set of values, butthey do not directly allow one to determine the elements having thesmallest or largest value for some property, for example theemployees earning the highest or lowest salary. The functions inthis section show how this can be achieved. The functions take as input an arbitrary sequence of items(typically but not necessarily a sequence of elements) and afunction that computes a property value for each of these items.This must be a value of an atomic type for which order comparisonsare defined. The functions return those items from the inputsequence that have a higher (or lower) value for the given propertythan any others in the sequence. If there are several that arejoint highest (or lowest) then they are all returned. C.6.1 eg:highest The function eg:highest returns the items havingthe highest value for the supplied function. XSLT implementation <xsl:function name="eg:highest" as="item()*">  <xsl:param name="f" as="function(item()) as xs:anyAtomicType"/>  <xsl:param name="seq" as="item()*"/>  <xsl:sequence select="     fold-left(       function($highestSoFar as item()*, $this as item()*) as item()* {         let $thisValue := $f($this)         let $highestValue := $f($highestSoFar[1])         return           if ($thisValue gt $highestValue)             then $this           else if ($thisValue eq $highestValue)             then ($highestSoFar, $this)           else $highestSoFar       }, head($seq), tail($seq))"/></xsl:function> XQuery implementation declare function eg:highest(                     $f as function(item()) as xs:anyAtomicType,                      $seq as item()*)                  as item()* {     fn:fold-left(       function($highestSoFar as item()*, $this as item()*) as item()* {         let $thisValue := $f($this)         let $highestValue := $f($highestSoFar[1])         return           if ($thisValue gt $highestValue)             then $this           else if ($thisValue eq $highestValue)             then ($highestSoFar, $this)           else $highestSoFar       }, fn:head($seq), fn:tail($seq))}; To find the employees with the highest salary, the functionmight be called as: eg:highest(function($emp){$emp/salary}, //employee) C.6.2 eg:lowest The function eg:lowest returns the items having thelowest value for the supplied function. XSLT implementation <xsl:function name="eg:lowest" as="item()*">  <xsl:param name="f" as="function(item()) as xs:anyAtomicType"/>  <xsl:param name="seq" as="item()*"/>  <xsl:sequence select="     fold-left(       function($lowestSoFar as item()*, $this as item()*) as item()* {         let $thisValue := $f($this)         let $lowestValue := $f($lowestSoFar[1])         return           if ($thisValue lt $lowestValue)             then $this           else if ($thisValue eq $lowestValue)             then ($lowestSoFar, $this)           else $lowestSoFar       }, head($seq), tail($seq))"/></xsl:function> XQuery implementation declare function eg:highest(                     $f as function(item()) as xs:anyAtomicType,                      $seq as item()*)                  as item()* {     fn:fold-left(       function($lowestSoFar as item()*, $this as item()*) as item()* {         let $thisValue := $f($this)         let $lowestValue := $f($lowestSoFar[1])         return           if ($thisValue gt $lowestValue)             then $this           else if ($thisValue eq $lowestValue)             then ($lowestSoFar, $this)           else $lowestSoFar       }, fn:head($seq), fn:tail($seq))}; To find the employees with the lowest total number of hoursworked, the function might be called as: eg:lowest(function($emp){sum($emp/timesheet/period/hours}, //employee) C.7 Sorting Both XSLT and XQuery include constructs for sorting sequences.However, it can often be convenient to invoke sorting via a simplefunction call. The example function in this section takes twoarguments, a sequence to be sorted, and a function to compute asort key, and it returns the items from the input sequence insorted order of this sort key. XSLT implementation <xsl:function name="eg:sort" as="item()*">  <xsl:param name="f" as="function(item()) as xs:anyAtomicType"/>  <xsl:param name="seq" as="item()*"/>  <xsl:perform-sort select="$seq">    <xsl:sort select="$f(.)"/>  </xsl:perform-sort></xsl:function> XQuery implementation declare function eg:sort(                     $f as function(item()) as xs:anyAtomicType,                      $seq as item()*)                  as item()* {     for $item in $seq order by $f($item) return $item}; To obtain a list of employees sorted by salary, the functionmight be called as: eg:sort(function($emp){$emp/salary}, //employee) D Checklist ofimplementation-defined features (Non-Normative) It is Â·implementation-definedÂ· which version of Unicode is supported, but itis recommended that the most recent version of Unicode be used.(See Conformance.) It is Â·implementation-definedÂ· whether the type system is based on XML Schema1.0 or XML Schema 1.1. (See Conformance.) It is Â·implementation-definedÂ· which version of [TheUnicode Standard] is supported, but it is recommended that themost recent version of Unicode be used. (See Strings, characters, andcodepoints.) Some functions (such as fn:distinct-values andfn:unordered) produceresults in an Â·implementation-definedÂ· or Â·implementation-dependentÂ· order. In such cases there is no guaranteethat the order of results from different calls will be the same.These functions are said to be non-deterministic with respect toordering. (See Properties offunctions.) Where the results of a function are described as being (to agreater or lesser extent) Â·implementation-definedÂ· or Â·implementation-dependentÂ·, this does not by itself remove therequirement that the results should be deterministic: that is, thatrepeated calls with the same explicit and implicit argumentsmust return identical results. (See Properties of functions.) In the case of a document node $D returned by thefn:doc function, or a documentnode at the root of a tree containing a node returned by thefn:collection function,it will always be true that either fn:document-uri($D)returns the empty sequence, or that the following expression istrue: fn:doc(fn:document-uri($D)) is$D. It is Â·implementation-definedÂ· whether this guarantee also holds for documentnodes obtained by other means, for example a document node passedas the initial context node of a query or transformation. (Seefn:document-uri.) In addition, the values of $value, converted to anxs:string, and $labelmay be directed to a trace data set. Thedestination of the trace output is Â·implementation-definedÂ·. The format of the trace output is Â·implementation dependentÂ·. The ordering of output from calls of thefn:trace function is Â·implementation dependentÂ·. (See fn:trace.) They Â·mayÂ· provide anÂ·implementation-definedÂ· mechanism that allows users to choose betweenraising an error and returning a result that is modulo the largestrepresentable integer value. See [ISO10967]. (See Arithmetic operators onnumeric values.) For xs:decimal values the number of digits ofprecision returned by the numeric operators is Â·implementation-definedÂ·. If the number of digits in the result exceedsthe number of digits that the implementation supports, the resultis truncated or rounded in an Â·implementation-definedÂ· manner. (See Arithmeticoperators on numeric values.) For xs:decimal values the number of digits ofprecision returned by the numeric operators is Â·implementation-definedÂ·. If the number of digits in the result exceedsthe number of digits that the implementation supports, the resultis truncated or rounded in an Â·implementation-definedÂ· manner. (See Arithmeticoperators on numeric values.) The [IEEE 754-2008] specificationalso describes handling of two exception conditions calleddivideByZero and invalidOperation. TheIEEE divideByZero exception is raised not only by adirect attempt to divide by zero, but also by operations such aslog(0). The IEEE invalidOperationexception is raised by attempts to call a function with an argumentthat is outside the function's domain (for example,sqrt(-1) or log(-1). These IEEEexceptions do not cause a dynamic error at the application level;rather they result in the relevant function or operator returningNaN. The underlying IEEE exceptionmay be notified to the application or to the userby some Â·implementation-definedÂ· warning condition, but the observable effecton an application using the functions and operators defined in thisspecification is simply to return NaN with no error.(See Arithmetic operators on numericvalues.) The [IEEE 754-2008] specificationdistinguishes two NaN values, a quiet NaN and a signaling NaN.These two values are not distinguishable in the XDM model: thevalue spaces of xs:float and xs:doubleeach include only a single NaN value. This does notprevent the implementation distinguishing them internally, andtriggering different Â·implementation-definedÂ· warning conditions, but such distinctions donot affect the observable behavior of an application using thefunctions and operators defined in this specification. (SeeArithmetic operators on numericvalues.) The implementation may adopt a different algorithm provided thatit is equivalent to this formulation in all cases where Â·implementation-dependentÂ· or Â·implementation-definedÂ· behavior does not affect the outcome, forexample, the implementation-defined precision of the result ofxs:decimal division. (See op:numeric-integer-divide.) XSD 1.1 allows the string +INF as a representationof positive infinity; XSD 1.0 does not. It is Â·implementation-definedÂ· whether XSD 1.1 is supported. (See fn:number.) Any other format token, which indicates a numbering sequence inwhich that token represents the number 1 (one) (but see the notebelow). It is Â·implementation-definedÂ· which numbering sequences, additional to thoselisted above, are supported. If an implementation does not supporta numbering sequence represented by the given token, itmust use a format token of 1. (Seefn:format-integer.) For all format tokens other than the first kind above (one thatconsists of decimal digits), there may beÂ·implementation-definedÂ· lower and upper bounds on the range of numbersthat can be formatted using this format token; indeed, for somenumbering sequences there may be intrinsic limits. For example, theformat token &#x2460; (circled digit one, â‘ ) has arange imposed by the Unicode character repertoire â€” 1 to 20in Unicode versions prior to 4.0, increased in subsequentversions. For the numbering sequences described above anyupper bound imposed by the implementation must notbe less than 1000 (one thousand) and any lower bound must not begreater than 1. Numbers that fall outside this rangemust be formatted using the format token1. (See fn:format-integer.) The set of languages for which numbering is supported isÂ·implementation-definedÂ·. If the $lang argument is absent,or is set to an empty sequence, or is invalid, or is not a languagesupported by the implementation, then the number is formatted usingthe default language from the dynamic context. (Seefn:format-integer.) ...either a or t, to indicatealphabetic or traditional numbering respectively, the default beingÂ·implementation-definedÂ·. (See fn:format-integer.) It is Â·implementation-definedÂ· what combinations of values of the formattoken, the language, and the cardinal/ordinal modifier aresupported. If ordinal numbering is not supported for thecombination of the format token, the language, and the stringappearing in parentheses, the request is ignored and cardinalnumbers are generated instead. (See fn:format-integer.) The use of the a or tmodifier disambiguates between numbering sequences that useletters. In many languages there are two commonly used numberingsequences that use letters. One numbering sequence assigns numericvalues to letters in alphabetic sequence, and the other assignsnumeric values to each letter in some other manner traditional inthat language. In English, these would correspond to the numberingsequences specified by the format tokens a andi. In some languages, the first member of eachsequence is the same, and so the format token alone would beambiguous. In the absence of the a ort modifier, the default is Â·implementation-definedÂ·. (See fn:format-integer.) The static context provides a set of decimal formats. One of thedecimal formats is unnamed, the others (if any) are identified by aQName. There is always an unnamed decimal format available, but itscontents are Â·implementation-definedÂ·. (See Defining a decimal format.) IEEE states that the preferred quantum is language-defined. Inthis specification, it is Â·implementation-definedÂ·. (See Trigonometricand exponential functions.) IEEE defines various rounding algorithms for inexact results,and states that the choice of rounding direction, and themechanisms for influencing this choice, are language-defined. Inthis specification, the rounding direction and any mechanisms forinfluencing it are Â·implementation-definedÂ·. (See Trigonometricand exponential functions.) Because the set of collations that are supported is Â·implementation-definedÂ·, an implementation has the option to supportall collation URIs, in which case it will never raise this error.(See Choosing a collation.) Conforming implementations must supportnormalization form "NFC" and may supportnormalization forms "NFD", "NFKC", "NFKD", and "FULLY-NORMALIZED".They may also support other normalization formswith Â·implementation-definedÂ· semantics. (See fn:normalize-unicode.) It is possible to define collations that do not have the abilityto decompose a string into units suitable for substring matching.An argument to a function defined in this section may be a URI thatidentifies a collation that is able to compare two strings, butthat does not have the capability to split the string intocollation units. Such a collation may cause the function to fail,or to give unexpected results or it may be rejected as anunsuitable argument. The ability to decompose strings intocollation units is an Â·implementation-definedÂ· property of the collation. (See Functions based on substringmatching.) All minimally conforming processors Â·mustÂ· supportpositive year values with a minimum of 4 digits (i.e., YYYY) and aminimum fractional second precision of 1 millisecond or threedigits (i.e., s.sss). However, conforming processorsÂ·mayÂ· set largerÂ·implementation-definedÂ· limits on the maximum number of digits theysupport in these two situations. Processors Â·mayÂ· also choose to support the year 0000 and yearswith negative values. The results of operations on dates that crossthe year 0000 are Â·implementation-definedÂ·. (See Limits and precision.) All minimally conforming processors Â·mustÂ· supportpositive year values with a minimum of 4 digits (i.e., YYYY) and aminimum fractional second precision of 1 millisecond or threedigits (i.e., s.sss). However, conforming processorsÂ·mayÂ· set largerÂ·implementation-definedÂ· limits on the maximum number of digits theysupport in these two situations. Processors Â·mayÂ· also choose to support the year 0000 and yearswith negative values. The results of operations on dates that crossthe year 0000 are Â·implementation-definedÂ·. (See Limits and precision.) ...the format token n, N, orNn, indicating that the value of the component is tobe output by name, in lower-case, upper-case, or title-caserespectively. Components that can be output by name include (butare not limited to) months, days of the week, timezones, and eras.If the processor cannot output these components by name for thechosen calendar and language then it must use an Â·implementation-definedÂ· fallback representation. (See The picture string.) ...indicates alphabetic or traditional numbering respectively,the default being Â·implementation-definedÂ·. This has the same meaning as in the secondargument of fn:format-integer. (SeeThe picture string.) A format token consisting of a single digit, such as1, does not constrain the number of digits in theoutput. In the case of fractional seconds in particular,[f001] requests three decimal digits,[f01] requests two digits, but [f1] willproduce an Â·implementation-definedÂ· number of digits. If exactly one digit isrequired, this can be achieved using the component specifier[f1,1-1]. (See Thepicture string.) The set of languages, calendars, and places thatare supported in the Â·date formatting functionsÂ· is Â·implementation-definedÂ·. When any of these arguments is omitted or isan empty sequence, an Â·implementation-definedÂ· default value is used. (See The language, calendar, and placearguments.) The set of languages, calendars, and places thatare supported in the Â·date formatting functionsÂ· is Â·implementation-definedÂ·. When any of these arguments is omitted or isan empty sequence, an Â·implementation-definedÂ· default value is used. (See The language, calendar, and placearguments.) The choice of the names and abbreviations used in any givenlanguage is Â·implementation-definedÂ·. For example, one implementation mightabbreviate July as Jul while another usesJly. In German, one implementation might representSaturday as Samstag while another usesSonnabend. Implementations mayprovide mechanisms allowing users to control such choices. (SeeThe language, calendar, and placearguments.) The choice of the names and abbreviations used in any givenlanguage for calendar units such as days of the week and months ofthe year is Â·implementation-definedÂ·. (See The language,calendar, and place arguments.) The calendar value if present must be a validEQName (dynamic error: [err:FOFD1340]). Ifit is a lexical QName then it is expanded into anexpanded QName using the statically known namespaces;if it has no prefix then it represents an expanded-QName in nonamespace. If the expanded QName is in no namespace, then itmust identify a calendar with a designatorspecified below (dynamic error: [err:FOFD1340]). If the expandedQName is in a namespace then it identifies the calendar in anÂ·implementation-definedÂ· way. (See Thelanguage, calendar, and place arguments.) At least one of the above calendars must besupported. It is Â·implementation-definedÂ· which calendars are supported. (See The language, calendar, and placearguments.) Various aspects of this processing are Â·implementation-definedÂ·. Implementations may provide externalconfiguration options that allow any aspect of the processing to becontrolled by the user. In particular:... (See fn:doc.) It is Â·implementation-definedÂ· whether DTD validation and/or schemavalidation is applied to the source document. (See fn:doc.) By default, this function is Â·deterministicÂ·. This means that repeated calls on thefunction with the same argument will return the same result.However, for performance reasons, implementations may provide auser option to evaluate the function without a guarantee ofdeterminism. The manner in which any such option is provided isÂ·implementation-definedÂ·. If the user has not selected such an option,a call to this function must either return a deterministic resultor must raise a dynamic error [err:FODC0003]. (See fn:collection.) ...the processor may use Â·implementation-definedÂ· heuristics to determine the likely encoding,otherwise... (See fn:unparsed-text.) The fact that the resolution of URIs is defined by a mapping inthe dynamic context means that in effect, various aspects of thebehavior of this function are Â·implementation-definedÂ·. Implementations may provide externalconfiguration options that allow any aspect of the processing to becontrolled by the user. In particular:... (See fn:unparsed-text.) The collation used for matching names is Â·implementation-definedÂ·, but must be the same as the collation used toensure that the names of all environment variables are unique. (Seefn:environment-variable.) The precise process used to construct the XDM instance isÂ·implementation-definedÂ·. In particular, it is implementation-definedwhether DTD and/or schema validation is invoked, and it isimplementation-defined whether an XML 1.0 or XML 1.1 parser isused. (See fn:parse-xml.) The precise process used to construct the XDM instance isÂ·implementation-definedÂ·. In particular, it is implementation-definedwhether an XML 1.0 or XML 1.1 parser is used. (See fn:parse-xml-fragment.) If the arguments to fn:function-lookup identify afunction that is present in the static context of the functioncall, the function will always return the same function that astatic reference to this function would bind to. If there is nosuch function in the static context, then the results depend onwhat is present in the dynamic context, which is Â·implementation-definedÂ·. (See fn:function-lookup.) If ST is xs:float orxs:double, then TV is thexs:decimal value, within the set ofxs:decimal values that the implementation is capableof representing, that is numerically closest to SV. If twovalues are equally close, then the one that is closest to zero ischosen. If SV is too large to be accommodated as anxs:decimal, (see [XML SchemaPart 2: Datatypes Second Edition] for Â·implementation-definedÂ· limits on numeric values) adynamic error is raised [err:FOCA0001]. If SV is one of thespecial xs:float or xs:double valuesNaN, INF, or -INF, adynamic error is raised [err:FOCA0002]. (See Casting to xs:decimal.) If ST is xs:decimal, xs:floator xs:double, then TV is SV with thefractional part discarded and the value converted toxs:integer. Thus, casting 3.1456 returns3 and -17.89 returns -17.Casting 3.124E1 returns 31. IfSV is too large to be accommodated as an integer, (see[XML Schema Part 2: Datatypes SecondEdition] for Â·implementation-definedÂ· limits on numeric values) adynamic error is raised [err:FOCA0003]. If SV is one of thespecial xs:float or xs:double valuesNaN, INF, or -INF, adynamic error is raised [err:FOCA0002]. (See Casting to xs:integer.) In casting to xs:decimal or to a type derived fromxs:decimal, if the value is not too large or too smallbut nevertheless cannot be represented accurately with the numberof decimal digits available to the implementation, theimplementation may round to the nearest representable value or mayraise a dynamic error [err:FOCA0006]. The choice of rounding algorithmand the choice between rounding and error behavior and is Â·implementation-definedÂ·. (See Castingfrom xs:string and xs:untypedAtomic.) The tz timezone database, available at http://www.twinsun.com/tz/tz-link.htm.It is Â·implementation-definedÂ· which version of the database is used. (SeeOlson Timezone Database.) The Unicode Consortium, Reading, MA, Addison-Wesley, 2003.The Unicode Standard as updated from time to time by thepublication of new versions. See http://www.unicode.org/standard/versions/for the latest version and additional information on versions ofthe standard and of the Unicode Character Database. The version ofUnicode to be used is Â·implementation-definedÂ·, but implementations are recommended to usethe latest Unicode version; currently, Version 6.0.0. (See The Unicode Standard.) Unicode Standard Annex #15, Unicode Normalization Forms.Available at: http://www.unicode.org/reports/tr15/.As with [The Unicode Standard], the versionto be used is Â·implementation-definedÂ·. (See UnicodeNormalization Forms.) E Changes since previousRecommendation (Non-Normative) E.1 Substantive changes (15December 2009) In the Working Draft of 15 December 2009, the following changeswere made relative to the first edition of the Functions andOperators specification for XPath 2.0 and XQuery 1.0 published on23 January 2007: Errata E1 through E47 were applied. A two-argument version of the fn:round function was introduced.(Bugzilla 6240) A single-argument version of the fn:string-join function wasintroduced. Specifications for the functions fn:format-date, fn:format-time, and fn:format-dateTime weretransferred from the XSLT 2.0 specification. The specification of fn:format-number wastransferred from the XSLT specification. A function fn:format-integer wasintroduced. The function fn:generate-id was introduced,transferred from the XSLT specification. A range of trigonometric functions was defined (in a newnamespace). New functions fn:parse-xml and fn:serialize were defined. (Thefn:parse function was subsequently renamed fn:parse-xml A new function fn:analyze-string wasdefined. The syntax of regular expressions was extended to allownon-capturing groups. A new flag was introduced for the $flags argumentof functions that use regular expressions: the q flagcauses all characters in a regular expression to be treated asordinary characters rather than metacharacters. Supporting the new language feature of higher-order functions, anumber of functions were defined that operate on function items astheir arguments: fn:map (subsequently renamed fn:for-each), fn:filter,fn:map-pairs (subsequently renamed fn:for-each-pair), fn:fold-left, fn:fold-right. The functionfn:partial-apply, however, which was introduced in theprevious version of this Working Draft, has now been dropped infavor of custom syntax for partial application using "?" as aplace-holder for missing arguments. The description of the fn:error function was rewritten toallow for the introduction of try/catch facilities into XQuery andXSLT. The section describing what it means for functions to becontextual and/or deterministic was rewritten. The termdeterministic has replaced stable. E.2 Substantive changes (18June 2012) In the Last Call Working Draft of 18 June 2012, the followingsubstantive changes are made relative to the draft of 15 December2009: The version number of the specification is changed from 1.1 to3.0. New functions math:exp, math:exp10, math:log, math:log10, math:atan2, and math:pow are defined. Thetrigonometric and exponential functions are now specified byreference to [IEEE 754-2008]. In the rules for fn:format-dateTime andrelated functions, the rules for formatting of timezones have beenexpanded and clarified; the $country argument isrenamed $place, and its value may now be an Olsontimezone name. The rules for the fn:normalize-unicodefunction are now defined directly by reference to the Unicodespecifications rather than the W3C Working Draft on the CharacterModel for the World Wide Web (which never progressed beyond WorkingDraft status). The rules for the normalization formFULLY_NORMALIZED are now defined normatively in thisspecification. The syntax for the picture string used by fn:format-integer has beenextended to allow grouping positions to be associated with optionaldigit positions. Two convenience functions fn:head and fn:tail are added, reflecting theincreased role played by head-tail recursive functions when writingcode to take advantage of higher-order functions. The function fn:partial-apply has been removed, asthis functionality is now provided by custom syntax (partialfunction application, using "?" as a placeholder for missingarguments). New functions fn:function-name, fn:function-arity, andfn:function-lookupare available. A new function fn:parse-xml-fragmentwas introduced. (This change went unremarked in the change log upto and including the Candidate Recommendation of 8 January2013.) Casting from a dynamic string to an xs:QName or atype derived from xs:NOTATION is now permitted (therestriction that the argument must be a string literal has beenremoved). (Bug 9183) Zero-argument forms have been introduced for the functionsfn:data, fn:document-uri, and fn:node-name, fn:base-uri, fn:nilled, and fn:has-children, with theargument defaulting to the context item in each case. (Bug9571) The new function fn:parse is renamed fn:parse-xml. (Bug 9751) The rules for handling of negative zero have been clarified.Where operations return negative zero, then in generalimplementations must respect this; the only exception is forcasting from string to float or double, where the lexical form-0 may result in positive zero forcompatibility with existing XML Schema 1.0 processors. (Bug9907) The functions fn:unparsed-text andfn:unparsed-text-availablehave been transferred unchanged from XSLT 2.0. (Bug 9067), andfn:unparsed-text-lineshas been transferred from the XSLT 2.1 draft. The function fn:uri-collection has beenadded. This was originally defined as an output of the work onstreaming in XSLT 3.0; its purpose is to give applications greatercontrol of the processing of individual documents within a largecollection. The rules for the fn:resolve-uri function havebeen rewritten to refer to more up-to-date specifications,specifically the IRI and LEIRI specifications. Implementations arerequired to support the IRI syntax as a minimum, and are permittedto support the legacy extensions defined in LEIRI. Two new functions fn:environment-variableand fn:available-environment-variableshave been defined. Casting from a string or xs:untypedAtomic value toa union or list type is now allowed. References to the Formal Semantics have been removed. Rules for the precision of the results of trigonometric andexponential functions have been removed, and replaced with anormative reference to the rules in the IEEE specifications. The functions fn:unparsed-text-lines,fn:has-children,fn:innermost andfn:outermost have beentransferred from the XSLT 3.0 working draft. The function fn:path hasbeen added. References to IEEE 754-1985 (to define the semantics ofoperations on 32-bit and 64-bit floating point) have been updatedto refer to IEEE 754-2008. The error codes produced by fn:collection have beenclarified, possibly involving incompatible changes. In regular expressions (without the "m" option) themeta-character "." now matches everything except x0A and x0D.Previously it was defined to match everything except x0A, which wasan unnecessary and unintended incompatibility with regularexpressions in XSD. E.3 Substantive changes(Candidate Recommendation) In this Candidate Recommendation, the following substantivechanges are made relative to the Last Call Working Draft draft of18 June 2012: Functions with dependencies on the static or dynamic context cannow be bound to function items (for example, by the use of fn:function-lookup), andthe rules for doing so have been clarified. The specification of fn:format-integer makes amore precise distinction between situations where the processormust report an error in the supplied picture, and situations whereit must adopt a fallback representation. The conditions under which the static base URI used duringstatic analysis can differ from the base URI used during evaluationare now more clearly and consistently described. The concept ofdynamic base URI is dropped. The syntax for regular expressions is now described by referenceto the XSD 1.1 specification as well as the XSD 1.0 specification.(XSD 1.1 gives a much clearer exposition of the syntax andsemantics of regular expressions without introducing any intendedchanges to the functionality.) Some edge cases for capturing subgroups in regular expressionsare described. The role of the schema for the data returned by fn:analyze-string is moreclearly defined. In the result of fn:path,dependencies on the default namespace for functions have beenremoved, by ensuring that any function calls in the return path usefully-qualified names. In the specification of fn:deep-equal, the consequencesof the existing rules for comparing validated against unvalidatedtrees are more carefully explained. The rules for the fn:unparsed-text functionhave been expressed at a higher level of abstraction, using thecontext in the same way as the fn:doc function, and making use ofconcepts such as the distinction in web architecture between aresource and its representation. A number of rules have been added, which were previouslyomitted, concerning casts and constructors where the target type isa union or list type. E.4 Substantive changes (postCandidate Recommendation) The following changes were made subsequent to the CandidateRecommendation of 8 January 2013: The functions fn:map and fn:map-pairsare renamed fn:for-eachand fn:for-each-pairrespectively. This change is made to remove the risk of potentialconfusion and syntactic conflicts if and when a map data type isadded to the language, as proposed in the current XSLT 3.0 WorkingDraft. (Bug 21128). The arguments of the functions fn:for-each and fn:for-each-pair, fn:filter, fn:fold-left, and fn:fold-right are re-ordered.This change has been made in the interests of usability andconsistency with other functions. (Bug 21797). The regular expression matching the format modifier in thepicture string supplied to fn:format-integer has beencorrected to match the accompanying prose. (Bug 19004). The function signature for the xs:QName constructorfunction has been corrected to show that the supplied value may bean empty sequence (the error arose because in XPath 2.0, thisconstructor was a special case, requiring that the suppliedargument be an string literal). (Bug 20856) The function signature for the fn:adjust-dateTime-to-timezonefunction has been corrected to show that the returned value may bean empty sequence, making the signature consistent with the prosedescription and with the XPath 2.0/XQuery 1.0 version of thespecification. (Bug 20850) The $calendar argument of functions in the fn:format-date family may nowbe an EQName for consistency, and the error conditionsfor the arguments to these functions are more clearly spelled out.(Bug 21284). A section has been added to describe the constructor functionxs:error present in implementations that support XSD1.1. The existence of such a function is a consequence of generalrules included in the published Candidate Recommendation, but thefunction was not listed along with other constructor functions forbuilt-in XSD types. (Bug 20634). A paragraph has been added explaining how to interpret theweek-in-month (w) component for the fn:format-date family offunctions in the case where the chosen calendar is the ISOcalendar. (Bug 21370). It is now stated that it is an error in a regular expression touse a Unicode block name which is not defined in the version(s) ofUnicode supported by the processor. This differs from the treatmentof this condition in XSD 1.1. (Bug 20575). Error conditions are now properly categorized as type errors ordynamic errors, and in particular where the error conditionXPDY0002 was previously categorized as a type errorthis has been corrected. (Bug 21315). It is now stated that failure to cast to a union type is alwaysa dynamic error, not a type error. (Bug 21766) It is now noted that the 5-argument versions of the functionsfn:format-date,fn:format-dateTime, andfn:format-time aredependent on the namespaces in the static context, since thecalendar argument is a lexical QName. (Bug 22395) The rules for the use of fn:function-lookup whenapplied to context-dependent built-in functions have beenclarified. The intent of the rules is unchanged, but they have beenexplained more carefully to prevent possible misinterpretation.(Bug 22732) E.5Editorial changes The following editorial changes have been made since the firstedition of the Functions and Operators specification for XPath 2.0and XQuery 1.0 published on 23 January 2007. These are notexplicitly marked in the change-highlighted version of thespecification: References to the Formal Semantics (which in nearly all caseswere references to detailed rules for static type inferencing) havebeen removed, as the Formal Semantics is not being maintained. (Bug9056) A quick reference section containing links to the functions hasbeen added before the full table of contents. The end-of-documentindexes have been dropped in this draft (any readers disappointedby this decision are invited to make representations to the editor,since they can easily be re-instated). The section on constructor functions has been moved so that itis now adjacent to the closely-related section on casting. The function fn:dateTime has been moved out ofthe section describing constructor functions, and is no longerdescribed as "a special constructor function". It is now anordinary function described in the appropriate section along withother functions on dates and times. This allows the term"constructor function" to be associated exclusively withsingle-argument functions whose name is the same as the type nameof the value that they return, and avoids any suggestion that thisfunction has special behavior. Similarly, the functions fn:true and fn:false are no longer described asconstructor functions. Where a function is referred to by name, the reference is nowalways in the form (for example) fn:base-uri rather than fn:base-uri(). The latter form isused only to indicate a call on the function in which no argumentsare supplied. The specification of each function now consists of a set ofstandard subsections: Summary, Operator Mapping, Signature,Properties, Rules, Error Conditions, Notes, and Examples. The "Summary" of the effect of each function is now just that:it never contains any information that cannot be found in the moredetailed rules, and it does not attempt to list unusual or errorconditions. Such rules have been moved into separate paragraphs.Sometimes the language used in the summary is relatively informal.Although the summary remains normative, it must be regarded asbeing subservient to the rules that follow. Functions are always called, neverinvoked. The specification no longer discusses functions, it nowspecifies or defines them. A seperate section for each function now lists the properties ofthe function: whether or not it is deterministic,context-dependent, or focus-dependent. These properties are linkedto their definitions. Rules have been rewritten in a more consistent style: "If$arg is X, the function returns Y" (avoidingalternatives such as "Returns Y if $arg is X", andavoiding the passive "is returned"). In nearly all cases thelanguage used for error conditions has been standardized to theform "An error is raised [code] if ...". The section heading for a section that defines a function is nowalways the name of the function. Some function definitions havebeen moved into subsections to achieve this. Statements within the rules of a function that follow inevitablyfrom other rules have in many cases been downgraded to notes. Anexample is the statement that fn:remove($seq, N) returns an emptysequence if $seq is an empty sequence. The functions for durations and those for dates/times have beensplit into separate sections. The fn:boolean functionhas been moved from "General Functions and Operators on Sequences"to "Functions on Boolean Values". In the interests of automating the testing of examples, theconvention has been adopted that the result of an exampleexpression is wherever possible given in the form of a simple XPathexpression. Specifically a numeric or string literal is used fornumbers and strings; the expressions true() andfalse() for booleans; constructors such asxs:duration('PT0S') for other atomic types;expressions such as (1, 2, 3, 4) for sequences. Theexpression will always return a value of the correct type; so thexs:double value zero is shown as 0.0e0,not as 0, which is the way the value would beserialized on output. The value NaN is given asxs:double('NaN'). Previously results were sometimesgiven in this form, sometimes in the form of a serialization of theresult value, and sometimes (particularly for dates, times, anddurations) in the form of an informal description. In some cases where one function can be readily specified interms of another, the opportunity has been taken to simplify thespecification. For example, all the operator support functions ofthe form op:xx-greater-than are now specified byreference to the corresponding op:xx-less-thanfunction with the arguments reversed. This reduces the risk ofintroducing errors and inconsistencies. In some cases, the rules for a function have been reordered. Forexample, the rule describing how an empty sequence is handled nowgenerally comes before any rule that works only if the argument isnot an empty sequence. Some non-normative examples and notes have been added. The non-normative example functions in Appendix D have beenrevised, and new functions are supplied to illustrate use cases forhigher-order functions. The appendix describing error codes gives more information. The checklist of implementation-defined features is nowautomatically aligned with the text. E.6Changes since the Proposed Recommendation The following changes are made subsequent to the ProposedRecommendation of 22 October 2013. These are all minor editorialchanges. Further details can be found in the referenced W3CBugzilla entries. Bug24228: a trivial copy-edit in the description of errorFODC0002. Bug24384: a couple of trivial copy-edits in the description offn:unparsed-text-lines; plus a non-normative note toclarify the relationship betweenfn:unparsed-text-available andfn:unparsed-text-lines. Bug24385: removed a possible ambiguity in the text, to clarify howfn:unparsed-text-lines handles a newline at the end ofthe input file. Bug24646: clarified the definition of Â·deterministicÂ· tolink it explicitly to the definition of Â·execution scopeÂ·;the linkage of the terms was previously implicit. Bug24689: where appropriate, references to other specificationshave been updated to refer to the latest version. Bug24742: an incompatibility relating to regular expressions waslisted in the wrong part of F.2Compatibility between XPath 3.0 and XPath 2.0. FCompatibility with Previous Versions (Non-Normative) This section summarizes the extent to which this specificationis compatible with previous versions. It describes first the incompatibilities between XPath 1.0 andXPath 2.0 (or XQuery 1.0), then the incompatibilities between XPath2.0 (or XQuery 1.0) and XPath/XQuery 3.0. F.1 Compatibility between XPath 2.0 andXPath 1.0 Note: XPath 2.0 and XQuery 1.0 were aligned, so all referencesto XPath 2.0 in this section apply equally to XQuery 1.0. This appendix summarizes the relationship between certainfunctions defined in [XML Path Language (XPath)Version 1.0] and the corresponding functions defined in thisdocument. The first column of the table provides the name of thefunction. The second column describes the differences in thesemantics of the corresponding functions. The functions appear inthe order they appear in [XML Path Language(XPath) Version 1.0]. A more detailed version of this information can be found in[XQuery 1.0 and XPath 2.0 Functions andOperators]. This appendix does not include incompatibilities that arisesolely from the change in function calling rules that occurredbetween XPath 1.0 and XPath 2.0, that is, incompatibilities thatcan be avoided by ensuring that XPath 1.0 compatibility mode isenabled. For example, in XPath 1.0 the fn:name function when applied to asequence of three nodes would return the name of the first (indocument order); in XPath 2.0 and XPath 3.0 such a call is a typeerror, unless XPath 1.0 compatiblity mode is enabled. Similarly,functions such as fn:substring, fn:contains, and fn:translate that expect stringarguments will raise a type error in XPath 2.0 if called with aboolean or numeric argument, unless XPath 1.0 compatibility mode isenabled. A more complete list of these incompatibilities can befound in [XQuery 1.0 and XPath 2.0Functions and Operators]. In addition, this appendix does not include incompatibilitiesthat arise when the default collation is set to something otherthan Unicode codepoint collation. This appendix does not include incompatibilities that mightarise due to XPath 2.0 defining the specification with greaterclarity or precision. For example, an implementation of fn:sum in XPath 1.0 that returnedNaN when given an empty node-set as the argument wouldnot have contradicted any explicit statement in the specification,while XPath 2.0 is explicit that the expected result in this caseis zero. Function Notes fn:last Because the result is an integer rather than a double, theprecision of subsequent computations may be different. fn:position Because the result is an integer rather than a double, theprecision of subsequent computations may be different. fn:count Because the result is an integer rather than a double, theprecision of subsequent computations may be different. fn:id XPath 2.0 raises a type error with boolean and numericarguments. The rules for recognizing a node as an id value changed.In XPath 1.0 the whole string is treated as a unit, while in XPath2.0 each string is treated as a list. fn:name The rules for determining the prefix are more precisely definedin [XML Path Language (XPath) 2.0]. fn:string Representations of numeric values are XPath 1.0 compatibleexcept for the special values positive and negative infinity, andfor values outside the range 1.0e-6 to 1.0e+6. fn:string-length Because the result is an integer rather than a double, theprecision of subsequent computations may be different. fn:sum XPath 2.0 raises an error if the sequence contains values thatcannot be added together, such as strings. XPath 1.0 returnsNaN. fn:floor In XPath 2.0, if the argument is (), the result is(). In XPath 1.0, the result is NaN. fn:ceiling In XPath 2.0, if the argument is (), the result is(). In XPath 1.0, the result is NaN. fn:round In XPath 2.0, if the argument is (), the result is(). In XPath 1.0, the result is NaN. F.2 Compatibility between XPath 3.0 andXPath 2.0 Note: XPath 2.0 and XQuery 1.0 were aligned, and XPath 3.0 andXQuery 3.0 are aligned. So all references to XPath 2.0 in thissection apply equally to XQuery 1.0, and all references to XPath3.0 apply equally to XQuery 3.0. The only incompatibilities between this version of thespecification and the version that applied to XPath 2.0 and XQuery1.0 are: Clarifications where this version of the specification describesthe intended behavior more precisely. Such clarifications have beenmade mainly to the description of functions that have significantinteractions with the processing environment: examples are fn:resolve-uri, fn:collection, and fn:doc. In regular expressions (without the "m" option) themeta-character "." now matches everything except x0A and x0D.Previously it was defined to match everything except x0A, which wasan unnecessary and unintended incompatibility with regularexpressions in XSD. (Note that x0D rarely appears in XML documents,because it is ordinarily removed by the process of normalizing lineendings.) Some functions appearing in this specification previouslyappeared as part of the specification of XSLT 2.0.Incompatibilities applying to these functions are as follows: The rules for timezone formatting using the [Z] component in thesecond argument of fn:format-date, fn:format-dateTime, andfn:format-time werepreviously very unclear, and have been completely revised. The newrules are likely to be different from the interpretation adopted byparticular XSLT 2.0 processors. Error codes have been changed to fit with the coding scheme usedin this specification. (Note however, that in XSLT 2.0 there was nointeroperable way of testing error codes, and the specificationexplicitly made the error codes non-normative.)