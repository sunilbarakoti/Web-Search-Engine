XML Schema Datatypes RDF OWL XML Schema Datatypes RDF OWL W3C Working Group Note March version: http://www.w3.org/TR/2006/NOTE-swbp-xsch-datatypes-20060314/ Latest version: http://www.w3.org/TR/swbp-xsch-datatypes/ Previous version: http://www.w3.org/TR/2005/WD-swbp-xsch-datatypes-20050427/ Editors: Jeremy J. Carroll, HP Lab Jeff Z. Pan, University Aberdeen Copyright Â©2006 W3CÂ® ERCIM, Keio), Rights Reserved. W3C liability, trademark document use rules apply. Abstract RDF OWL Recommendations use simple types XML Schema. document addresses questions left unanswered Recommendations: URIref be used refer user defined datatype? values XML Schema simple types are same? use problematic xsd:duration RDF OWL? addition, further describe integrate OWL DL user defined datatypes appendix B). Status Document section status document time publication. Other documents supersede document. list current W3C publications latest revision technical report be found W3C technical reports index http://www.w3.org/TR/. document Working Group Note, produced Semantic Web Best Practices Deployment Working Group, part W3C Semantic Web Activity. publication Working Group Note SWBPD Working Group completed work document. Changes previous Working Draft are summarized Appendix C. Comments document be sent public-swbp-wg@w3.org, mailing list public archive. Further discussion material be sent Semantic Web Interest Group mailing list, semantic-web@w3.org, also public archive. document was produced group operating February W3C Patent Policy. document informative only. W3C public list patent disclosures made connection deliverables group; page also instructions disclosing patent. Publication Working Group Note not imply endorsement W3C Membership. draft document be updated, replaced obsoleted other documents time. inappropriate cite document other work progress. Table Contents Introduction Reading Document Namespaces Used Document XML Schema Simple Types User Defined Datatypes Problem Statement Component Designators Solution Using id Attribute Suggested Practice Comparison Values Problem Statement Primitive Types Differ Formal Analysis Examples Using SPARQL Equality Value Approximate Mapping Duration Use Numeric Types Acknowledgements References Appendix Semantics Datatyping Semantic Web Recommendations A.1 Datatypes RDF A.2 Datatypes OWL DL Appendix B: Integrating Description Logics User-Defined Datatypes Appendix C: Changes Working Draft April Introduction overview datatype abstraction used RDF found Concepts Abstract Syntax]; shared Abstract Syntax]. semantics RDF datatyping OWL datatyping are summarized appendix A. RDF OWL allow use typed literal values description resources ontologies. See Primer], Guide] more introductory treatments RDF OWL. Semantics] Semantics] use lexical-to-value mapping datatype give interpretation value) typed literal, thus semantics typed literals given type system. type systems are defined externally RDF OWL, most notably Schema2]. Concrete syntaxes typed literals are found Syntax], questions XML Schema datatypes Semantic Web are not directly answered published W3C Recommendations. document RDF OWL, refer XML Schema user defined simple type URI. Details denotational semantics values primitive XML Schema simple types. XML Schema principally operational semantics. RDF OWL applications need denotational semantics interoperable behaviour. possible solution problems concerning xsd:duration, are reported Semantics]. Appropriate use numeric types engineering applications. Reading Document document be read start finish, many readers benefit skipping sections. intended reader informed RDF OWL, be creator user metadata ontologies, be implementor systems implement RDF OWL Recommendations, be author editor related specifications. reader interested defining own datatypes read section maybe appendix B, formal treatment, terms OWL DL user defined datatypes, not been covered Semantics]. reader interested correct use datatypes read section concerning values are same, section concerning numerics, particularly, not exclusively, engineering applications. Implementors probably read most document: appendix formal treatment datatyping recommendations; section extended discussion equality; section mapping URIs user defined types. Readers most interested formal semantics find most value appendix B, concerning user defined datatypes, section concerning equality. Such readers start reviewing appendix be familiar. Section durations, more limited interest, significant reader wishes use, implement build top duration datatypes. Namespaces Used Document document use N3 such following subset used Test Cases], following namespace prefixes: @prefix dc: <http://purl.org/dc/elements/1.1/> .@prefix eg: <http://www.example.org/> .@prefix egdt: <http://example.org/simpleTypes#> .@prefix xsd: <http://www.example.org/> .@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .@prefix owl: <http://www.w3.org/2002/07/owl#> .@prefix xsd: <http://www.w3.org/2001/XMLSchema#> XML Schema Simple Types SCHEMA2] facilities defining simple types be used XML Schema well other XML specifications. influenced earlier work datatypes such XML Schema simple type d characterised value space, V(d), non-empty set, lexical space, L(d), non-empty set Unicode strings, set facets, F(d), value space independent axes dimensions. XML Schema simple types are divided disjoint built-in simple types derived simple types. Derived datatypes be defined primitive existing derived datatypes following means: restriction, i.e., using facets existing type, so limit number possible values derived type. union, i.e., allow values list simple types. list, i.e., define list type existing simple type. Example 1A following definition derived simple type base datatype xsd:integer) values integers greater equal less using facets minInclusive maxExclusive. <xsd:schema <xsd:simpleType name="humanAge"> <xsd:restriction base="integer"> <xsd:minInclusive value="0"> <xsd:maxExclusive value="150"> </xsd:restriction> </xsd:simpleType> </xsd:schema> User Defined Datatypes Schema2] predefines simple types, ones suitable RDF OWL are listed Semantics]. addition, XML Schema permits users refine builtin types taking restriction including only values lexical forms. Example 2A further example, wish talk ages adults years, adult be described restriction xsd:integer datatype. <xsd:schema <xsd:simpleType name="adultAge"> <xsd:restriction base="integer"> <xsd:minInclusive value="18"> </xsd:restriction> </xsd:simpleType> </xsd:schema> Semantic Web context be used objects triples eg:age property, used, instance, describing members club restricted adults, e.g. nightclub political party. use example section, assume be retrieved http://example.org/simpleTypes. RDF, RDF reasoning, additional restriction be enough catch typos data entry errors putting inappropriate value eg:age property). OWL, OWL reasoning, interact axioms ontology significantly restrict possible interpretations, adding modelling power language. section only deals problem refer such datatypes. semantics treated appendices. Appendix reviews semantics datatypes RDF OWL recommendations. Appendix B integrate Description Logics SHOIN DL, underpinning OWL DL) user defined datatypes. also consider topic target namespace SCHEMA1]. clarity, consider variants example. first target namespace, second Example 2B <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"> <xs:simpleType name="adultAge"> <xs:restriction base="integer"> <xs:minInclusive value="18"> </xs:restriction> </xs:simpleType> Example 2C <xs:schema targetNamespace="http://example.org/ns" elementFormDefault="qualified" xmlns:egn="http://example.org/ns" xmlns:xs="http://www.w3.org/2001/XMLSchema"> <xs:simpleType name="adultAge"> <xs:restriction base="integer"> <xs:minInclusive value="18"> </xs:restriction> </xs:simpleType> case XML Schema been assembed multiple schema documents lies scope document. case discussed SCHEMA1] explicitly not discussed Problem Statement: describing resource RDF building ontology OWL, user defined simple XML Schema datatype, such adultAge above, URI be used identify datatype? Component Designators Solution Following XML Schema Component Designators Example 2B URI reference http://example.org/simpleTypes#xscd(/type::adultAge). URI reference Example 2C choice prefix namespace http://example.org/ns. good choice use prefix used schema i.e. egn. resulting URI reference datatype then http://example.org/simpleTypes#xmlns(egn=http://example.org/ns)xscd(/type::egn:adultAge) schema not define prefix target namespace, perhaps using default namespace, then arbitrary prefix needs be chosen. always namespace prefixes, permitted use prefix choice, even conventional prefix used schema document. XML Schema Component Designators XPointer scheme XML Schema document identify schema components using fragment. very general: fragments are defined identify many different aspects document, including unnamed simple types complex schema. example 2B eg:membersAge rdfs:range <http://example.org/simpleTypes#xscd(/type::adultAge)> eg:name Doe" eg:membersAge way reading fragment full semantic clarity being identified: xscd(.) shows XML Schema component being identified; type being identified; shows type being identified. URIrefs be abbreviated eg:membersAge rdfs:range egdt:xscd(/type::adultAge) eg:name Doe" eg:membersAge xscd(/type::adultAge) not match NCName production. Overall, referring XML Schema Datatypes manner proposed XML Schema Working Group good practice, be moreso, reaches Recommendation status. Using id Attribute cases XML Schema control Semantic Web author, full generality not needed. section shows defining own datatype, derived XML Schema type, possible use simpler method, slightly modifying schema defining datatype. Example 2A <xsd:schema <xsd:simpleType id="adultAge" name="adultAge"> <xsd:restriction base="integer"> <xsd:minInclusive value="18"> </xsd:restriction> </xsd:simpleType> </xsd:schema> difference datatype wish use not only identified @name attribute, also @id attribute. technically possibly use different values attributes, be confusing. URI reference http://example.org/simpleTypes#adultAge then be used refer datatype. terminology URI http://example.org/simpleTypes#adultAge secondary resource. http://example.org/simpleTypes retrieved XML Schema document, mimetype application/xml, be taken shorthand pointer Framework]. view XML representation primary resource being XML element matching @id attribute. used RDF Concepts], URI reference be understood URI http://example.org/simpleTypes identifying schema, URI http://example.org/simpleTypes#adultAge identifying datatype resource defined described representation identified application/xml retrieval. preferred targetNamespace given schema usage. there @id attribute given name, Framework] clear error: element information item identified shorthand pointer's NCName, pointer error. example RDF eg:membersAge rdfs:range <http://example.org/simpleTypes#adultAge> eg:name Doe" eg:membersAge eg:membersAge rdfs:range egdt:adultAge eg:name Doe" eg:membersAge further example, club members ages, wishes have class adult members, use OWL expression following Abstract Syntax]: Class(AdultMembers insersectionOf( Members Restriction(eg:membersAge, allValuesFrom(egdt:adultAge)) Suggested Practice referring arbitrary user defined datatypes arbitrary XML Schema, solution appropriate. RDF OWL author tool writing XML Schema use RDF/XML document, @id solution be preferred. Comparison Values different authors publishing same information Semantic Web make different syntactic choices. then say same thing different ways. seen most clearly documents entail determined Semantics] Semantics]. aspect syntactic choices facing author datatypes use. Even use only built SCHEMA2] simple types, there are non-trivial choices, different authors legitimately choose different datatypes. section addresses issue implementations Semantics] Semantics] allow different choices datatype made different authors. Problem Statement relationship value spaces various XML Schema built-in simple types used RDF OWL? other words, do literals, are written down differently, refer same value. example, denote integer Primitive Types Differ most appropriate solution primitive XML Schema Datatypes are treated having disjoint value spaces. approach easy understand, easy implement. Formally, unary datatype group, value spaces primitive base datatypes are required be defined disjoint other. instance, value space datatype D1 subset datatype D2, then D1 D2 not be primitive base datatypes unary datatype group. Formal Analysis discussing examples, presented pairs literals denoted same value. relationship denoting same value forms equivalence relation, write ~; conventionally written called equality. reflexive, symmetric transitive. terms Semantics] appendix A.1) equivalence relation be constructed interpretation function IL, following way: = <x,y> IL(x)=IL(y), x, y âˆˆ LV terms Semantics] appendix A.2), be constructed terms interpretation function ED = <x,y> ED(x)=ED(y), x, y âˆˆ LV key term use following examples, primitive base datatype type system. recursive definition built primitive datatype own primitive base datatype. primitive base datatype derived simple type primitive base datatype base datatype. other words, primitive base datatype type system found walking up restriction tree reaching primitive type. Note concept primitive base datatypes type system slightly different concept primitive base datatypes unary datatype group. possible primitive base datatype type system not datatype map, derived datatypes are. instance, Example_B, xsd:integer primitive base datatype unary datatype group G1. Examples give sets examples. first set examples, depend comparisons primitive base datatype same. second set primitive base datatype not. However, second set are intended be slightly counter-intuitive, illustrate limitations approach comparing typed literals. example presented ways: pair literals not, denote same value. possible entailment. Technically intended entailment D-entailment, terms Semantics], OWL Full entailment terms Semantics]. Similar, slightly longer, OWL DL entailments be constructed, illustrating same issues. Easy Examples uncontested SCHEMA2] datatype derived restriction subset values base datatype, not different values SCHEMA2]). Hence, typed literals type have same primitive base datatype, lexical forms are equivalent, are equal. addition, Semantics] explicitly sanctions identification RDF plain literals language tags corresponding typed literals datatype xsd:string. Derived Numerics first example denote same value, xsd:byte primitive base datatype xsd:decimal. licenses following entailment: Example 3A eg:Jane eg:age eg:Jane eg:age same result types have primitive base datatype decimal. example denote entailment: Example 3B eg:Jane eg:age eg:Jane eg:age Note xsd:byte not derived xsd:nonNegativeInteger, vice versa, even intermediate steps. Derived Strings xsd:language primitive base datatype xsd:string. Thus denote same value, following entailment Example 3C eg:doc dc:language eg:doc dc:language However, language identifier being case insensitive according case insensitivity not represented datatype, so denote different values have following non-entailment: Example 3D eg:doc dc:language not entail eg:doc dc:language Plain Strings Semantics] informative section): value space lexical-to-value mapping XSD datatype xsd:string sanctions identification typed literals plain literals language tags character strings are lexical space datatype, denote Unicode character string displayed literal; Thus same plain literal following entailments hold: Example 3E eg:doc dc:language eg:doc dc:language Example 3F eg:doc dc:language eg:doc dc:language Hard Examples typed literals being compared have different primitive base datatypes, values are assumed be different, entailments do not follow, even counterintuitive. number instance be float, double, decimal. have different primitive base datatypes, are different. Float Decimal human age conventionally given integer years, babies). float plausible alternative representation. April 7th Jeremy was different primitive basetype so are not equal Example 3G eg:JeremyCarroll eg:ageInYears not entail eg:JeremyCarroll eg:ageInYears Similarly, float double are different primitive base datatypes, so superficially similar values, such are different, Example 3H eg:car eg:engineSizeInLitres not entail eg:car eg:engineSizeInLitres Float Double float decimal, float double derived other. Thus, are treated not equal, Example 3J eg:JeremyCarroll eg:ageInYears not entail eg:JeremyCarroll eg:ageInYears Similarly: Example eg:car eg:engineSizeInLitres not entail eg:car eg:engineSizeInLitres String anyURI Similarly, types string anyURI, are distinct primitive base datatypes. So superficial similarities, different Example 3L eg:doc dc:identifier not entail eg:doc dc:identifier hexBinary base64Binary final case value spaces XML Schema simple types appear same xsd:hexBinary xsd:base64Binary. value space described set finite-length sequences binary octets. instance binary sequence octets 16-bit integer be written hexadecmial 0FB7. base64 encoding same sequence octets represented D7c=. types hexBinary base64Binary, are distinct primitive base datatypes. So different Example 3M eg:doc eg:checkSum not entail eg:doc eg:checkSum Using SPARQL Equality non-entailments shown be counterintuitive, possible use SPARQL query graph retrieve literal values are similar even not derived same primitive base type. example, related examples 3H 3K. Given graph including following triples: eg:car eg:engineSizeInLitres eg:engineSizeInLitres eg:engineSizeInLitres following query match SELECT eg:car eg:engineSizeInLitres FILTER = current working draft, mapping typedliteral, syntactic object, corresponding value, done aspart operation = operator query, ratherthanas part say D-interpretation Semantics].This mapping specified Operators], being strongly typed, not identical specified Semantics] Value Approximate Mapping different approach, better embedded Semantics], enablemeaningful mappings values different datatypes.This give better foundations operations such typepromotion XML Path Language = operator inSPARQL mentioned Section quick sketch extend D-interpretation support value approximate maps, value approximate map mapsTois partial mapping typed literals typed literals. Example 3N example value approximate mapping owlx:mapsTo Given datatype map D value approximate map mapsTo, approximate equality aeq defined aeq("s1"^^u1, L2S(D(u1))(s1) = L2S(D(u2))(s2) mapsTo("s1"^^u1)="s3"^^u2 L2S(D(u2))(s3) = L2S(D(u2))(s2), aeq("s1"^^u1, otherwise. Note according definition, aeq("s1"^^u1, not imply are interpreted same value = L2S(D(u2))(s2)). approximate equality different equality not necessarily symmetric, depending corresponding value approxiate map. unsymmetry needed support e.g. type promotions XML Path Language Note notion value approxiate mappings very general not disallow having symmetric mappings typed literals. Example 3N, also specify value approximate mapping make mappings typed literals symmetric. sum up, applications specify value approximate map mapsTo make use approximate equality aeq purposes. Duration Semantics] Recommendation use xsd:duration datatype SCHEMA2]). built-in XML Schema datatypes are unsuitable various reasons, NOT be used: xsd:duration not have well-defined value space be corrected later revisions XML Schema datatypes, case revised datatype be suitable use RDF datatyping); underlying difficulty impossibility unequivocal answer question many days month?" proved problematic other applications XML Schema datatypes. XQuery XSLT Working Groups have proposed solution. derive new datatypes, xdt:yearMonthDuration xdt:dayTimeDuration xsd:duration, sidestepping unanswerable question. section Operators] read: xdt:yearMonthDuration derived xs:duration restricting lexical representation contain only year month components. value space xdt:yearMonthDuration set xs:integer month values. year month components xdt:yearMonthDuration correspond Gregorian year month components defined section respectively. xdt:dayTimeDuration derived xs:duration restricting lexical representation contain only days, hours, minutes seconds components. value space xdt:dayTimeDuration set fractional second values. components xdt:dayTimeDuration correspond day, hour, minute second components defined Section respectively. new datatypes are suitable use RDF OWL. are not yet recommended, F&O still Working Draft). Use Numeric Types much data Semantic Web motivation providing type information permit use data engineering applications, interoperation engineering applications. Most such data be marked up using numeric types XML Schema. Loss precision unexpected changes values due automatic type conversion be problematic engineering environment. engineering domain there are important types usage numerics: count, measurement, constant. count count integer representing essentially cardinal number set things classified set tests. example be count packages candy available shipment. count exact number. Tests include measurements, count not approximation sum measurements sum approximation measurements. type such xsd:integer type derived xsd:integer appropriate counts. measurement measurement inexact numeric value represented real) produced measurement method. value value range actual value. actual value unknowable, more precise measurement methods reduce range uncertainty. precision uncertainty usually included measurement value. implicitly using significant figures explicitly using separate property value such error range. xsd:float xsd:double datatypes are appropriate measurement, be noted do not include precision uncertainity, be included value separate property. SCHEMA2] explicitly states xsd:decimal not reflected value space, number not distinct number constant constant exact value used computation. not be possible express exactly numeric. millimeter exactly meters, Pi not Often xsd:decimal be more appropriate xsd:float xsd:double expressing constant. Example 5A example measurement error range indicate weight interval eg:JeremyCarroll eg:weight eg:units eg:value eg:errorRange different usages suggest potential needs concerns type system underlying value spaces types are different, measurements are disjoint counts constants. means capturing precision error/uncertainty needed measurement values. means desirable writing down constants be expressed precisely numeric form. first issues generally be reflected use xsd:integer counts, xsd:float xsd:double measurements, xsd:decimal constants. second issue concerning precision measurements, be addressed modelling level using objects state precision error properties measurements. not bad approach, case, there are often other properties metadata associated measurement. third issue, concerning constants, solution offered. Acknowledgements Evan Wallace author Section Evan Wallace, Ashok Malhotra, Pat Hayes, Dave Peterson, Dave Reynolds, Michael Sperberg-McQueen Ralph Swick contributed useful reviews. References RDF Semantics, Patrick Hayes, Editor, W3C Recommendation, February http://www.w3.org/TR/2004/REC-rdf-mt-20040210/ Latest version available http://www.w3.org/TR/rdf-mt/ Primer] RDF Primer, Frank Manola Eric Miller, Editors, W3C Recommendation, February http://www.w3.org/TR/2004/REC-rdf-primer-20040210/ Latest version available http://www.w3.org/TR/rdf-primer/ Concepts] Resource Description Framework Concepts Abstract Syntax, Graham Klyne Jeremy J. Carroll, Editors, W3C Recommendation, February http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/ Latest version available http://www.w3.org/TR/rdf-concepts/ Syntax] RDF/XML Syntax Specification Dave Beckett, Editor, W3C Recommendation, February http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/ Latest version available http://www.w3.org/TR/rdf-syntax-grammar/ RDF Test Cases, Jan Grant Dave Beckett, Editors, W3C Recommendation, February http://www.w3.org/TR/2004/REC-rdf-testcases-20040210/ Latest version available http://www.w3.org/TR/rdf-testcases/ Abstract Syntax] Semantics] OWL Web Ontology Language Semantics Abstract Syntax, Peter F. Patel-Schneider, Patrick Hayes, Ian Horrocks, Editors, W3C Recommendation February http://www.w3.org/TR/2004/REC-owl-semantics-20040210/ Latest version available http://www.w3.org/TR/owl-semantics/ Guide] OWL Web Ontology Language Guide, Michael K. Smith, Chris Welty, Deborah L. McGuinness, Editors, W3C Recommendation, February http://www.w3.org/TR/2004/REC-owl-guide-20040210/ Latest version available http://www.w3.org/TR/owl-guide/ Test Cases] OWL Web Ontology Language Test Cases Jeremy J. Carroll Jos De Roo, Editors. W3C Recommendation, February http://www.w3.org/TR/2004/REC-owl-test-20040210/. Latest version available http://www.w3.org/TR/owl-test/. Framework] XPointer Framework Paul Grosso, Eve Maler, Jonathan Marsh Norman Walsh, Editors, W3C Recommendation, March http://www.w3.org/TR/2003/REC-xptr-framework-20030325/ Latest version available http://www.w3.org/TR/xptr-framework/ XML Schema Part Structures, Second Edition, W3C Recommendation, World Wide Web Consortium, Henry S. Thompson, David Beech, Murray Maloney Noah Mendelsohn October version http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/. latest version available http://www.w3.org/TR/xmlschema-1/. XML Schema Part Datatypes, Second Edition, W3C Recommendation, World Wide Web Consortium, Paul V. Biron Ashok Malhotra October version http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/. latest version available http://www.w3.org/TR/xmlschema-2/. N. Freed N. Borenstein. RFC Multipurpose Internet Mail Extensions Part Format Internet Message Bodies. Available http://www.ietf.org/rfc/rfc2045.txt T. Berners-Lee, R. Fielding, L. Masinter. Uniform Resource Identifiers Generic Syntax. IETF RFC See http://www.ietf.org/rfc/rfc3986.txt. H. Alvestrand, ed. RFC Tags Identification Languages Available http://www.ietf.org/rfc/rfc3066.txt ISO Organization Standardization). Representations dates times, Available http://www.iso.ch/ ISO Organization Standardization). Language-independent Datatypes. Available http://www.iso.ch/ Unicode Standard, Version Unicode Consortium, Addison-Wesley, ISBN updated time time publication new versions. http://www.unicode.org/unicode/standard/versions/ latest version additional information versions standard Unicode Character Database). Operators] XQuery XPath Functions Operators, Ashok Malhotra, Jim Melton Norman Walsh World Wide Web Consortium Working Draft, work progress, September version Functions Operators http://www.w3.org/TR/2005/WD-xpath-functions-20050915/. latest version Functions Operators http://www.w3.org/TR/xpath-functions/. XML Path Language Anders Berglund, Scott Boag, Don Chamberlin, Mary F. Fernández, Michael Kay, Jonathan Robie Jérôme Siméon W3C Candidate Recommendation November version XML Path Language http://www.w3.org/TR/2005/CR-xpath20-20051103/. latest version XML Path Language http://www.w3.org/TR/xpath20/. SPARQL Query Language RDF, Eric Prud'hommeaux Andy Seaborne, Editors, W3C Working Draft July http://www.w3.org/TR/2005/WD-rdf-sparql-query-20050721/ Latest version available http://www.w3.org/TR/rdf-sparql-query/ XML Schema Component Designators, Mary Holstege Asir S. Vedamuthu, Editors, W3C Working Draft, March http://www.w3.org/TR/2005/WD-xmlschema-ref-20050329/. Latest version available http://www.w3.org/TR/xmlschema-ref/ Description Logics: Reasoning Support Semantic Web, Jeff Z.Pan, PhD Thesis, School Computer Science, University Manchester, OWL-Eu: Adding Customised Datatypes OWL, Jeff Z.Pan Ian Horrocks. Proc. Second European Semantic Web Conference pages extended version Journal Web Semantic, online version available http://www.websemanticsjournal.org/ps/pub/2005-24. Primer: Getting RDF Semantic Web using N3 Tim Berners-Lee, Dan Connolly Appendix Semantics Datatyping Semantic Web Recommendations A.1 Datatypes RDF According Semantics], section RDF use datatypes defined external type systems, e.g., XML Schema type system, conform following specification. RDF, datatype d characterised value space, V(d), non-empty set, lexical space, L(d), non-empty set Unicode strings, total mapping L2V(d) lexical space value space. specification use non-list XML Schema simple types datatypes RDF. literals have lexical form being Unicode string. Typed literals are form Unicode string, called lexical form typed literal, u URI reference datatype. Plain literals have lexical form optionally language tag defined normalized lowercase. Example Boolean datatype value space lexical space lexical-to-value mapping typed literal, plain literal. associations datatype URI references xsd:boolean) datatypes boolean) be provided datatype maps defined datatype map D partial mapping datatype URI references datatypes. RDFS-interpretation w.r.t. datatype map D be defined Given datatype map D, RDFS D-interpretation vocabulary V RDFS-interpretation Vâˆª{u distinguished subset LV IR, called set literal values, plain literals V, mapping IL literals V IR, satisfies following extra conditions: LV = ICEXT(rdfs:Literal). plain literal plâˆˆV, IL(pl) = pl. pair <u,d> d = D(u), âˆˆ ICEXT(rdfs:Datatype), there dâˆˆIR s.t. = d, ICEXT(d) = V(d) âŠ† LV, = d, sâˆˆL(d), then IL("s"^^u') = L2S(d)(s); otherwise, IL("s"^^u') âˆˆ IR LV. d âˆˆ ICEXT(rdfs:Datatype), then <d, âˆˆ IEXT(rdfs:subClassOf). A.2 Datatypes OWL DL OWL Full datatyping RDF Semantics OWL DL datatyping specified section Semantics], fundamental difference RDF datatyping OWL DL datatyping relationship datatypes classes. OWL DL, datatypes are not classes, object datatype domains are disjoint other. OWL different OWL reasoners provide different supported datatypes. Given datatype map D, datatype URI reference u called supported datatype URI reference w.r.t. D there datatype d such <u,d>âˆˆD case, d called supported datatype w.r.t. D); otherwise, u called unsupported datatype URI reference w.r.t. D. OWL use so called enumerated datatypes, are built using literals. Let y1, yn be literals. enumerated datatype form oneOf(y1, yn). OWL DL D-interpretation w.r.t. datatype map D be defined OWL DL datatype interpretation w.r.t. datatype map D pair datatype domain LV value spaces datatype D PL value space plain literals, i.e., union set Unicode strings set pairs Unicode strings language tags) ED datatype interpretation function, satisfythe following conditions: LV = ED(rdfs:Literal). plain literal pl, ED(pl) = pl âˆˆ PL. supported datatype URIref u d = D(u)): ED(u) = V(d) âŠ† LV, s âˆˆ L(d), then ED("s"^^u) = L2V(d)(s);otherwise, ED("s"^^u) not defined. unsupported datatype URIref u, ED(u) âŠ† LV andED("s"^^u) âˆˆ ED(u). enumerated datatype oneOf(y1, interpreted Note here simplify presentation using ED theinterpretation function datatype URI references andliterals, Semantics]uses EC datatypes URI references L literals. OWL Full, disjointness restriction object datatype domains not required. Appendix B: Integrating Description Logics User-Defined Datatypes present scheme ofintegrating large family decidable Description Logics(including SHOIN, underpinning OWL DL) unarydatatype groups, so support user defined datatypes. Acombined DL decidable unary datatype group conforming.A conforming unary datatype group equipped decisionprocedure satisfiability problem finite conjunctionsover supported datatypes. unary datatypegroup G triple <D,B,dom>, D datatype map,B set primitive base datatype URI references G domis declared domain function. call S set supporteddatatype URI references, i.e., uâˆˆS, D(u) defined; werequire B âŠ† S. declared domain function dom followingproperties: u âˆˆ S, u âˆˆ B, dom(u) = u; otherwise, dom(u)= âˆˆ B. assume there datatype URIreference rdfsx:DatatypeBottom such D(rdfsx:DatatypeBottom) isundefined. Note datatypegroups allow arbitrary datatype predicates, here consideronly datatypes, be regarded unary datatypepredicates. Example B G1=(D1,B1,dom1) datatype group, D1 = â†’ integer, xsd:stringâ†’ string, xsd:nonNegativeInteger â†’â‰¥0, xsdx:integerLessThanN â†’<N}, B1 = xsd:string}, dom1 = â†’ xsd:integer,xsd:string â†’ xsd:string, xsd:nonNegativeIntegerâ†’ xsd:integer, xsdx:integerLessThanN â†’xsd:integer}. According D1, have S1 = xsd:nonNegativeInteger, xsdx:integerGreaterThanN},hence have B1 âŠ† S1. Note valuespace <N isV(<N) = âˆˆ V(integer) L2S(integer)(N)} mean there built-indatatype <N integerL2S(integer)(N). unary datatype group, datatype expressions be used torepresent user defined datatypes. Let G be unarydatatype group, set unary datatype expressions G,abbreviated Dexp(G), inductively defined let u be datatype URI reference, u âˆˆ DPexp(G); let u be datatype URI reference, negationnot(u) âˆˆ DPexp(G); let y1, yn be literals, theenumerated datatype oneOf(y1, yn) âˆˆDPexp(G); p,q âˆˆ DPexp(G), conjunction âˆˆDPexp(G); p,q âˆˆ DPexp(G), disjunction âˆˆDPexp(G). Example C XML Schema user defined datatype humanAge defined 1A] be represented thefollowing unary datatype expression: datatypeinterpretation unary datatype group G = apair datatype domain LV non-empty set datatype interpretation function satisfies thefollowing conditions: ED(rdfs:Literal)=LV ED(rdfsx:DatatypeBottom)} = âˆ…. plain literal pl, ED(pl) = pl âˆˆ PL PL âŠ† LV. primitivebase datatype URI references u1 u2,ED(u1) âˆ© ED(u2) = âˆ…. supported datatype URI reference u âˆˆ S d = D(u)): ED(u) = V(d) âŠ† V(D(dom(u))) âŠ† LV, L(D(u)) âŠ† L(D(dom(u)) andL2S(D(u)) âŠ† L2S(D(dom(u)), s âˆˆ L(d), then ED("s"^^u) = L2V(d)(s);otherwise, ED("s"^^u) not defined. unsupported datatype URI reference u âˆ‰ S, ED(u) âŠ† LVand âˆˆ ED(u). datatype interpretation function ED be extended providesemantics unary datatype expressions Relativised negations: u âˆˆ S D, ED(not(u)) = ED(dom(U)) otherwise, ED(not(u)) = LV ED(u). Enumerated datatypes: ED(oneOf(y1, = âˆª{ED(yn)}. Conjunctions: ED(and(p,q)) = ED(p) âˆ© ED(q). Disjunctions: ED(or(p,q)) = ED(p) âˆª ED(q). shows combine decidable DL SHOIN, underpinning OWL DL) conjunction bottom constructors conforming unary datatype group combined DL still decidable. Appendix C: Changes Working Draft April C.1 Typos etc. introduction. Updated syntax XML Schema Component Designators. Deleted broken link description Added reference ISO homepage instead. C.2 Discussion removal earlier draft was discussion document. note not intended such, so issues, particularly do interactions various standards, recommendations, RFCs etc. been removed. Removed DAML+OIL solution. Removed true values solution. Removed XPath eq solution. Moved OWL syntax example DAML+OIL section end id section. XML Schema Component Designator section: Discussion relationship XSCD, XPointer RFC been removed. Discussion exact semantics XSCD fragment been removed. Deleted words contentious)" id solution. Changed XML Schema Component Designator section, indicate XSCD good practice. particular, see last paragraph. Changed discussion subsection user defined datatypes suggest solutions are appropriate, have discussion. Changed title Suggested Practice. Discussion harder examples cut down substantially, are trivially non-entailments agreed semantics. Removed EDITORS' OPINION notes. C.3 Changes response comment Ashok Malhotra Deleted uses word section caused confusion. Added links XML Schema document union, list restriction, make clear intended concept defined document. Added brief discussion target namespace example 2A providing further examples example 2B example 2C. Scoped document not address Schema assembled multiple schema documents". Added reference SCHEMA1]. XML Schema Component Designator section: added more extended discussion target namespace issue; added example XSCD schema target namespace. Added text showing @id solution comply secondary resource concept RFC read conjunction RDF Concepts, XPointer XML Schema. C.4 Restructuring section Reordered subsections section deleting old ordering remaining subsections Followed renumbering. Text discussing examples changed, change tracking not detailed. Moved definition primitive base datatype examples subsection formal analysis subsection. Deleted references examples new section Added example SPARQL query, show use = SPARQL compare type hierarchy. Added updated discussion mapsTo. C.5 Other changes Added further acknowledgements. Updated reference RFC be RFC Updated Table Contents Removed unused references. Updated versions W3C WD's references. 