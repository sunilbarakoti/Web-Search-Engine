OWL Web Ontology Language Mapping RDF Graphs Edition) OWL Web Ontology Language Mapping RDF Graphs Edition) W3C Recommendation December version: http://www.w3.org/TR/2012/REC-owl2-mapping-to-rdf-20121211/ Latest version http://www.w3.org/TR/owl2-mapping-to-rdf/ Latest Recommendation: http://www.w3.org/TR/owl-mapping-to-rdf Previous version: http://www.w3.org/TR/2012/PER-owl2-mapping-to-rdf-20121018/ Editors: Peter F. Patel-Schneider, Nuance Communications Boris Motik, University Oxford Contributors: alphabetical order) Bernardo Cuenca Grau, University Oxford Ian Horrocks, University Oxford Bijan Parsia, University Manchester Alan Ruttenberg, Science Commons Commons) Michael Schneider, FZI Research Center Information Technology refer errata document, include normative corrections. color-coded version document showing changes made previous version also available. document also available non-normative formats: PDF version. See also translations. Copyright W3C® ERCIM, Keio), Rights Reserved. W3C liability, trademark document use rules apply. Abstract OWL Web Ontology Language, informally OWL ontology language Semantic Web formally defined meaning. OWL ontologies provide classes, properties, individuals, data values are stored Semantic Web documents. OWL ontologies be used information written RDF, OWL ontologies are primarily exchanged RDF documents. OWL Document Overview overall state OWL be read other OWL documents. document mapping OWL ontologies RDF graphs, vice versa. Status Document May Be Superseded section status document time publication. Other documents supersede document. list current W3C publications latest revision technical report be found W3C technical reports index http://www.w3.org/TR/. Summary Changes have been substantive changes previous version. details minor changes see change log color-coded diff. Send Comments send comments public-owl-comments@w3.org archive). work document OWL Working Group complete, comments be addressed errata future revisions. Open discussion developers welcome public-owl-dev@w3.org archive). Endorsed W3C document been reviewed W3C Members, software developers, other W3C groups interested parties, endorsed Director W3C Recommendation. stable document be used reference material cited document. W3C's role making Recommendation draw attention specification promote widespread deployment. functionality interoperability Web. Patents document was produced group operating February W3C Patent Policy. W3C public list patent disclosures made connection deliverables group; page also instructions disclosing patent. Table Contents Introduction Preliminaries Mapping Structural Specification RDF Graphs Translation Axioms Annotations Translation Annotations Translation Axioms Annotations Axioms Generate Main Triple Axioms are Translated Multiple Triples Axioms Represented Blank Nodes Mapping RDF Graphs Structural Specification Extracting Declarations IRIs Directly Imported Ontology Documents Resolving Included RDF Graphs Parsing Ontology Header Declarations Populating Ontology Analyzing Declarations Parsing Annotations Parsing Ontology Annotations Parsing Expressions Parsing Axioms Appendix: Change Log Changes Recommendation Changes Proposed Recommendation Changes Candidate Recommendation Changes Last Call Acknowledgments References Introduction Preliminaries document mappings structural specification OWL Specification] RDF graphs Concepts]. mapping presented Section be used transform OWL ontology O RDF graph T(O). mapping presented Section be used transform RDF graph G satisfying certain restrictions OWL DL ontology OG. transformations do not incur change formal meaning ontology. More precisely, OWL DL ontology O, let G = T(O) be RDF graph obtained transforming O specified Section let OG be OWL DL ontology obtained applying reverse transformation Section G; then, O OG are logically equivalent have exactly same set models. mappings presented document are backwards-compatible OWL DL: OWL DL ontology encoded RDF graph be mapped valid OWL DL ontology using mapping Section such resulting OWL DL ontology exactly same set models original OWL DL ontology. syntax triples used document used RDF Semantics Semantics]. Full IRIs are abbreviated using prefixes OWL Specification Specification]. OWL ontologies mentioned document be understood instances structural specification OWL Specification]; required, are written document using functional-style syntax. following notation used document referring parts RDF graphs: IRI; _:x blank node; blank node IRI; lt literal; xlt blank node, IRI, literal. italicized keywords MUST, MUST NOT, NOT, MAY are used specify normative features OWL documents tools, are interpreted specified RFC Mapping Structural Specification RDF Graphs section mapping OWL ontology O RDF graph T(O). mapping presented parts. Section shows translate axioms do not contain annotations, Section shows translate annotations, Section shows translate axioms containing annotations. Translation Axioms Annotations Table presents operator T maps OWL ontology O RDF graph T(O), provided axiom O annotated. mapping defined recursively; mapping construct often mappings subconstructs, slightly unusual way: mapping construct mapping subconstruct, then triples generated recursive invocation mapping subconstruct are added graph construction, main node mapping subconstruct used place recursive invocation definition operator T uses operator TANN order translate annotations. operator TANN defined Section annotation IRI blank node triples attach annotation supplied object. mapping, generated blank node blank node not correspond anonymous individual) fresh application mapping rule. Furthermore, possible conditions mapping rules are enclosed curly braces Finally, following conventions are used section denote different parts OWL ontologies: OP object property; OPE object property expression; DP data property; DPE data property expression; AP annotation property; C class; CE class expression; DT datatype; DR data range; U IRI; F constraining facet; individual anonymous); named individual; lt literal; annotation source; annotation value. section, T(SEQ y1 yn) translation sequence objects structural specification RDF list, shown Table Table Transformation Triples Element E Structural Specification Triples Generated Invocation T(E) Main Node T(E) SEQ rdf:nil SEQ y1 yn _:x rdf:first T(y1) _:x rdf:rest T(SEQ y2 yn) _:x Ontology( ontologyIRI versionIRI Import( importedOntologyIRI1 Import( importedOntologyIRIk annotation1 annotationm axiom1 axiomn ontologyIRI rdf:type owl:Ontology ontologyIRI owl:versionIRI versionIRI ontologyIRI owl:imports importedOntologyIRI1 ontologyIRI owl:imports importedOntologyIRIk TANN(annotation1, ontologyIRI) TANN(annotationm, ontologyIRI) T(axiom1) T(axiomn) ontologyIRI Ontology( Import( importedOntologyIRI1 Import( importedOntologyIRIk annotation1 annotationm axiom1 axiomn _:x rdf:type owl:Ontology _:x owl:imports importedOntologyIRI1 _:x owl:imports importedOntologyIRIk TANN(annotation1, TANN(annotationm, T(axiom1) T(axiomn) _:x C C DT DT OP OP DP DP AP AP U U lt lt literal datatype other rdf:PlainLiteral lt Declaration( Datatype( DT T(DT) rdf:type rdfs:Datatype Declaration( Class( C T(C) rdf:type owl:Class Declaration( ObjectProperty( OP T(OP) rdf:type owl:ObjectProperty Declaration( DataProperty( DP T(DP) rdf:type owl:DatatypeProperty Declaration( AnnotationProperty( AP T(AP) rdf:type owl:AnnotationProperty Declaration( NamedIndividual( T(*:a) rdf:type owl:NamedIndividual ObjectInverseOf( OP _:x owl:inverseOf T(OP) _:x DataIntersectionOf( DR1 DRn _:x rdf:type rdfs:Datatype _:x owl:intersectionOf T(SEQ DR1 DRn) _:x DataUnionOf( DR1 DRn _:x rdf:type rdfs:Datatype _:x owl:unionOf T(SEQ DR1 DRn) _:x DataComplementOf( DR _:x rdf:type rdfs:Datatype _:x owl:datatypeComplementOf T(DR) _:x DataOneOf( lt1 ltn _:x rdf:type rdfs:Datatype _:x owl:oneOf T(SEQ lt1 ltn) _:x DatatypeRestriction( DT F1 lt1 Fn ltn _:x rdf:type rdfs:Datatype _:x owl:onDatatype T(DT) _:x owl:withRestrictions T(SEQ _:y1 _:yn) _:y1 F1 lt1 _:yn Fn ltn _:x ObjectIntersectionOf( CE1 CEn _:x rdf:type owl:Class _:x owl:intersectionOf T(SEQ CE1 CEn) _:x ObjectUnionOf( CE1 CEn _:x rdf:type owl:Class _:x owl:unionOf T(SEQ CE1 CEn) _:x ObjectComplementOf( CE _:x rdf:type owl:Class _:x owl:complementOf T(CE) _:x ObjectOneOf( a1 _:x rdf:type owl:Class _:x owl:oneOf T(SEQ a1 _:x ObjectSomeValuesFrom( OPE CE _:x rdf:type owl:Restriction _:x owl:onProperty T(OPE) _:x owl:someValuesFrom T(CE) _:x ObjectAllValuesFrom( OPE CE _:x rdf:type owl:Restriction _:x owl:onProperty T(OPE) _:x owl:allValuesFrom T(CE) _:x ObjectHasValue( OPE _:x rdf:type owl:Restriction _:x owl:onProperty T(OPE) _:x owl:hasValue T(a) _:x ObjectHasSelf( OPE _:x rdf:type owl:Restriction _:x owl:onProperty T(OPE) _:x owl:hasSelf _:x ObjectMinCardinality( n OPE _:x rdf:type owl:Restriction _:x owl:onProperty T(OPE) _:x owl:minCardinality _:x ObjectMinCardinality( n OPE CE _:x rdf:type owl:Restriction _:x owl:onProperty T(OPE) _:x owl:minQualifiedCardinality _:x owl:onClass T(CE) _:x ObjectMaxCardinality( n OPE _:x rdf:type owl:Restriction _:x owl:onProperty T(OPE) _:x owl:maxCardinality _:x ObjectMaxCardinality( n OPE CE _:x rdf:type owl:Restriction _:x owl:onProperty T(OPE) _:x owl:maxQualifiedCardinality _:x owl:onClass T(CE) _:x ObjectExactCardinality( n OPE _:x rdf:type owl:Restriction _:x owl:onProperty T(OPE) _:x owl:cardinality _:x ObjectExactCardinality( n OPE CE _:x rdf:type owl:Restriction _:x owl:onProperty T(OPE) _:x owl:qualifiedCardinality _:x owl:onClass T(CE) _:x DataSomeValuesFrom( DPE DR _:x rdf:type owl:Restriction _:x owl:onProperty T(DPE) _:x owl:someValuesFrom T(DR) _:x DataSomeValuesFrom( DPE1 DPEn DR n _:x rdf:type owl:Restriction _:x owl:onProperties T(SEQ DPE1 DPEn) _:x owl:someValuesFrom T(DR) _:x DataAllValuesFrom( DPE DR _:x rdf:type owl:Restriction _:x owl:onProperty T(DPE) _:x owl:allValuesFrom T(DR) _:x DataAllValuesFrom( DPE1 DPEn DR n _:x rdf:type owl:Restriction _:x owl:onProperties T(SEQ DPE1 DPEn) _:x owl:allValuesFrom T(DR) _:x DataHasValue( DPE lt _:x rdf:type owl:Restriction _:x owl:onProperty T(DPE) _:x owl:hasValue T(lt) _:x DataMinCardinality( n DPE _:x rdf:type owl:Restriction _:x owl:onProperty T(DPE) _:x owl:minCardinality _:x DataMinCardinality( n DPE DR _:x rdf:type owl:Restriction _:x owl:onProperty T(DPE) _:x owl:minQualifiedCardinality _:x owl:onDataRange T(DR) _:x DataMaxCardinality( n DPE _:x rdf:type owl:Restriction _:x owl:onProperty T(DPE) _:x owl:maxCardinality _:x DataMaxCardinality( n DPE DR _:x rdf:type owl:Restriction _:x owl:onProperty T(DPE) _:x owl:maxQualifiedCardinality _:x owl:onDataRange T(DR) _:x DataExactCardinality( n DPE _:x rdf:type owl:Restriction _:x owl:onProperty T(DPE) _:x owl:cardinality _:x DataExactCardinality( n DPE DR _:x rdf:type owl:Restriction _:x owl:onProperty T(DPE) _:x owl:qualifiedCardinality _:x owl:onDataRange T(DR) _:x SubClassOf( CE1 CE2 T(CE1) rdfs:subClassOf T(CE2) EquivalentClasses( CE1 CEn T(CE1) owl:equivalentClass T(CE2) T(CEn-1) owl:equivalentClass T(CEn) DisjointClasses( CE1 CE2 T(CE1) owl:disjointWith T(CE2) DisjointClasses( CE1 CEn n > _:x rdf:type owl:AllDisjointClasses _:x owl:members T(SEQ CE1 CEn) DisjointUnion( C CE1 CEn T(C) owl:disjointUnionOf T(SEQ CE1 CEn) SubObjectPropertyOf( OPE1 OPE2 T(OPE1) rdfs:subPropertyOf T(OPE2) SubObjectPropertyOf( ObjectPropertyChain( OPE1 OPEn OPE T(OPE) owl:propertyChainAxiom T(SEQ OPE1 OPEn) EquivalentObjectProperties( OPE1 OPEn T(OPE1) owl:equivalentProperty T(OPE2) T(OPEn-1) owl:equivalentProperty T(OPEn) DisjointObjectProperties( OPE1 OPE2 T(OPE1) owl:propertyDisjointWith T(OPE2) DisjointObjectProperties( OPE1 OPEn n > _:x rdf:type owl:AllDisjointProperties _:x owl:members T(SEQ OPE1 OPEn) ObjectPropertyDomain( OPE CE T(OPE) rdfs:domain T(CE) ObjectPropertyRange( OPE CE T(OPE) rdfs:range T(CE) InverseObjectProperties( OPE1 OPE2 T(OPE1) owl:inverseOf T(OPE2) FunctionalObjectProperty( OPE T(OPE) rdf:type owl:FunctionalProperty InverseFunctionalObjectProperty( OPE T(OPE) rdf:type owl:InverseFunctionalProperty ReflexiveObjectProperty( OPE T(OPE) rdf:type owl:ReflexiveProperty IrreflexiveObjectProperty( OPE T(OPE) rdf:type owl:IrreflexiveProperty SymmetricObjectProperty( OPE T(OPE) rdf:type owl:SymmetricProperty AsymmetricObjectProperty( OPE T(OPE) rdf:type owl:AsymmetricProperty TransitiveObjectProperty( OPE T(OPE) rdf:type owl:TransitiveProperty SubDataPropertyOf( DPE1 DPE2 T(DPE1) rdfs:subPropertyOf T(DPE2) EquivalentDataProperties( DPE1 DPEn T(DPE1) owl:equivalentProperty T(DPE2) T(DPEn-1) owl:equivalentProperty T(DPEn) DisjointDataProperties( DPE1 DPE2 T(DPE1) owl:propertyDisjointWith T(DPE2) DisjointDataProperties( DPE1 DPEn n > _:x rdf:type owl:AllDisjointProperties _:x owl:members T(SEQ DPE1 DPEn) DataPropertyDomain( DPE CE T(DPE) rdfs:domain T(CE) DataPropertyRange( DPE DR T(DPE) rdfs:range T(DR) FunctionalDataProperty( DPE T(DPE) rdf:type owl:FunctionalProperty DatatypeDefinition( DT DR T(DT) owl:equivalentClass T(DR) HasKey( CE OPE1 OPEm DPE1 DPEn T(CE) owl:hasKey T(SEQ OPE1 OPEm DPE1 DPEn SameIndividual( a1 T(a1) owl:sameAs T(a2) T(an-1) owl:sameAs T(an) DifferentIndividuals( a1 a2 T(a1) owl:differentFrom T(a2) DifferentIndividuals( a1 n > _:x rdf:type owl:AllDifferent _:x owl:members T(SEQ a1 ClassAssertion( CE T(a) rdf:type T(CE) ObjectPropertyAssertion( OP a1 a2 T(a1) T(OP) T(a2) ObjectPropertyAssertion( ObjectInverseOf( OP a1 a2 T(a2) T(OP) T(a1) NegativeObjectPropertyAssertion( OPE a1 a2 _:x rdf:type owl:NegativePropertyAssertion _:x owl:sourceIndividual T(a1) _:x owl:assertionProperty T(OPE) _:x owl:targetIndividual T(a2) DataPropertyAssertion( DPE lt T(a) T(DPE) T(lt) NegativeDataPropertyAssertion( DPE lt _:x rdf:type owl:NegativePropertyAssertion _:x owl:sourceIndividual T(a) _:x owl:assertionProperty T(DPE) _:x owl:targetValue T(lt) AnnotationAssertion( AP T(as) T(AP) T(av) SubAnnotationPropertyOf( AP1 AP2 T(AP1) rdfs:subPropertyOf T(AP2) AnnotationPropertyDomain( AP U T(AP) rdfs:domain T(U) AnnotationPropertyRange( AP U T(AP) rdfs:range T(U) Translation Annotations operator TANN, translates annotations IRI blank node, defined Table Table Translation Annotations Annotation ann Triples Generated Invocation TANN(ann, y) Annotation( AP T(y) T(AP) T(av) Annotation( annotation1 annotationn AP T(y) T(AP) T(av) _:x rdf:type owl:Annotation _:x owl:annotatedSource T(y) _:x owl:annotatedProperty T(AP) _:x owl:annotatedTarget T(av) TANN(annotation1, TANN(annotationn, Let ann be following annotation. Annotation( rdfs:label Griffin" invocation TANN(ann, then following triples. rdfs:label Griffin" Let ann be following annotation, annotated. Annotation( Annotation( rdfs:label Griffin" invocation TANN(ann, then following triples: rdfs:label Griffin" _:x rdf:type owl:Annotation _:x owl:annotatedSource _:x owl:annotatedProperty rdfs:label _:x owl:annotatedTarget Griffin" _:x Translation Axioms Annotations axiom ax embedded annotations annotation1 annotationm, serialization RDF type axiom. Let ax' be axiom obtained ax removing axiom annotations. Axioms Generate Main Triple row Table corresponding type ax' single main triple s p xlt then axiom ax translated following triples: s p xlt _:x rdf:type owl:Axiom _:x owl:annotatedSource s _:x owl:annotatedProperty p _:x owl:annotatedTarget xlt TANN(annotation1, TANN(annotationm, case ax' type SubClassOf, DisjointClasses classes, SubObjectPropertyOf property chain subproperty expression, SubDataPropertyOf, ObjectPropertyDomain, DataPropertyDomain, ObjectPropertyRange, DataPropertyRange, InverseObjectProperties, FunctionalObjectProperty, FunctionalDataProperty, InverseFunctionalObjectProperty, ReflexiveObjectProperty, IrreflexiveObjectProperty, SymmetricObjectProperty, AsymmetricObjectProperty, TransitiveObjectProperty, DisjointObjectProperties properties, DisjointDataProperties properties, ClassAssertion, ObjectPropertyAssertion, DataPropertyAssertion, Declaration, DifferentIndividuals individuals, AnnotationAssertion. Consider following subclass axiom: SubClassOf( Annotation( rdfs:comment are people." annotation, axiom be translated following triple: rdfs:subClassOf Thus, annotated axiom transformed following triples: rdfs:subClassOf _:x rdf:type owl:Axiom _:x owl:annotatedSource _:x owl:annotatedProperty rdfs:subClassOf _:x owl:annotatedTarget _:x rdfs:comment are people." ax' type DisjointUnion, SubObjectPropertyOf subproperty chain, HasKey, first triple corresponding row Table main triple subjected transformation described other triples corresponding row Table called side triples are output change. Consider following subproperty axiom: SubObjectPropertyOf( Annotation( rdfs:comment aunt mother's sister." ObjectPropertyChain( annotation, axiom be translated following triples: owl:propertyChainAxiom _:y1. _:y1 rdf:first _:y1 rdf:rest _:y2 _:y2 rdf:first _:y2 rdf:rest rdf:nil order capture annotation axiom, first triple plays role main triple axiom, so represented using fresh blank node _:x order be able attach annotation original triple output other triples well. _:x rdf:type owl:Axiom _:x owl:annotatedSource _:x owl:annotatedProperty owl:propertyChainAxiom _:x owl:annotatedTarget _:y1 _:x rdfs:comment aunt mother's sister." owl:propertyChainAxiom _:y1. _:y1 rdf:first _:y1 rdf:rest _:y2 _:y2 rdf:first _:y2 rdf:rest rdf:nil Consider following key axiom: HasKey( Annotation( rdfs:comment uniquely person." annotation, axiom be translated following triples: owl:hasKey rdf:first rdf:rest rdf:nil order capture annotation axiom, first triple plays role main triple axiom, so represented using fresh blank node _:x order be able attach annotation _:x rdf:type owl:Axiom _:x owl:annotatedSource _:x owl:annotatedProperty owl:hasKey _:x owl:annotatedTarget _:x rdfs:comment uniquely person." owl:hasKey rdf:first rdf:rest rdf:nil Axioms are Translated Multiple Triples axiom ax' type EquivalentClasses, EquivalentObjectProperties, EquivalentDataProperties, SameIndividual, translation RDF be broken up several RDF triples RDF only represent binary relations). case, RDF triples obtained translation ax' transformed described previous section, annotations are repeated triples obtained translation. Consider following individual equality axiom: SameIndividual( Annotation( axiom first split following equalities pairs individuals, annotation repeated axiom obtained process: SameIndividual( Annotation( SameIndividual( Annotation( axioms now transformed triples explained previous section: owl:sameAs _:x1 rdf:type owl:Axiom _:x1 owl:annotatedSource _:x1 owl:annotatedProperty owl:sameAs _:x1 owl:annotatedTarget _:x1 owl:sameAs _:x2 rdf:type owl:Axiom _:x2 owl:annotatedSource _:x2 owl:annotatedProperty owl:sameAs _:x2 owl:annotatedTarget _:x2 Axioms Represented Blank Nodes axiom ax' type NegativeObjectPropertyAssertion, NegativeDataPropertyAssertion, DisjointClasses more classes, DisjointObjectProperties more properties, DisjointDataProperties more properties, DifferentIndividuals more individuals, then translation already introducing blank node _:x. such cases, ax translated first translating ax' _:x shown Table then attaching annotations ax _:x. Consider following negative object property assertion: NegativeObjectPropertyAssertion( Annotation( Even annotation, axiom be represented using blank node. annotation readily be attached node, so axiom transformed following triples: _:x rdf:type owl:NegativePropertyAssertion _:x owl:sourceIndividual _:x owl:assertionProperty _:x owl:targetIndividual _:x Mapping RDF Graphs Structural Specification section results steps CP CP canonical parsing process Section OWL Specification Specification] ontology document D be parsed RDF graph G. OWL tool MAY implement steps way however, results MUST be structurally equivalent ones defined following sections. steps do not depend RDF syntax used encode RDF graph D; therefore, ontology document D identified section corresponding RDF graph G. RDF syntax ontology document document accessible given IRI be parsed RDF graph, then be transformed OWL ontology canonical parsing process instantiated specified section. following sections contain rules triple patterns are matched G. Note triple pattern variable number triples, maximal possible subset G MUST be matched. following notation used patterns: notation NN_INT(n) be matched literal value n nonnegative integer. Possible conditions pattern are enclosed curly braces patterns use optional parts, are enclosed square brackets abbreviation T(SEQ y1 yn) pattern corresponding RDF lists, shown Table list pattern matched G, list variables j MUST be matched different nodes; furthermore, MUST NOT be possible match list pattern maximal subsets G such list variable first pattern instance matched same node different) variable second pattern instance. necessary order detect malformed lists such lists internal cycles, lists share tails, lists cross. Table Patterns Corresponding RDF Lists Sequence S Triples Corresponding T(S) Main Node T(S) SEQ rdf:nil SEQ y _:x rdf:first y _:x rdf:rest rdf:nil _:x SEQ y1 yn n>1 _:x1 rdf:first y1 _:x1 rdf:rest _:x2 _:xn rdf:first yn _:xn rdf:rest rdf:nil _:x1 Extracting Declarations IRIs Directly Imported Ontology Documents section result step CP canonical parsing process RDF graph G. Resolving Included RDF Graphs backwards compatibility OWL DL, G owl:imports triple pointing RDF document encoding RDF graph G' G' not have ontology header, owl:imports triple interpreted include rather import triples G' are included G are not parsed separate ontology. achieve following transformation applied G long following rule applicable G. G pair triples form rdf:type owl:Ontology owl:imports values have not already been considered, following actions are performed: document accessible IRI retrieved using augmented retrieval process Section OWL Specification Specification]. document parsed RDF graph G'. parsing graph G' not contain triple form rdf:type owl:Ontology. then G' merged RDF Semantics Semantics]) G triple owl:imports removed G. Parsing Ontology Header Declarations Next, ontology header extracted G matching patterns Table G. MUST be possible match exactly such pattern G exactly way. matched triples are removed G. set Imp(G) IRIs ontology documents are directly imported G exactly are matched pattern. Table Parsing Ontology Header G pattern... ontology header form. rdf:type owl:Ontology owl:versionIRI owl:imports owl:imports k following triple pattern be matched G: u w u rdf:type owl:Ontology w rdf:type owl:OntologyProperty Ontology( Import( Import( _:x rdf:type owl:Ontology _:x owl:imports _:x owl:imports k following triple pattern be matched G: u w _:x u rdf:type owl:Ontology w rdf:type owl:OntologyProperty Ontology( Import( Import( Next, backwards compatibility OWL DL, certain redundant triples are removed G. particular, triple pattern left-hand side Table matched G, then triples right-hand side Table are removed G. Table Triples be Removed Backwards Compatibility OWL DL G pattern... triples are removed G. rdf:type owl:Ontology rdf:type owl:Ontology rdf:type owl:Class rdf:type rdfs:Class rdf:type rdfs:Class rdf:type rdfs:Datatype rdf:type rdfs:Class rdf:type rdfs:Class rdf:type owl:DataRange rdf:type rdfs:Class rdf:type rdfs:Class rdf:type owl:Restriction rdf:type rdfs:Class rdf:type rdfs:Class rdf:type owl:Restriction rdf:type owl:Class rdf:type owl:Class rdf:type owl:ObjectProperty rdf:type rdf:Property rdf:type rdf:Property rdf:type owl:FunctionalProperty rdf:type rdf:Property rdf:type rdf:Property rdf:type owl:InverseFunctionalProperty rdf:type rdf:Property rdf:type rdf:Property rdf:type owl:TransitiveProperty rdf:type rdf:Property rdf:type rdf:Property rdf:type owl:DatatypeProperty rdf:type rdf:Property rdf:type rdf:Property rdf:type owl:AnnotationProperty rdf:type rdf:Property rdf:type rdf:Property rdf:type owl:OntologyProperty rdf:type rdf:Property rdf:type rdf:Property rdf:type rdf:List rdf:first y rdf:rest rdf:type rdf:List Next, backwards compatibility OWL DL, G modified such declarations be properly extracted step. triple pattern first column Table matched G, matching triples are replaced G triples second column. matching phase stops matching pattern replacing specified not change G. Note G set thus contain duplicate triples, so last condition infinite matches. Table Additional Declaration Triples G pattern... matched triples are replaced G triples. rdf:type owl:OntologyProperty rdf:type owl:AnnotationProperty rdf:type owl:InverseFunctionalProperty rdf:type owl:ObjectProperty rdf:type owl:InverseFunctionalProperty rdf:type owl:TransitiveProperty rdf:type owl:ObjectProperty rdf:type owl:TransitiveProperty rdf:type owl:SymmetricProperty rdf:type owl:ObjectProperty rdf:type owl:SymmetricProperty Next, set declarations Decl(G) extracted G according Table matched triples are not removed G triples Table contain annotations so, order correctly parse annotations, be matched again step described Section Table Parsing Declarations G G pattern... declaration added Decl(G). rdf:type owl:Class Declaration( Class( rdf:type rdfs:Datatype Declaration( Datatype( rdf:type owl:ObjectProperty Declaration( ObjectProperty( rdf:type owl:DatatypeProperty Declaration( DataProperty( rdf:type owl:AnnotationProperty Declaration( AnnotationProperty( rdf:type owl:NamedIndividual Declaration( NamedIndividual( _:x rdf:type owl:Axiom _:x owl:annotatedSource _:x owl:annotatedProperty rdf:type _:x owl:annotatedTarget owl:Class Declaration( Class( _:x rdf:type owl:Axiom _:x owl:annotatedSource _:x owl:annotatedProperty rdf:type _:x owl:annotatedTarget rdfs:Datatype Declaration( Datatype( _:x rdf:type owl:Axiom _:x owl:annotatedSource _:x owl:annotatedProperty rdf:type _:x owl:annotatedTarget owl:ObjectProperty Declaration( ObjectProperty( _:x rdf:type owl:Axiom _:x owl:annotatedSource _:x owl:annotatedProperty rdf:type _:x owl:annotatedTarget owl:DatatypeProperty Declaration( DataProperty( _:x rdf:type owl:Axiom _:x owl:annotatedSource _:x owl:annotatedProperty rdf:type _:x owl:annotatedTarget owl:AnnotationProperty Declaration( AnnotationProperty( _:x rdf:type owl:Axiom _:x owl:annotatedSource _:x owl:annotatedProperty rdf:type _:x owl:annotatedTarget owl:NamedIndividual Declaration( NamedIndividual( Finally, set RIND blank nodes used reification identified. done initially setting RIND = then applying patterns shown Table matched triples are not deleted G. Table Identifying Reification Blank Nodes G pattern, then _:x added RIND. _:x rdf:type owl:Axiom _:x rdf:type owl:Annotation _:x rdf:type owl:AllDisjointClasses _:x rdf:type owl:AllDisjointProperties _:x rdf:type owl:AllDifferent _:x rdf:type owl:NegativePropertyAssertion Populating Ontology section result step CP canonical parsing process RDF graph G, corresponding instance OG Ontology class, set AllDecl(G) declarations G computed specified step CP canonical parsing process. Analyzing Declarations following functions map IRI blank node occurring G object structural specification. particular, CE(x) maps class expression, DR(x) maps data range, OPE(x) maps object property expression, DPE(x) maps data property expression, AP(x) maps annotation property. Initially, functions are undefined IRIs blank nodes occurring G; written CE(x) = ?, DR(x) = ?, OPE(x) = ?, DPE(x) = ?, AP(x) = ?. functions are updated parsing following conditions MUST be satisfied given point time parsing. x, most OPE(x), DPE(x), AP(x) defined. x, most CE(x) DR(x) defined. Furthermore, value functions MUST NOT be redefined parsing function not undefined x, attempt be made change function's value x). Functions CE, DR, OPE, DPE, AP are initialized shown Table Table Initialization CE, DR, OPE, DPE, AP AllDecl(G) declaration... perform assignment. Declaration( Class( CE(*:x) class IRI Declaration( Datatype( DR(*:x) datatype IRI Declaration( ObjectProperty( OPE(*:x) object property IRI Declaration( DataProperty( DPE(*:x) data property IRI Declaration( AnnotationProperty( AP(*:x) annotation property IRI Parsing Annotations annotations G are parsed next. function ANN set annotations ANN(x) IRI blank node x. function initialized setting ANN(x) = IRI blank node x. Next, triple patterns Table are matched G matched pattern, ANN(x) extended annotation right column. time triple patterns matched, matched triples are removed G. process repeated further matches are possible. Table Parsing Annotations G pattern... annotation added ANN(x). xlt AP(*:y) ? there blank node such G following triples: rdf:type owl:Annotation owl:annotatedSource owl:annotatedProperty owl:annotatedTarget xlt Annotation( xlt xlt rdf:type owl:Annotation owl:annotatedSource owl:annotatedProperty owl:annotatedTarget xlt AP(*:y) ? other triple G subject object position Annotation( ANN(_:w) xlt Parsing Ontology Annotations Let be node was matched G _:x according patterns Table then, ANN(x) set ontology annotations OG. Parsing Expressions Next, functions OPE, DR, CE are extended shown Tables well Tables patterns latter tables are not generated mapping Section be present RDF graphs encode OWL DL ontologies. time pattern matched, matched triples are removed G. Pattern matching repeated triple pattern be matched G. Table Parsing Object Property Expressions G pattern... OPE(_:x) set object property expression. _:x owl:inverseOf OPE(_:x) = ? OPE(*:y) ? ObjectInverseOf( OPE(*:y) Table Parsing Data Ranges G pattern... DR(_:x) set data range. _:x rdf:type rdfs:Datatype _:x owl:intersectionOf T(SEQ y1 yn) n DR(yi) ? n DataIntersectionOf( DR(y1) DR(yn) _:x rdf:type rdfs:Datatype _:x owl:unionOf T(SEQ y1 yn) n DR(yi) ? n DataUnionOf( DR(y1) DR(yn) _:x rdf:type rdfs:Datatype _:x owl:datatypeComplementOf y DR(y) ? DataComplementOf( DR(y) _:x rdf:type rdfs:Datatype _:x owl:oneOf T(SEQ lt1 ltn) n DataOneOf( lt1 ltn _:x rdf:type rdfs:Datatype _:x owl:onDatatype _:x owl:withRestrictions T(SEQ _:z1 _:zn) _:z1 lt1 _:zn ltn DR(*:y) datatype DatatypeRestriction( DR(*:y) lt1 ltn Table Parsing Class Expressions G pattern... CE(_:x) set class expression. _:x rdf:type owl:Class _:x owl:intersectionOf T(SEQ y1 yn) n CE(yi) ? n ObjectIntersectionOf( CE(y1) CE(yn) _:x rdf:type owl:Class _:x owl:unionOf T(SEQ y1 yn) n CE(yi) ? n ObjectUnionOf( CE(y1) CE(yn) _:x rdf:type owl:Class _:x owl:complementOf y CE(y) ? ObjectComplementOf( CE(y) _:x rdf:type owl:Class _:x owl:oneOf T(SEQ n ObjectOneOf( _:x rdf:type owl:Restriction _:x owl:onProperty y _:x owl:someValuesFrom OPE(y) ? CE(z) ? ObjectSomeValuesFrom( OPE(y) CE(z) _:x rdf:type owl:Restriction _:x owl:onProperty y _:x owl:allValuesFrom OPE(y) ? CE(z) ? ObjectAllValuesFrom( OPE(y) CE(z) _:x rdf:type owl:Restriction _:x owl:onProperty y _:x owl:hasValue OPE(y) ? ObjectHasValue( OPE(y) _:x rdf:type owl:Restriction _:x owl:onProperty y _:x owl:hasSelf OPE(y) ? ObjectHasSelf( OPE(y) _:x rdf:type owl:Restriction _:x owl:minQualifiedCardinality NN_INT(n) _:x owl:onProperty y _:x owl:onClass OPE(y) ? CE(z) ? ObjectMinCardinality( n OPE(y) CE(z) _:x rdf:type owl:Restriction _:x owl:maxQualifiedCardinality NN_INT(n) _:x owl:onProperty y _:x owl:onClass OPE(y) ? CE(z) ? ObjectMaxCardinality( n OPE(y) CE(z) _:x rdf:type owl:Restriction _:x owl:qualifiedCardinality NN_INT(n) _:x owl:onProperty y _:x owl:onClass OPE(y) ? CE(z) ? ObjectExactCardinality( n OPE(y) CE(z) _:x rdf:type owl:Restriction _:x owl:minCardinality NN_INT(n) _:x owl:onProperty y OPE(y) ? ObjectMinCardinality( n OPE(y) _:x rdf:type owl:Restriction _:x owl:maxCardinality NN_INT(n) _:x owl:onProperty y OPE(y) ? ObjectMaxCardinality( n OPE(y) _:x rdf:type owl:Restriction _:x owl:cardinality NN_INT(n) _:x owl:onProperty y OPE(y) ? ObjectExactCardinality( n OPE(y) _:x rdf:type owl:Restriction _:x owl:onProperty y _:x owl:hasValue lt DPE(y) ? DataHasValue( DPE(y) lt _:x rdf:type owl:Restriction _:x owl:onProperty y _:x owl:someValuesFrom DPE(y) ? DR(z) ? DataSomeValuesFrom( DPE(y) DR(z) _:x rdf:type owl:Restriction _:x owl:onProperties T(SEQ y1 yn) _:x owl:someValuesFrom n DPE(yi) ? n, DR(z) ? DataSomeValuesFrom( DPE(y1) DPE(yn) DR(z) _:x rdf:type owl:Restriction _:x owl:onProperty y _:x owl:allValuesFrom DPE(y) ? DR(z) ? DataAllValuesFrom( DPE(y) DR(z) _:x rdf:type owl:Restriction _:x owl:onProperties T(SEQ y1 yn) _:x owl:allValuesFrom n DPE(yi) ? n, DR(z) ? DataAllValuesFrom( DPE(y1) DPE(yn) DR(z) _:x rdf:type owl:Restriction _:x owl:minQualifiedCardinality NN_INT(n) _:x owl:onProperty y _:x owl:onDataRange DPE(y) ? DR(z) ? DataMinCardinality( n DPE(y) DR(z) _:x rdf:type owl:Restriction _:x owl:maxQualifiedCardinality NN_INT(n) _:x owl:onProperty y _:x owl:onDataRange DPE(y) ? DR(z) ? DataMaxCardinality( n DPE(y) DR(z) _:x rdf:type owl:Restriction _:x owl:qualifiedCardinality NN_INT(n) _:x owl:onProperty y _:x owl:onDataRange DPE(y) ? DR(z) ? DataExactCardinality( n DPE(y) DR(z) _:x rdf:type owl:Restriction _:x owl:minCardinality NN_INT(n) _:x owl:onProperty y DPE(y) ? DataMinCardinality( n DPE(y) _:x rdf:type owl:Restriction _:x owl:maxCardinality NN_INT(n) _:x owl:onProperty y DPE(y) ? DataMaxCardinality( n DPE(y) _:x rdf:type owl:Restriction _:x owl:cardinality NN_INT(n) _:x owl:onProperty y DPE(y) ? DataExactCardinality( n DPE(y) Table Parsing Data Ranges Compatibility OWL DL G pattern... DR(_:x) set object property expression. _:x rdf:type owl:DataRange _:x owl:oneOf T(SEQ lt1 ltn) n DataOneOf( lt1 ltn _:x rdf:type owl:DataRange _:x owl:oneOf T(SEQ) DataComplementOf( rdfs:Literal Table Parsing Class Expressions Compatibility OWL DL G pattern... CE(_:x) set class expression. _:x rdf:type owl:Class _:x owl:unionOf T(SEQ) owl:Nothing _:x rdf:type owl:Class _:x owl:unionOf T(SEQ y) CE(y) ? CE(y) _:x rdf:type owl:Class _:x owl:intersectionOf T(SEQ) owl:Thing _:x rdf:type owl:Class _:x owl:intersectionOf T(SEQ y) CE(y) ? CE(y) _:x rdf:type owl:Class _:x owl:oneOf T(SEQ) owl:Nothing Parsing Axioms Next, OG populated axioms. clarity, axiom patterns are split tables. Table presents patterns axioms annotations. Annotated axioms are parsed case patterns owl:AllDisjointClasses, owl:AllDisjointProperties, owl:AllDifferent, owl:NegativePropertyAssertion, axiom annotations are defined ANN(_:x). other axioms, axiom annotations are obtained additionally matching patterns Table G axiom matching. axioms G are parsed annotated axioms are parsed first. Only pattern annotated axioms be matched G, then patterns axioms annotations are matched. case, time triple pattern matched, matched triples are removed G. Table Parsing Axioms Annotations G pattern... following axiom added OG. rdf:type owl:Class Declaration( Class( rdf:type rdfs:Datatype Declaration( Datatype( rdf:type owl:ObjectProperty Declaration( ObjectProperty( rdf:type owl:DatatypeProperty Declaration( DataProperty( rdf:type owl:AnnotationProperty Declaration( AnnotationProperty( rdf:type owl:NamedIndividual Declaration( NamedIndividual( rdfs:subClassOf y CE(x) ? CE(y) ? SubClassOf( CE(x) CE(y) owl:equivalentClass y CE(x) ? CE(y) ? EquivalentClasses( CE(x) CE(y) owl:disjointWith y CE(x) ? CE(y) ? DisjointClasses( CE(x) CE(y) _:x rdf:type owl:AllDisjointClasses _:x owl:members T(SEQ y1 yn) n CE(yi) ? n DisjointClasses( CE(y1) CE(yn) owl:disjointUnionOf T(SEQ y1 yn) n CE(x) ?, CE(yi) ? n DisjointUnion( CE(*:x) CE(y1) CE(yn) rdfs:subPropertyOf y OPE(x) ? OPE(y) ? SubObjectPropertyOf( OPE(x) OPE(y) owl:propertyChainAxiom T(SEQ y1 yn) n OPE(yi) ? n, OPE(x) ? SubObjectPropertyOf( ObjectPropertyChain( OPE(y1) OPE(yn) OPE(x) owl:equivalentProperty y OPE(x) ? OPE(y) ? EquivalentObjectProperties( OPE(x) OPE(y) owl:propertyDisjointWith y OPE(x) ? OPE(y) ? DisjointObjectProperties( OPE(x) OPE(y) _:x rdf:type owl:AllDisjointProperties _:x owl:members T(SEQ y1 yn) n OPE(yi) ? n DisjointObjectProperties( OPE(y1) OPE(yn) rdfs:domain y OPE(x) ? CE(y) ? ObjectPropertyDomain( OPE(x) CE(y) rdfs:range y OPE(x) ? CE(y) ? ObjectPropertyRange( OPE(x) CE(y) owl:inverseOf y OPE(x) ? OPE(y) ? InverseObjectProperties( OPE(x) OPE(y) rdf:type owl:FunctionalProperty OPE(x) ? FunctionalObjectProperty( OPE(x) rdf:type owl:InverseFunctionalProperty OPE(x) ? InverseFunctionalObjectProperty( OPE(x) rdf:type owl:ReflexiveProperty OPE(x) ? ReflexiveObjectProperty( OPE(x) rdf:type owl:IrreflexiveProperty OPE(x) ? IrreflexiveObjectProperty( OPE(x) rdf:type owl:SymmetricProperty OPE(x) ? SymmetricObjectProperty( OPE(x) rdf:type owl:AsymmetricProperty OPE(x) ? AsymmetricObjectProperty( OPE(x) rdf:type owl:TransitiveProperty OPE(x) ? TransitiveObjectProperty( OPE(x) rdfs:subPropertyOf y DPE(x) ? DPE(y) ? SubDataPropertyOf( DPE(x) DPE(y) owl:equivalentProperty y DPE(x) ? DPE(y) ? EquivalentDataProperties( DPE(x) DPE(y) owl:propertyDisjointWith y DPE(x) ? DPE(y) ? DisjointDataProperties( DPE(x) DPE(y) _:x rdf:type owl:AllDisjointProperties _:x owl:members T(SEQ y1 yn) n DPE(yi) ? n DisjointDataProperties( DPE(y1) DPE(yn) rdfs:domain y DPE(x) ? CE(y) ? DataPropertyDomain( DPE(x) CE(y) rdfs:range y DPE(x) ? DR(y) ? DataPropertyRange( DPE(x) DR(y) rdf:type owl:FunctionalProperty DPE(x) ? FunctionalDataProperty( DPE(x) owl:equivalentClass y DR(*:x) ? DR(y) ? DatatypeDefinition( DR(*:x) DR(y) owl:hasKey T(SEQ y1 yk) CE(x) ?, sequence y1 yk be partitioned disjoint sequences z1 zm w1 wn such m > n > OPE(zi) ? m DPE(wj) ? j n HasKey( CE(x) OPE(z1) OPE(zm) DPE(w1) DPE(wn) owl:sameAs y SameIndividual( y owl:differentFrom y DifferentIndividuals( y _:x rdf:type owl:AllDifferent _:x owl:members T(SEQ x1 xn) n DifferentIndividuals( x1 xn _:x rdf:type owl:AllDifferent _:x owl:distinctMembers T(SEQ x1 xn) n DifferentIndividuals( x1 xn rdf:type y CE(y) ? ClassAssertion( CE(y) OPE(*:y) ? ObjectPropertyAssertion( OPE(*:y) _:x rdf:type owl:NegativePropertyAssertion _:x owl:sourceIndividual w _:x owl:assertionProperty y _:x owl:targetIndividual OPE(y) ? NegativeObjectPropertyAssertion( OPE(y) w lt DPE(*:y) ? DataPropertyAssertion( DPE(*:y) lt _:x rdf:type owl:NegativePropertyAssertion _:x owl:sourceIndividual w _:x owl:assertionProperty y _:x owl:targetValue lt DPE(y) ? NegativeDataPropertyAssertion( DPE(y) w lt rdf:type owl:DeprecatedClass AnnotationAssertion( owl:deprecated rdf:type owl:DeprecatedProperty AnnotationAssertion( owl:deprecated rdfs:subPropertyOf AP(*:x) ? AP(*:y) ? SubAnnotationPropertyOf( AP(*:x) AP(*:y) rdfs:domain AP(*:x) ? AnnotationPropertyDomain( AP(*:x) rdfs:range AP(*:x) ? AnnotationPropertyRange( AP(*:x) Table Parsing Annotated Axioms G pattern... following axiom added OG. s xlt _:x rdf:type owl:Axiom _:x owl:annotatedSource s _:x owl:annotatedProperty _:x owl:annotatedTarget xlt s xlt main triple axiom according Table G possible necessary side triples axiom result axiom corresponding s xlt possible side triples) additionally annotations ANN(_:x). Next, blank node IRI such RIND, annotationAnnotation( annotation1 annotationn AP y ANN(x) n possibly being equal following annotation assertion added OG: AnnotationAssertion( annotation1 annotationn AP y Finally, patterns Table are matched G resulting axioms are added OG. patterns are not generated mapping Section be present RDF graphs encode OWL DL ontologies. patterns table do not contain triples form rdf:type owl:Class such triples are removed parsing entity declarations, specified Section time triple pattern matched, matched triples are removed G. Table Parsing Axioms Compatibility OWL DL G pattern... following axiom added OG. owl:complementOf y CE(*:x) ? CE(y) ? EquivalentClasses( CE(*:x) ObjectComplementOf( CE(y) owl:unionOf T(SEQ) CE(*:x) ? EquivalentClasses( CE(*:x) owl:Nothing owl:unionOf T(SEQ y) CE(*:x) ? CE(y) ? EquivalentClasses( CE(*:x) CE(y) owl:unionOf T(SEQ y1 yn) n CE(*:x) ?, CE(yi) ? n EquivalentClasses( CE(*:x) ObjectUnionOf( CE(y1) CE(yn) owl:intersectionOf T(SEQ) CE(*:x) ? EquivalentClasses( CE(*:x) owl:Thing owl:intersectionOf T(SEQ y) CE(*:x) ? CE(y) ? EquivalentClasses( CE(*:x) CE(y) owl:intersectionOf T(SEQ y1 yn) n CE(*:x) ?, CE(yi) ? n EquivalentClasses( CE(*:x) ObjectIntersectionOf( CE(y1) CE(yn) owl:oneOf T(SEQ) CE(*:x) ? EquivalentClasses( CE(*:x) owl:Nothing owl:oneOf T(SEQ n CE(*:x) ? EquivalentClasses( CE(*:x) ObjectOneOf( end process, graph G MUST be empty. Appendix: Change Log Changes Recommendation section changes document Recommendation October, publication XML Schema Definition Language Part Datatypes Recommendation April elements OWL are based XSD are now considered required, note detailing optional dependency XSD Candidate Recommendation April, been removed Document" section. Minor typographical errors were corrected detailed OWL Errata page. Changes Proposed Recommendation section changes document Proposed Recommendation September, arguments ClassAssertion axiom Table were swapped bring axiom line functional-style syntax. Changes Candidate Recommendation section changes document Candidate Recommendation June, minor bugs were fixed reverse mappings inverseOf hasKey. Changes Last Call section changes document Last Call Working Draft April, RDF vocabulary annotations was changed: owl:subject, owl:predicate owl:object became, respectively, owl:annotatedSource, owl:annotatedProperty owl:annotatedTarget. Several lists syntax were updated track previous change Structural Specification Functional-Style Syntax. examples were fixed. minor editorial changes were made. Acknowledgments starting point development OWL was OWL1.1 member submission, result user developer feedback, particular information gathered OWL Experiences Directions Workshop series. working group also considered postponed issues WebOnt Working Group. document been produced OWL Working Group contents reflect extensive discussions Working Group whole.The editors extend special thanks toMarkus Krötzsch Ruttenberg Commons),Uli Sattler Manchester),Michael Schneider andEvren Sirin Parsia)for thorough reviews. regular attendees meetings OWL Working Group time publication document were:Jie Bao Calvanese University Bozen-Bolzano),Bernardo Cuenca Grau University Computing Laboratory),Martin Dzbor University),Achille Fokoue Corporation),Christine Golbreich Versailles St-Quentin LIRMM),Sandro Hawke Herman Hoekstra Amsterdam),Ian Horrocks University Computing Laboratory),Elisa Kendall Software),Markus Krötzsch Lutz Bremen),Deborah L. McGuinness Motik University Computing Laboratory),Jeff Pan Aberdeen),Bijan Parsia Manchester),Peter F. Patel-Schneider Labs Research, Alcatel-Lucent),Sebastian Rudolph Ruttenberg Commons),Uli Sattler Manchester),Michael Schneider Smith Parsia),Evan Wallace Wu Corporation), andAntoine Zimmermann Galway).We also thank members working group:Jeremy Carroll,Jim Hendler, andVipul Kashyap. References Specification] OWL Web Ontology Language: Structural Specification Functional-Style Syntax Edition) Boris Motik, Peter F. Patel-Schneider, Bijan Parsia, eds. W3C Recommendation, December http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/. Latest version available http://www.w3.org/TR/owl2-syntax/. Concepts] Resource Description Framework Concepts Abstract Syntax. Graham Klyne Jeremy J. Carroll, eds. W3C Recommendation, February http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/. Latest version available http://www.w3.org/TR/rdf-concepts/. Semantics] RDF Semantics. Patrick Hayes, ed., W3C Recommendation, February http://www.w3.org/TR/2004/REC-rdf-mt-20040210/. Latest version available http://www.w3.org/TR/rdf-mt/. RFC Key words use RFCs Indicate Requirement Levels. Network Working Group, S. Bradner. IETF, March http://www.ietf.org/rfc/rfc2119.txt 